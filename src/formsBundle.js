(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _expected_api_version;

  var _activeTab = null;
  var _tabs = null;
  var _use_tiled_background = false;
  var _currentFilters = null;
  util.inherits(DateSelector, _events);

  function DateSelector(options) {
    _token = options.token;
    _baseHref = options.baseHref;
    _device = options.device;
    _expected_api_version = options.expected_api_version;
    _use_tiled_background = options.use_tiled_background;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "DateSelector.js", "DateSelector module loaded", "success");
    }, 700);
    setTimeout(function () {
      getDatesForm(_use_tiled_background, function (err, msg) {
        if (err) {
          _self.emit("log", "DateSelector.js", "getDatesForm error", "error", msg);

          return false;
        }

        _self.emit("log", "DateSelector.js", "getDatesForm on start module", "success", _currentFilters);

        if (_currentFilters) {
          _self.emit("notifyToMap", "DateFilters ready", _currentFilters);
        }
      });
    }, 910);
  }

  function setToken(token) {
    _token = token;
  } //****************************************************************
  //*****************         GET DATES FORM         ***************
  //****************************************************************

  /***
  	getDatesForm
  		gets dateselector form
  			@scope public
  		@param cb<function>
  	***/


  function getDatesForm(use_tiled_background, cb) {
    _self.emit("log", "DateSelector.js", "getDatesForm()", "info");

    var dataToSend = {};
    dataToSend.device = _device;
    dataToSend.use_tiled_background = use_tiled_background;
    dataToSend.token = _token;
    dataToSend.what = 'GET_DATES_SELECTOR_FORM';
    dataToSend.expected_api_version = _expected_api_version;
    var retorno = {};
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      try {
        if (response.data.status === "Accepted") {
          _self.emit("log", "DateSelector.js", "getDatesForm", "success", response.data.message);

          if (typeof response.data.message.formTabs != "undefined") {
            retorno = response.data.message.formTabs;
            _tabs = response.data.message.formTabs; //add a button

            retorno[0].buttons = [_createButton("Filtrar", "dateSelector", "filterDateAction", false)]; //set active tab

            var activeTabIndex = _getActiveTab(response.data.message.formTabs);

            retorno.activeTab = response.data.message.formTabs[activeTabIndex];
            retorno.activeTab.activeTabIndex = activeTabIndex;
            retorno.formName = response.data.message.formInfo.formName;

            if (retorno.activeTab.fields[0].value) {
              _currentFilters = {
                'date_from': retorno.activeTab.fields[0].value,
                'date_to': retorno.activeTab.fields[1].value
              };
            }

            cb(null, retorno);
          }
        } else {
          cb(body.status, body.message);
        }
      } catch (e) {
        _self.emit("log", "DateSelector.js", "getDatesForm", "error", e.message);

        cb("Error in getDatesForm: " + e.message, null);
      }
    })["catch"](function (error) {
      _self.emit("log", "DateSelector.js", "getDatesForm", "error", error);
    });
  } //****************************************************************
  //*************            END GET FILTERS         ***************
  //****************************************************************
  //****************************************************************
  //*****************        SET FILTER DATE         ***************
  //****************************************************************

  /***
  	setFilterDate
  
  		@scope public
  		@param formData<object>
  		@param extent<string>
  			@param cb<function>
  	***/


  function setFilterDate(formData, cb) {
    _self.emit("log", "DateSelector.js", "setFilterDate()", "info", formData);

    var dataToSend = {};
    dataToSend.device = _device; //dynamic attributes

    for (var k in formData) {
      if (formData.hasOwnProperty(k)) {
        if (formData[k] != "") {
          dataToSend[k] = formData[k];
        } else if (formData[k] === 0) {
          dataToSend[k] = "0";
        }
      }
    }

    dataToSend.token = _token;
    dataToSend.what = 'SET_FILTER_DATE';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      try {
        if (response.data.status === "Accepted") {
          _self.emit("log", "DateSelector.js", "setFilterDate", "success", response.data.message);

          cb(null, response.data);
        } else {
          cb(response.data, response.data);
        }
      } catch (e) {
        _self.emit("log", "DateSelector.js", "setFilterDate", "error", e.message);

        cb("Error in setFilterDate: " + e.message, null);
      }
    })["catch"](function (error) {
      _self.emit("log", "DateSelector.js", "setFilterDate", "error", error);
    });
  } //****************************************************************
  //*****************       END SET FILTER DATE      ***************
  //****************************************************************
  //****************************************************************
  //*************            SETTERS/GETTERS         ***************
  //****************************************************************

  /***
  	_createButton
  		creates JSON for form button component
  			@scope private
  		@param label<string>
  		@param name<string>
  		@param action<string>
  		@param disabled<boolean>
  			@return <json>
  	***/


  function _createButton(label, name, action, disabled) {
    var retorno = {};
    retorno.buttonAction = action;
    retorno.disabled = disabled;
    retorno.label = label;
    retorno.name = name;
    retorno.type = "button";
    return retorno;
  }

  function _getActiveTab(tabs) {
    if (tabs.length > 0) {
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].active) {
          return i;
          break;
        }
      }
    }
  } //****************************************************************
  //*************          END SETTERS/GETTERS       ***************
  //****************************************************************


  module.exports = DateSelector;
  DateSelector.prototype.getDatesForm = getDatesForm;
  DateSelector.prototype.setFilterDate = setFilterDate;
  DateSelector.prototype.setToken = setToken;
})();

},{"axios":10,"events":84,"util":109}],2:[function(require,module,exports){
"use strict";

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var _project_type = "ws"; //<string> ws or ud

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _expected_api_version;

  util.inherits(EventsSewernet, _events);

  function EventsSewernet(options) {
    if (typeof options.project_type !== "undefined") {
      _project_type = options.project_type.toLowerCase();
    }

    _token = options.token;
    _baseHref = options.baseHref;
    _device = options.device;
    _expected_api_version = options.expected_api_version;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "EventsSewernet.js", "Visits loaded", "success");
    }, 500);
  }

  function setToken(token) {
    _token = token;
  }

  function _setFieldValue(name, value, fields, disabled) {
    for (var i = 0; i < fields.length; i++) {
      if (fields[i].name === name) {
        fields[i].value = value;
        fields[i].disabled = disabled;
        break;
      }
    }

    return fields;
  }

  function _addInternalKeysToFields(fields, key, value) {
    for (var i = 0; i < fields.length; i++) {
      fields[i][key] = value;
    }
  }

  function _assignValuesToCombo(object) {
    var comboValues = Array();

    try {
      for (var i = 0; i < object.comboKeys.length; i++) {
        comboValues.push({
          id: object.comboKeys[i],
          name: object.comboValues[i]
        });
      }

      return comboValues;
    } catch (e) {
      _self.emit("log", "EventsSewernet.js", "getEventFormTypeAndEvent error formatting combo", "error", e.message);

      return false;
    }
  } //****************************************************************
  //*******************     GET EVENT FORM TYPE     ****************
  //****************************************************************


  function getEventFormTypeAndEvent(visit_parameter_id, pol_id, id_name, layer, cb) {
    _self.emit("log", "EventsSewernet.js", "getEventFormTypeAndEvent(" + visit_parameter_id + "," + pol_id + "," + id_name + "," + layer + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.visit_parameter_id = visit_parameter_id;
    dataToSend.arc_id = pol_id;
    dataToSend.id_name = id_name;
    dataToSend.token = _token;
    dataToSend.what = 'GET_EVENT_FORM_TYPE_AND_EVENT';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      _self.emit("log", "EventsSewernet.js", "getEventFormTypeAndEvent", "success", response.data);

      if (response.data.status === "Accepted") {
        try {
          var retorno = {};
          retorno.formToDisplay = response.data.message.formToDisplay;
          retorno.fields = response.data.message.fields;

          for (var i = 0; i < retorno.fields.length; i++) {
            if (retorno.fields[i].type === "combo") {
              retorno.fields[i].comboValues = _assignValuesToCombo(retorno.fields[i]);
            }
          }

          retorno.fields = _setFieldValue('parameter_id', visit_parameter_id, response.data.message.fields, true);

          _addInternalKeysToFields(retorno.fields, 'formDataContainer', 'eventData');

          _addInternalKeysToFields(retorno.fields, 'changeAction', 'updateEvent'); //retorno.position 	= body.message.position;


          cb(null, retorno);
        } catch (e) {
          _self.emit("log", "EventsSewernet.js", "getEventFormTypeAndEvent", "error", e.message);

          cb("Error in event: " + e.message, null);
        }
      } else {
        _self.emit("log", "EventsSewernet.js", "getEventFormTypeAndEvent", "warn", response.data.message);

        cb(response.data.code, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "DateSelector.js", "getEventFormTypeAndEvent", "error", error);
    });
  } //****************************************************************
  //*****************    END GET EVENT FORM TYPE     ***************
  //****************************************************************
  //****************************************************************
  //*****************          INSERT EVENT          ***************
  //****************************************************************


  function insertEvent(layer, visit_id, pol_id, id_name, eventData, formId, photos, compasses, cb) {
    _self.emit("log", "EventsSewernet.js", "insertEvent(" + layer + "," + visit_id + "," + pol_id + "," + id_name + "," + formId + ")", "info", [eventData, photos, compasses]);

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.visit_id = visit_id;
    dataToSend.pol_id = pol_id;
    dataToSend.id_name = id_name;
    dataToSend.formId = formId; //dynamic attributes

    for (var k in eventData) {
      if (eventData.hasOwnProperty(k)) {
        dataToSend[k] = eventData[k];
      }
    }

    dataToSend.photos = photos;
    dataToSend.compasses = compasses;
    dataToSend.token = _token;
    dataToSend.what = 'INSERT_EVENT';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      try {
        if (response.data.status === "Accepted") {
          _self.emit("log", "EventsSewernet.js", "insertEvent", "success", response.data.message);

          cb(null, response.data.message.event_id);
        } else {
          cb(response.data.status, response.data.message);
        }
      } catch (e) {
        _self.emit("log", "EventsSewernet.js", "insertEvent", "error", e.message);

        cb("Error in event: " + e.message, null);
      }
    })["catch"](function (error) {
      _self.emit("log", "DateSelector.js", "insertEvent", "error", error);
    });
  } //****************************************************************
  //*****************        END INSERT EVENT        ***************
  //****************************************************************


  function getEvent(layer, event_id, pol_id, id_name, cb) {
    _self.emit("log", "EventsSewernet.js", "getEvent(" + layer + "," + event_id + "," + pol_id + "," + id_name + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.event_id = event_id;
    dataToSend.pol_id = pol_id;
    dataToSend.id_name = id_name;
    dataToSend.token = _token;
    dataToSend.what = 'GET_EVENT';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      try {
        if (response.data.status === "Accepted") {
          _self.emit("log", "EventsSewernet.js", "getEvent", "success", response.data.message);

          try {
            var retorno = {};
            retorno.event_data = response.data.message.event_data;
            retorno.formToDisplay = response.data.message.form_data.formToDisplay;
            retorno.fields = response.data.message.form_data.fields;

            for (var i = 0; i < retorno.fields.length; i++) {
              if (retorno.fields[i].type === "combo") {
                retorno.fields[i].comboValues = _assignValuesToCombo(retorno.fields[i]);
                retorno.fields[i].selectedValue = retorno.event_data[retorno.fields[i].name];
              } else {
                var disabled = false;

                if (retorno.fields[i].name === "parameter_id") {
                  disabled = true;
                }

                retorno.fields = _setFieldValue(retorno.fields[i].name, retorno.event_data[retorno.fields[i].name], retorno.fields, disabled);
              }
            }

            _addInternalKeysToFields(retorno.fields, 'formDataContainer', 'eventData');

            _addInternalKeysToFields(retorno.fields, 'changeAction', 'updateEvent');

            cb(null, retorno);
          } catch (e) {
            _self.emit("log", "EventsSewernet.js", "getEvent", "error", e.message);

            cb("Error in event: " + e.message, null);
          }
        } else {
          cb(body.status, body.message);
        }
      } catch (e) {
        _self.emit("log", "EventsSewernet.js", "getEvent", "error", e.message);

        cb("Error in event: " + e.message, null);
      }
    })["catch"](function (error) {
      _self.emit("log", "events.js", "getEvent", "error", error);
    });
  }

  function deleteEvent(layer, event_id, cb) {
    try {
      _self.emit("log", "events.js", "deleteEvent(" + layer + "," + event_id + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.event_id = event_id;
      dataToSend.token = _token;
      dataToSend.what = 'DELETE_EVENT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "events.js", "deleteEvent response", "success", response.data.message);

          cb(null, response.data.message);
        } else {
          cb(response.data.message, false);
        }
      })["catch"](function (error) {
        _self.emit("log", "DateSelector.js", "deleteEvent", "error", error);
      });
    } catch (e) {
      _self.emit("log", "events.js", "deleteEvent error", "error", e);

      cb(e, false);
    }
  }

  function updateEvent(layer, event_id, key, value, pol_id, id_name, cb) {
    try {
      _self.emit("log", "events.js", "updateEvent(" + layer + "," + key + "," + value + "," + pol_id + "," + id_name + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.event_id = event_id;
      dataToSend.key = key;
      dataToSend.value = value;
      dataToSend.token = _token;
      dataToSend.what = 'UPDATE_EVENT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "events.js", "updateEvent response", "success", response.data.message);

          cb(null, response.data.message);
        } else {
          cb(response.data.message, false);
        }
      })["catch"](function (error) {
        _self.emit("log", "events.js", "updateEvent", "error", error);
      });
    } catch (e) {
      _self.emit("log", "events.js", "updateEvent error", "error", e);

      cb(e, false);
    }
  }

  module.exports = EventsSewernet;
  EventsSewernet.prototype.getEventFormTypeAndEvent = getEventFormTypeAndEvent;
  EventsSewernet.prototype.insertEvent = insertEvent;
  EventsSewernet.prototype.getEvent = getEvent;
  EventsSewernet.prototype.updateEvent = updateEvent;
  EventsSewernet.prototype.deleteEvent = deleteEvent;
  EventsSewernet.prototype.setToken = setToken;
})();

},{"axios":10,"events":84,"util":109}],3:[function(require,module,exports){
"use strict";

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var _project_type = "ws"; //<string> ws or ud

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _version = "1.0.1";

  var _expected_api_version;

  util.inherits(FeaturesSewernet, _events);

  function FeaturesSewernet(options) {
    if (typeof options.project_type !== "undefined") {
      _project_type = options.project_type.toLowerCase();
    }

    _token = options.token;
    _baseHref = options.baseHref;
    _device = options.device;
    _expected_api_version = options.expected_api_version;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "features.js", "Module loaded v." + _version, "success");
    }, 500);
  }

  function setToken(token) {
    _token = token;
  }

  function _setFieldValue(name, value, fields, disabled) {
    for (var i = 0; i < fields.length; i++) {
      if (fields[i].name === name) {
        fields[i].value = value;
        fields[i].disabled = disabled;
        break;
      }
    }

    return fields;
  }

  function _getAttributeValue(attributes, name) {
    var retorno;

    for (var i = 0; i < attributes.length; i++) {
      if (attributes[i].name === name) {
        retorno = attributes[i].value;
        break;
      }
    }

    return retorno;
  }

  function _assignValuesToCombo(object) {
    var comboValues = Array();

    try {
      for (var i = 0; i < object.comboIds.length; i++) {
        comboValues.push({
          id: object.comboIds[i],
          name: object.comboNames[i]
        });
      }

      return comboValues;
    } catch (e) {
      _self.emit("log", "features.js", "_assignValuesToCombo error formatting combo", "error", e.message);

      return false;
    }
  }

  function _addInternalKeysToFields(fields, key, value) {
    for (var i = 0; i < fields.length; i++) {
      if (fields[i]) {
        fields[i][key] = value;
      }
    }
  }

  function getInsertFeatureForm(layer, db_table, cb) {
    try {
      _self.emit("log", "features.js", "getInsertFeatureForm(" + layer + "," + db_table + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.db_table = db_table;
      dataToSend.token = _token;
      dataToSend.what = 'GET_INSERT_FEATURE_FORM';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "forms.js", "getWebForms", "success", response.data.message);

        if (response.data.status === "Accepted") {
          _self.emit("log", "features.js", "getInsertFeatureForm response", "success", response.data.message);

          var retorno = {};
          retorno.formToDisplay = response.data.message.formToDisplay;
          retorno.fields = response.data.message.fields;

          for (var i = 0; i < retorno.fields.length; i++) {
            if (retorno.fields[i]) {
              if (retorno.fields[i].type === "combo") {
                retorno.fields[i].comboValues = _assignValuesToCombo(retorno.fields[i]);
              }
            }
          }

          cb(null, retorno);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "form.js", "getInsertFeatureForm", "error", error);
      });
    } catch (e) {
      _self.emit("log", "features.js", "getInsertFeatureForm error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //******************       INSERT FEATURE     ********************
  //****************************************************************


  function insertFeature(layer, db_table, epsg, formData, geometry, cb) {
    _self.emit("log", "features.js", "insertFeature(" + layer + "," + db_table + "," + epsg + ")", "info", formData);

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.db_table = db_table;
    dataToSend.epsg = epsg;
    dataToSend.geometry = geometry; //dynamic attributes

    for (var k in formData) {
      if (formData.hasOwnProperty(k)) {
        if (formData[k] != "") {
          dataToSend[k] = formData[k];
        } else if (formData[k] === 0) {
          dataToSend[k] = "0";
        }
      }
    }

    dataToSend.token = _token;
    dataToSend.what = 'INSERT_FEATURE';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        _self.emit("log", "features.js", "insertFeature response", "success", response.data.message);

        cb(null, response.data.message);
      } else {
        _self.emit("log", "features.js", "insertFeature error on request", "error", response.data.message);

        cb(response.data.message, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "insertFeature", "error", error);

      cb(error, false);
      return false;
    });
  } //****************************************************************
  //******************     END INSERT FEATURE   ********************
  //****************************************************************
  //****************************************************************
  //******************      DELETE FEATURE      ********************
  //****************************************************************


  function deleteFeature(layer, db_table, id_name, id, cb) {
    _self.emit("log", "features.js", "deleteReview(" + layer + "," + db_table + "," + id_name + "," + id + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.db_table = db_table;
    dataToSend.id_name = id_name;
    dataToSend.id = id;
    dataToSend.token = _token;
    dataToSend.what = 'DELETE_FEATURE';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        _self.emit("log", "features.js", "deleteFeature response", "success", response.data.message);

        cb(null, response.data.message);
      } else {
        _self.emit("log", "features.js", "deleteFeature error on request", "error", response.data.message);

        cb(response.data.message, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "deleteFeature", "error", error);

      cb(error, false);
      return false;
    });
  } //****************************************************************
  //*****************    END DELETE FEATURE      *******************
  //****************************************************************
  //****************************************************************
  //*****************        UPDATE FEATURE      *******************
  //****************************************************************


  function updateFeature(layer, db_table, key, value, pol_id, id_name, cb) {
    try {
      if (value === 0) {
        value = "0";
      }

      _self.emit("log", "features.js", "updateFeature(" + layer + "," + db_table + "," + key + "," + value + "," + pol_id + "," + id_name + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.db_table = db_table;
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.key = key;
      dataToSend.value = value;
      dataToSend.token = _token;
      dataToSend.what = 'UPDATE_FEATURE';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "features.js", "updateFeature response", "success", response.data.message);

          cb(null, response.data.message);
        } else {
          _self.emit("log", "features.js", "updateFeature error on request", "error", response.data.message);

          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "form.js", "updateFeature", "error", error);
      });
    } catch (e) {
      _self.emit("log", "features.js", "updateFeature error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*****************       END UPDATE FEATURE   *******************
  //****************************************************************
  //****************************************************************
  //****************     UPDATE FEATURE GEOMETRY     ***************
  //****************************************************************


  function updateFeatureGeometry(layer, db_table, epsg, pol_id, id_name, geometry, cb) {
    _self.emit("log", "features.js", "updateFeatureGeometry(" + layer + "," + db_table + "," + epsg + "," + pol_id + "," + id_name + "," + geometry + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.db_table = db_table;
    dataToSend.id_name = id_name;
    dataToSend.pol_id = pol_id;
    dataToSend.epsg = epsg;
    dataToSend.geometry = geometry;
    dataToSend.token = _token;
    dataToSend.what = 'UDPATE_FEATURE_GEOMETRY';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        _self.emit("log", "features.js", "updateFeatureGeometry response", "success", response.data.message);

        cb(null, response.data.message);
      } else {
        _self.emit("log", "features.js", "updateFeatureGeometry error on request", "error", response.data.message);

        cb(response.data.message, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "updateFeatureGeometry", "error", error);

      cb(error, false);
      return false;
    });
  } //****************************************************************
  //**************    END UPDATE FEATURE GEOMETRY   ****************
  //****************************************************************
  //****************************************************************
  //*************        GET INFO FORM FROM ID      ****************
  //****************************************************************


  function getInfoForm(layer, db_table, id_name, pol_id, edit, pointAttributtes, info_type, cb) {
    _self.emit("log", "features.js", "getInfoForm(" + layer + "," + db_table + "," + id_name + "," + pol_id + "," + edit + "," + info_type + ")", "info", pointAttributtes);

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.db_table = db_table;
    dataToSend.device = _device;
    dataToSend.pol_id = pol_id;
    dataToSend.edit = edit;
    dataToSend.id_name = id_name;
    dataToSend.info_type = info_type;
    dataToSend.token = _token;
    dataToSend.what = 'GET_INFO_FORM_FROM_ID';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        _self.emit("log", "features.js", "getInfoForm response", "success", response.data.message);

        var retorno = response.data.message;

        if (retorno.formTabs.length === 0) {
          cb("Error on gw_fct_getformtabs or no available forms for this layer", retorno);
          return false;
        }

        if (edit) {
          if (retorno.editData.status === "Accepted") {
            for (var i = 0; i < retorno.editData.fields.length; i++) {
              if (retorno.editData.fields[i]) {
                if (retorno.editData.fields[i].type === "combo") {
                  retorno.editData.fields[i].comboValues = _assignValuesToCombo(retorno.editData.fields[i]);
                }
              }
            }

            _addInternalKeysToFields(retorno.editData.fields, 'changeAction', 'updateFeature');
          } else {
            cb(JSON.stringify(retorno.editData), retorno);
            return false;
          }
        }

        cb(null, retorno);
      } else {
        cb(response.data.code, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "getInfoForm", "error", error);
    });
  } //****************************************************************
  //************       END GET INFO FORM FROM ID      **************
  //****************************************************************
  //****************************************************************
  //**************   GET INFO FORM FROM COORDINATES    *************
  //****************************************************************


  function getInfoFormFromCoordinates(x, y, active_layer, visible_layers, editable_layers, epsg, zoomlevel, info_type, use_tiled_background, visitable, cb) {
    _self.emit("log", "features.js", "getInfoFormFromCoordinates(" + x + "," + y + "," + active_layer + "," + visible_layers + "," + editable_layers + "," + epsg + "," + zoomlevel + "," + info_type + "," + use_tiled_background + "," + visitable + ")", "info");

    var dataToSend = {};
    dataToSend.x = x;
    dataToSend.y = y;
    dataToSend.active_layer = active_layer;
    dataToSend.visible_layers = visible_layers;
    dataToSend.epsg = epsg;
    dataToSend.device = _device;
    dataToSend.info_type = info_type;
    dataToSend.editable_layers = editable_layers;
    dataToSend.zoomlevel = zoomlevel;
    dataToSend.use_tiled_background = use_tiled_background;
    dataToSend.token = _token;
    dataToSend.what = 'GET_INFO_FORM_FROM_COORDINATES';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        _self.emit("log", "features.js", "getInfoFormFromCoordinates response", "success", response.data.message);

        var retorno = response.data.message;

        if (parseInt(retorno.results) > 0) {
          if (retorno.formTabs.length === 0) {
            cb("No tabs found", retorno);
            return false;
          }

          if (typeof retorno.editData != "undefined") {
            if (retorno.editData.status === "Accepted") {
              for (var i = 0; i < retorno.editData.fields.length; i++) {
                if (retorno.editData.fields[i]) {
                  //find pol_id
                  if (retorno.editData.fields[i].name === retorno.idName) {
                    _self.emit("log", "features.js", "getInfoFormFromCoordinates pol_id found", "success", retorno.editData.fields[i].value);

                    retorno.pol_id = retorno.editData.fields[i].value;
                  }

                  if (retorno.editData.fields[i].type === "combo") {
                    retorno.editData.fields[i].comboValues = _assignValuesToCombo(retorno.editData.fields[i]);
                  }
                }
              }

              _addInternalKeysToFields(retorno.editData.fields, 'changeAction', 'updateFeature');
            } else {
              cb(JSON.stringify(retorno.editData), "Edit data is empty");
              return false;
            }
          }

          cb(null, retorno);
        } else {
          cb(null, {
            message: "no results",
            use_tiled_background: use_tiled_background
          });
        }
      } else {
        cb(response.data.code, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "getInfoFormFromCoordinates", "error", error);
    });
  } //****************************************************************
  //*************   END GET INFO FORM FROM COORDINATES    **********
  //****************************************************************
  //****************************************************************
  //*************          GET INFO FROM POLYGON          **********
  //****************************************************************


  function getInfoFromPolygon(data) {
    _self.emit("log", "features.js", "getInfoFromPolygon()", "info", data);

    return new Promise(function (resolve, reject) {
      var dataToSend = data;
      dataToSend.token = _token;
      dataToSend.what = 'GET_INFO_FORM_FROM_POLYGON';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "features.js", "getInfoFromPolygon response", "success", response.data.message);

          resolve(response.data.message);
        } else {
          reject(response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "form.js", "getInfoFromPolygon", "error", error);

        reject(error);
      });
    });
  } //****************************************************************
  //*************        END GET INFO FROM POLYGON        **********
  //****************************************************************


  module.exports = FeaturesSewernet;
  FeaturesSewernet.prototype.insertFeature = insertFeature;
  FeaturesSewernet.prototype.getInsertFeatureForm = getInsertFeatureForm;
  FeaturesSewernet.prototype.deleteFeature = deleteFeature;
  FeaturesSewernet.prototype.updateFeature = updateFeature;
  FeaturesSewernet.prototype.updateFeatureGeometry = updateFeatureGeometry;
  FeaturesSewernet.prototype.getInfoForm = getInfoForm;
  FeaturesSewernet.prototype.getInfoFormFromCoordinates = getInfoFormFromCoordinates;
  FeaturesSewernet.prototype.getInfoFromPolygon = getInfoFromPolygon;
  FeaturesSewernet.prototype.setToken = setToken;
})();

},{"axios":10,"events":84,"util":109}],4:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var _project_type = "ws"; //<string> ws or ud

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _use_tiled_background;

  var _filters = {};

  var _expected_api_version;

  var _activeTab = null;
  var _tabs = null;
  var _strings = null;
  util.inherits(Filters, _events);

  function Filters(options) {
    if (typeof options.project_type !== "undefined") {
      _project_type = options.project_type.toLowerCase();
    }

    _baseHref = options.baseHref;
    _device = options.device;
    _token = options.token;
    _use_tiled_background = options.use_tiled_background;
    _expected_api_version = options.expected_api_version;
    _strings = options.strings;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "Filters.js", "Filters module loaded", "success");
    }, 500);
    setTimeout(function () {
      getFormFilters(_use_tiled_background, function (err, msg) {
        if (err) {
          _self.emit("log", "Filters.js", "getFormFilters error", "error", msg);

          return false;
        }

        _self.emit("notifyToMap", "Filters ready", getFilters());
      });
    }, 1000);
  }

  function setToken(token) {
    _token = token;
  } //****************************************************************
  //*****************           GET FILTERS          ***************
  //****************************************************************

  /***
  	getFormFilters
  		gets filters and forms
  			@scope public
  		@param cb<function>
  	***/


  function getFormFilters(use_tiled_background, cb) {
    _self.emit("log", "Filters.js", "getFormFilters(" + use_tiled_background + ")", "info");

    var dataToSend = {};
    dataToSend.device = _device;
    dataToSend.use_tiled_background = use_tiled_background;
    dataToSend.token = _token;
    dataToSend.what = 'GET_FILTERS';
    dataToSend.expected_api_version = _expected_api_version;
    var retorno = {};
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      try {
        if (response.data.status === "Accepted") {
          _self.emit("log", "Filters.js", "getFormFilters", "success", response.data.message); //	response.body.message="Filters not implemented"


          if (response.data.message === "Filters not implemented") {
            cb(null, "Filters not implemented");
          } else {
            if (typeof response.data.message.formTabs != "undefined") {
              retorno = response.data.message.formTabs;
              _tabs = response.data.message.formTabs; //set filters

              setFilters(retorno); //sets activce tab

              var activeTabIndex = _getActiveTab(response.data.message.formTabs);

              retorno.activeTab = response.data.message.formTabs[activeTabIndex];
              retorno.activeTab.activeTabIndex = activeTabIndex;
              cb(null, retorno);
            } else {
              cb("no fields", "no fields");
            }
          }
        } else {
          cb(response.data.status, response.data.message);
        }
      } catch (e) {
        _self.emit("log", "Filters.js", "getFormFilters", "error", e.message);

        cb("Error in getFormFilters: " + e.message, null);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "getFormFilters", "error", error);
    });
  } //****************************************************************
  //*************            END GET FILTERS         ***************
  //****************************************************************
  //****************************************************************
  //*************           UPDATE FILTERS           ***************
  //****************************************************************

  /***
  	updateFilters
  		update filters
  			@scope public
  		@param key<string>
  		@param value<string>
  		@param filterName<string>
  		@param cb<function>
  	***/


  function updateFilters(key, value, tabName, cb) {
    try {
      if (value === 0) {
        value = "0";
      }

      var tabIinfo = _getTabData(tabName);

      _self.emit("log", "Filters.js", "updateFilters(" + key + "," + value + "," + tabName + ")", "info", tabIinfo);

      var dataToSend = {};
      dataToSend.key = key;
      dataToSend.value = value;
      dataToSend.tabName = tabIinfo.tabName;
      dataToSend.tabIdName = tabIinfo.tabIdName;
      dataToSend.token = _token;
      dataToSend.what = 'UPDATE_FILTERS';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "Filters.js", "updateFilters response", "success", response.data.message); //updates filters object


          var index = _filters[tabIinfo.tabIdName].indexOf(key);

          if (value && index === -1) {
            _filters[tabIinfo.tabIdName].push(key);
          }

          if ((value === "false" || value === false || value === 0 || value === "0") && index > -1) {
            _filters[tabIinfo.tabIdName].splice(index, 1);
          }

          cb(null, response.data.message);
        } else {
          cb(response.data.status, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "form.js", "updateFilters", "error", error);
      });
    } catch (e) {
      _self.emit("log", "Filters.js", "updateFilters error", "error", e);

      cb(e, false);
    }
  }

  function updateAllFilters(tabs, selectedTab, value, tabName) {
    _self.emit("log", "Filters.js", "updateAllFilters ", "info", {
      tabs: tabs,
      selectedTab: selectedTab,
      value: value,
      tabName: tabName
    });

    return new Promise(function (resolve, reject) {
      var activeTab = null;

      if (_typeof(selectedTab) == "object") {
        selectedTab = selectedTab.tabName;
      }

      var tabIinfo = _getTabData(tabName);

      for (var t = 0; t < tabs.length; t++) {
        tabs[t].active = false;

        if (tabs[t].tabName === selectedTab) {
          activeTab = tabs[t];
          tabs[t].active = true;
          activeTab.activeTabIndex = t;

          for (var i = 0; i < tabs[t].fields.length; i++) {
            if (tabs[t].fields[i].disabled == false) {
              tabs[t].fields[i].value = value;

              if (tabs[t].fields[i].name != "select_all") {
                //updates filters object
                var index = _filters[tabIinfo.tabIdName].indexOf(tabs[t].fields[i].name);

                if (value && index === -1) {
                  _filters[tabIinfo.tabIdName].push(tabs[t].fields[i].name);
                }

                if ((value === "false" || value === false || value === 0 || value === "0") && index > -1) {
                  _filters[tabIinfo.tabIdName].splice(index, 1);
                }
              }
            }
          }
        }

        tabs.activeTab = activeTab;
      }

      var dataToSend = {};
      dataToSend.fields = JSON.stringify(tabs.activeTab.fields);
      dataToSend.tabName = tabIinfo.tabName;
      dataToSend.tabIdName = tabIinfo.tabIdName;
      dataToSend.token = _token;
      dataToSend.what = 'UPDATE_ALL_FILTERS';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "Filters.js", "updateFilters response", "success", response.data.message);

          resolve(tabs);
        } else {
          reject(response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "form.js", "updateFilters", "error", error);
      });
    });
  } //****************************************************************
  //*************           END UPDATE FILTERS       ***************
  //****************************************************************
  //****************************************************************
  //*************           SETTERS/GETTERS          ***************
  //****************************************************************

  /***
  	setFilters
  		set filters
  			@scope private
  		@param filters<array>
  	***/


  function setFilters(filters) {
    _self.emit("log", "Filters.js", "setFilters()", "info", filters);

    for (var i = 0; i < filters.length; i++) {
      _filters[filters[i].tabIdName] = Array(); //adds updateAction property to each field

      _addInternalKeysToFields(filters[i].fields, 'changeAction', 'updateFilters');

      filters[i].fields.unshift({
        'label': _strings.ALL,
        'name': 'select_all',
        'dataType': "boolean",
        'disabled': false,
        'type': 'check',
        'value': false
      }); //sets activeTab for form

      if (filters[i].active) {
        _activeTab = filters[i].tabIdName;
      }

      for (var f = 0; f < filters[i].fields.length; f++) {
        if (filters[i].fields[f].value) {
          if (_filters[filters[i].tabIdName].indexOf(filters[i].fields[f].name) === -1) {
            _filters[filters[i].tabIdName].push(filters[i].fields[f].name);
          }
        }
      }
    }
  }
  /***
  	getFilters
  		returns current filters
  			@scope public
  		@return <object>
  	***/


  function getFilters() {
    return _filters;
  }
  /***
  	_addInternalKeysToFields
  		adds properties to json
  			@scope private
  		@return <object>
  	***/


  function _addInternalKeysToFields(fields, key, value) {
    for (var i = 0; i < fields.length; i++) {
      if (fields[i]) {
        fields[i][key] = value;
      }
    }
  }
  /***
  	_getTabData
  		gets tabData needed on update
  			@scope private
  		@param tabName <string>
  		@return <object>
  	***/


  function _getTabData(tabName) {
    _self.emit("log", "Filters.js", "_getTabData(" + tabName + ")", "info", _tabs);

    var retorno = {};

    for (var i = 0; i < _tabs.length; i++) {
      if (_tabs[i].tabName === tabName) {
        retorno.tabName = _tabs[i].tabName;
        retorno.tabIdName = _tabs[i].tabIdName;
        break;
      }
    }

    return retorno;
  }

  function _getActiveTab(tabs) {
    if (tabs.length > 0) {
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].active) {
          return i;
          break;
        }
      }
    }
  }

  function setLocalizedStrings(strings) {
    _strings = strings;
  } //****************************************************************
  //*************          END SETTERS/GETTERS       ***************
  //****************************************************************


  module.exports = Filters;
  Filters.prototype.updateFilters = updateFilters;
  Filters.prototype.updateAllFilters = updateAllFilters;
  Filters.prototype.getFilters = getFilters;
  Filters.prototype.getFormFilters = getFormFilters;
  Filters.prototype.setToken = setToken;
  Filters.prototype.setLocalizedStrings = setLocalizedStrings;
})();

},{"axios":10,"events":84,"util":109}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _richLogger = _interopRequireDefault(require("../src/richLogger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _self = null,
    _version = '1.0.0',
    _events = null,
    _logger = null;

var FormUtils =
/*#__PURE__*/
function () {
  function FormUtils(options, events, logger) {
    _classCallCheck(this, FormUtils);

    if (typeof options === 'undefined') {
      throw new TypeError('no data');
    }

    if (typeof options.baseHref === 'undefined') {
      throw new TypeError('no options baseHref');
    }

    if (typeof events === 'undefined') {
      throw new TypeError('no events');
    }

    _events = events;

    if (typeof logger === 'undefined') {
      throw new TypeError('no logger');
    }

    _logger = logger;
    _self = this;
    _self._fileName = 'form_utils.js';
    _self.options = options;

    _logger.info(_self._fileName, "Module loaded v.".concat(_version), options);
  }
  /*
    formatPhotoData
      used in visits v.2, creates json for api insertion
     @param fileName
    @param photo_id
    @param visit_id
    @param deviceTrace
     @return JSON
   */


  _createClass(FormUtils, [{
    key: "formatPhotoData",
    value: function formatPhotoData(fileName, photo_id, visit_id, deviceTrace, metaData) {
      _logger.info(_self._fileName, 'formatPhotoData()', {
        'fileName': fileName,
        'photo_id': photo_id,
        'visit_id': visit_id,
        'deviceTrace': deviceTrace,
        'metaData': metaData
      });

      var processedName = fileName.split('\\').pop();
      var idval = processedName.replace(/^.*[\\\/]/, '');
      idval = idval.split('.');
      var fextension = processedName.substr(processedName.lastIndexOf('.') + 1);
      var link = "".concat(_self.options.baseHref, "external.image.php?img=").concat(photo_id);
      return {
        'photo_url': "".concat(_self.options.baseHref, "external.image.php?img="),
        'hash': photo_id,
        'visit_id': visit_id,
        'fextension': fextension,
        'metaData': metaData
      };
    }
  }]);

  return FormUtils;
}();

exports["default"] = FormUtils;

},{"../src/richLogger":79}],6:[function(require,module,exports){
"use strict";

var _go2epa2 = _interopRequireDefault(require("./go2epa"));

var _package = require("./package.json");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function () {
  'use strict';

  var util = require('util');

  var axios = require('axios');

  var MobileDetect = require('mobile-detect');

  var FormsContentsSewernet = require('./formsContents');

  var Visits = require('./visits');

  var EventsSewernet = require('./events');

  var FeaturesSewernet = require('./features');

  var Filters = require('./filters');

  var Search = require('./search');

  var Print = require('./print');

  var Mincut = require('./mincut');

  var DatesSelector = require('./dateselector');

  var _events = require('events').EventEmitter;

  var _baseHref;

  var _self;

  var _token = null;
  var _device = 3; //<int> 1 mobile, 2 tablet, 3 desktop

  var _project_type = "ws"; //<string> ws or ud

  var _info_type = 0; //<int> info type, 0 full info - 100 limited info

  var _expected_api_version = "1.1.0"; //expected api version

  var _formsContents;

  var _visits;

  var _features;

  var _eventsModule;

  var _datesSelector;

  var _filters;

  var _search;

  var _print;

  var _mincut;

  var _go2epa;

  var _excludingMincut = false; //flag for detecting mincut exclusion

  var _mincutValveLayerTableName = null; //table name layer for mincut valves

  var _mincutGeometryForZoom = null; //store feature geometry for highlight and zoom after upsert mincut

  var _id_name_mincut = null; //store id_name for mincut (hidePreviousForms empties global vars)

  var _pol_id_mincut = null; //store pol_id for mincut (hidePreviousForms empties global vars)

  var _historyObj = []; //<object> store form navigation

  var constants = new Map();
  var _options = null; //options object

  util.inherits(FormsSewernet, _events);

  function FormsSewernet(options) {
    _baseHref = options.baseHref;

    if (typeof options.project_type !== "undefined") {
      _project_type = options.project_type.toLowerCase();
    }

    if (typeof options.info_type !== "undefined") {
      _info_type = parseInt(options.info_type);
    }

    _expected_api_version = options.expected_api_version;
    _self = this;
    var md = new MobileDetect(window.navigator.userAgent);

    if (md.mobile() && !md.tablet()) {
      _device = 1; //mobile
    } else if (md.tablet() && md.mobile()) {
      _device = 2; //tablet
    }

    _options = options;
    _options.device = _device;
    _formsContents = new FormsContentsSewernet({
      project_type: _project_type,
      expected_api_version: _expected_api_version
    });
    setTimeout(function () {
      _self.emit("log", "form.js", "FormsSewernet loaded", "success");
    }, 500);
  } //set session token


  function setToken(token) {
    _token = token;
    _options.token = _token;
    _visits = new Visits(_options);

    _visits.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _visits.on('offlineEvent', function (evt, data) {
      console.log('offlineEvent on forms');

      _self.emit("offlineEvent", evt, data);
    });

    _eventsModule = new EventsSewernet({
      project_type: _project_type,
      token: _token,
      baseHref: _baseHref,
      device: _device,
      expected_api_version: _expected_api_version
    });

    _eventsModule.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _features = new FeaturesSewernet({
      project_type: _project_type,
      token: _token,
      baseHref: _baseHref,
      device: _device,
      expected_api_version: _expected_api_version
    });

    _features.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _search = new Search({
      project_type: _project_type,
      token: _token,
      baseHref: _baseHref,
      device: _device,
      expected_api_version: _expected_api_version
    });

    _search.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _search.on('notifyToMap', function (data, extraData) {
      _self.emit("notifyToMap", data, extraData);
    });

    _print = new Print({
      project_type: _project_type,
      token: _token,
      baseHref: _baseHref,
      device: _device,
      expected_api_version: _expected_api_version
    });

    _print.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _print.on('notifyToMap', function (data, extraData) {
      _self.emit("notifyToMap", data, extraData);
    });

    _mincut = new Mincut({
      project_type: _project_type,
      token: _token,
      baseHref: _baseHref,
      device: _device,
      expected_api_version: _expected_api_version
    });

    _mincut.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _mincut.on('notifyToMap', function (data, extraData) {
      _self.emit("notifyToMap", data, extraData);
    });

    _datesSelector = new DatesSelector({
      project_type: _project_type,
      token: _token,
      baseHref: _baseHref,
      device: _device,
      expected_api_version: _expected_api_version,
      use_tiled_background: _options.use_tiled_background
    });

    _datesSelector.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _datesSelector.on('notifyToMap', function (data, extraData) {
      _self.emit("notifyToMap", data, extraData);
    });

    _go2epa = new _go2epa2["default"]({
      'env': _options.env,
      'baseHref': _baseHref,
      'device': _device,
      token: _token
    });
  }

  function setLocalizedStrings(stringsObject) {
    /*stringsObject.forEach( function (eachObj){
    	for (var key in eachObj) {
    		if (eachObj.hasOwnProperty(key)){
    			constants.set(key,eachObj[key]);
    		}
    	}
    });*/
    _options.strings = stringsObject;

    if (_filters) {
      _filters.setLocalizedStrings(_options.strings);
    }

    return true;
  } //****************************************************************
  //********************    GET WEB FORMS      *********************
  //****************************************************************
  //******************        GENERIC FORM     *********************


  function getWebForms(formIdentifier, layer, pol_id, id_name, tabName, cb) {
    _self.emit("log", "form.js", "getWebForms(" + formIdentifier + "," + layer + "," + pol_id + "," + id_name + "," + tabName + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.device = _device;
    dataToSend.form = formIdentifier;
    dataToSend.pol_id = pol_id;
    dataToSend.id_name = id_name;
    dataToSend.tabName = tabName;
    dataToSend.token = _token;
    dataToSend.expected_api_version = _expected_api_version;
    dataToSend.what = 'ELEMENTS';
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      _self.emit("log", "forms.js", "getWebForms", "success", response.data.message);

      if (response.data.status === "Accepted") {
        cb(null, response.data.message);
      } else {
        cb(response.data.code, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "getWebForms", "error", error);
    });
  }

  function getWebFormsForConnect(layer, pol_id, id_name, cb) {
    _self.emit("log", "form.js", "getWebFormsForConnect(" + layer + "," + pol_id + "," + id_name + ")", "info");

    var upstream;
    var downstream; //if(_project_type==="ud"){

    if (id_name != "arc_id") {
      //load upstream
      _self.emit("log", "form.js", "getWebFormsForConnect - request upstream/downstream", "info");

      getWebForms('v_ui_node_x_connection_upstream', layer, pol_id, id_name, null, function (err, response) {
        if (err && err != 404) {
          _self.emit("log", "form.js", "getWebFormsForConnect error on request upstream", "error", err);

          cb(err, null);
        } else {
          if (err === 404) {
            _self.emit("log", "form.js", "getWebFormsForConnect no data for upstream/downstream", "warn", err);

            cb(null, {
              upstream: null,
              downtream: null
            });
          }

          cb(null, response);
        }
      });
    } else {
      getWebForms('v_ui_arc_x_connection', layer, pol_id, id_name, null, function (err, response) {
        if (err && err != 404) {
          _self.emit("log", "form.js", "getWebFormsForConnect error on request v_ui_arc_x_connection", "error", err);

          cb(err, null);
        } else {
          if (err === 404) {
            _self.emit("log", "form.js", "getWebFormsForConnect no data for v_ui_arc_x_connection", "warn", err);
          } else {
            var related = response;
            var dataToSend = {};
            dataToSend.layer = layer;
            dataToSend.pol_id = pol_id;
            dataToSend.device = _device;
            dataToSend.id_name = id_name;
            dataToSend.token = _token;
            dataToSend.what = 'GET_NODES_FOR_ARC_CONNECT';
            dataToSend.expected_api_version = _expected_api_version;
            axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
              _self.emit("log", "form.js", "getWebFormsForConnect", "success", response.data.message);

              if (response.data.status === "Accepted") {
                cb(null, {
                  table: response.data.message.table,
                  node1: response.data.message.node1[0],
                  node2: response.data.message.node2[0]
                });
              } else {
                cb(true, {
                  related: response.data
                });
              }
            })["catch"](function (error) {
              _self.emit("log", "form.js", "getWebFormsForConnect error on request", "error", error);
            });
          }
        }
      });
    }
    /*	}else{
    		return false;
    	}*/

  } //******************     END GENERIC FORM    *********************
  //****************************************************************
  //*******************     INFO FORM TAB FILES     ****************
  //****************************************************************


  function getInfoFiles(pol_id, id_name, selected_layer, tableName) {
    _self.emit("log", "form.js", "getInfoFiles()", "info", {
      'pol_id': pol_id,
      'id_name': id_name,
      'selected_layer': selected_layer,
      'tableName': tableName
    });

    return new Promise(function (resolve, reject) {
      var dataToSend = {}; //dataToSend.layer			= layer

      dataToSend.device = _device;
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.selected_layer = selected_layer;
      dataToSend.tableName = tableName;
      dataToSend.token = _token;
      dataToSend.what = 'GET_INFO_FILES';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "getInfoFiles", "success", response.data.message);

        resolve(response.data.message.body);
      })["catch"](function (e) {
        _self.emit("log", "visits.js", "getInfoFiles", "error", response.data);

        reject(e);
      });
    });
  }

  function setFeatureFile(pol_id, idName, info_type, tableName, photos, deviceTrace) {
    _self.emit("log", "form.js", "setFeatureFile()", "info", {
      'pol_id': pol_id,
      'idName': idName,
      'info_type': info_type,
      'tableName': tableName,
      'photos': photos,
      'deviceTrace': deviceTrace
    });

    return new Promise(function (resolve, reject) {
      var dataToSend = {};
      dataToSend.device = _device;
      dataToSend.id = pol_id;
      dataToSend.idName = idName;
      dataToSend.tableName = tableName;
      dataToSend.token = _token;
      dataToSend.info_type = info_type;
      dataToSend.deviceTrace = JSON.stringify(deviceTrace);
      dataToSend.photos = JSON.stringify(photos);
      dataToSend.what = 'SET_FEAUTURE_FILE';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "setFeatureFile", "success", response.data.message);

        resolve(response.data.message.body);
      })["catch"](function (e) {
        _self.emit("log", "visits.js", "setFeatureFile", "error", response.data);

        reject(e);
      });
    });
  }

  function deleteFeatureFile(pol_id, file_id, info_type) {
    _self.emit("log", "form.js", "deleteFeatureFile()", "info", {
      'pol_id': pol_id,
      'file_id': file_id,
      'info_type': info_type
    });

    return new Promise(function (resolve, reject) {
      var dataToSend = {};
      dataToSend.device = _device;
      dataToSend.id = pol_id;
      dataToSend.file_id = file_id;
      dataToSend.token = _token;
      dataToSend.info_type = info_type;
      dataToSend.what = 'DELETE_FEAUTURE_FILE';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "deleteFeatureFile", "success", response.data.message);

        resolve(response.data.message.body);
      })["catch"](function (e) {
        _self.emit("log", "visits.js", "deleteFeatureFile", "error", response.data);

        reject(e);
      });
    });
  } //****************************************************************
  //*******************    END INFO FORM TAB FILES  ****************
  //****************************************************************
  //****************************************************************
  //*******************      END GET WEB FORMS      ****************
  //****************************************************************
  //****************************************************************
  //*******************             VISITS          ****************
  //****************************************************************


  function deleteVisit(visit_id, layer, cb) {
    if (visit_id === constants.get('SELECT')) {
      cb("no visit_id", false);
    } else {
      _visits.deleteVisit(visit_id, layer, cb);
    }
  }

  function getWebFormsForVisit(formIdentifier, pol_id, id_name, options, cb) {
    _self.emit("log", "form.js", "getWebFormsForVisit(" + formIdentifier + "," + pol_id + ")", "info", options);

    _visits.getWebFormsForVisit(formIdentifier, pol_id, id_name, options, constants, cb);
  }

  function upsertVisit(layer, coordinates, epsg, pol_id, id_name, cb) {
    _self.emit("log", "form.js", "insertVisit(" + layer + "," + coordinates + "," + epsg + "," + pol_id + "," + id_name + ")", "info");

    _visits.upsertVisit(layer, coordinates, epsg, pol_id, id_name, cb);
  }

  function updateVisit(layer, visit_id, key, value, pol_id, id_name, cb) {
    _visits.updateVisit(layer, visit_id, key, value, pol_id, id_name, cb);
  }

  function getVisitsFromFeature(layer, pol_id, id_name, options, cb) {
    _self.emit("log", "form.js", "getVisitsFromFeature(" + layer + "," + pol_id + ")", "info", options);

    _visits.getVisitsFromFeature(layer, pol_id, id_name, options, cb);
  }

  function getParameterIdFromParameterType(layer, paramaterType, id_name, cb) {
    _visits.getParameterIdFromParameterType(layer, paramaterType, id_name, cb);
  } //visits new implementation


  function gwGetVisit(data, cb) {
    data.device = _device;

    _visits.gwGetVisit(data, cb);
  }

  function gwSetVisit(data, cb) {
    data.device = _device;

    _visits.gwSetVisit(data, cb);
  }

  function gwSetDelete(pol_id, id_name, info_type, featureType, tableName, idname, id, formData, cb) {
    _visits.gwSetDelete(pol_id, id_name, info_type, featureType, tableName, idname, id, formData, _device, cb);
  }

  function gwGetVisitManager(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, cb) {
    _visits.gwGetVisitManager(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, _device, cb);
  }

  function gw_api_setvisitmanagerend(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, cb) {
    _visits.gw_api_setvisitmanagerend(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, _device, cb);
  }

  function gw_api_setvisitmanagerstart(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, cb) {
    _visits.gw_api_setvisitmanagerstart(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, _device, cb);
  }

  function gwSetVisitManager(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, cb) {
    _visits.gwSetVisitManager(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, _device, cb);
  }

  function gwGetLot(pol_id, id_name, info_type, featureType, tableName, idname, id, formData, cb) {
    _visits.gwGetLot(pol_id, id_name, info_type, featureType, tableName, idname, id, formData, _device, cb);
  }

  function gwSetLot(pol_id, id_name, info_type, featureType, tableName, idname, id, formData, deviceTrace, cb) {
    _visits.gwSetLot(pol_id, id_name, info_type, featureType, tableName, idname, id, formData, deviceTrace, _device, cb);
  }

  function gwSetVehicleLoad(info_type, formData, deviceTrace) {
    return _visits.gwSetVehicleLoad(info_type, formData, deviceTrace, _device);
  }

  function setUpOfflineVisit(props) {
    return _visits.setUpOfflineVisit(props);
  }

  function clearOfflineVisits(data) {
    return _visits.clearOfflineVisits(data);
  }

  function clearVisitedSpots() {
    return _visits.clearVisitedSpots();
  }

  function dumpOfflineVisits(data) {
    return _visits.dumpOfflineVisits(data);
  }

  function saveVisitPicture(data, preview, fileName, metaData) {
    data.device = _device;
    return _visits.saveVisitPicture(data, preview, fileName, metaData);
  }

  function renderVisitedSpotsLayer(options) {
    return _visits.renderVisitedSpotsLayer(options);
  }

  function toggleVisitedSpots(options) {
    return _visits.toggleVisitedSpots(options);
  }

  function storeVisitForms() {
    _visits.storeVisitForms();
  }

  function storeDownloadDate() {
    return _visits.storeDownloadDate();
  } //****************************************************************
  //*******************         END VISITS         *****************
  //****************************************************************
  //****************************************************************
  //*******************            EVENTS          *****************
  //****************************************************************


  function getEventFormTypeAndEvent(visit_parameter_id, pol_id, id_name, layer, cb) {
    _eventsModule.getEventFormTypeAndEvent(visit_parameter_id, pol_id, id_name, layer, cb);
  }

  function insertEvent(layer, visit_id, pol_id, id_name, eventData, formId, photos, compasses, cb) {
    _eventsModule.insertEvent(layer, visit_id, pol_id, id_name, eventData, formId, photos, compasses, cb);
  }

  function deleteEvent(layer, event_id, cb) {
    _eventsModule.deleteEvent(layer, event_id, cb);
  }

  function getEvent(layer, event_id, pol_id, id_name, cb) {
    _eventsModule.getEvent(layer, event_id, pol_id, id_name, cb);
  }

  function updateEvent(layer, event_id, key, value, pol_id, id_name, cb) {
    _eventsModule.updateEvent(layer, event_id, key, value, pol_id, id_name, cb);
  } //****************************************************************
  //*******************         END EVENTS         *****************
  //****************************************************************
  //****************************************************************
  //*******************           GALLERY          *****************
  //****************************************************************


  function getGallery(layer, type, id, cb) {
    _self.emit("log", "form.js", "getGallery(" + layer + "," + type + "," + id + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.type = type;
    dataToSend.id = id;
    dataToSend.token = _token;
    dataToSend.what = 'GET_GALLERY';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      _self.emit("log", "forms.js", "getGallery", "success", response.data.message);

      if (response.data.status === "Accepted") {
        cb(null, response.data.message);
      } else {
        cb(response.data.code, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "getGallery", "error", error);
    });
  }

  function deletePhoto(layer, hash, cb) {
    _self.emit("log", "form.js", "deletePhoto(" + layer + "," + hash + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.hash = hash;
    dataToSend.token = _token;
    dataToSend.what = 'DELETE_EVENT_PHOTO';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      _self.emit("log", "forms.js", "deletePhoto", "success", response.data.message);

      if (response.data.status === "Accepted") {
        cb(null, response.data.message);
      } else {
        cb(response.data.code, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "deletePhoto", "error", error);
    });
  } //****************************************************************
  //*******************        END GALLERY         *****************
  //****************************************************************
  //****************************************************************
  //*******************         FEATURES           *****************
  //****************************************************************


  function getInsertFeatureForm(layer, db_table, cb) {
    _features.getInsertFeatureForm(layer, db_table, cb);
  }

  function insertFeature(layer, db_table, epsg, formData, geometry, cb) {
    _features.insertFeature(layer, db_table, epsg, formData, geometry, cb);
  }

  function deleteFeature(layer, db_table, id_name, id, cb) {
    _features.deleteFeature(layer, db_table, id_name, id, cb);
  }

  function updateFeature(layer, db_table, key, value, pol_id, id_name, cb) {
    _features.updateFeature(layer, db_table, key, value, pol_id, id_name, cb);
  }

  function updateFeatureGeometry(layer, db_table, epsg, pol_id, id_name, geometry, cb) {
    _features.updateFeatureGeometry(layer, db_table, epsg, pol_id, id_name, geometry, cb);
  }

  function getInfoForm(layer, db_table, id_name, pol_id, edit, pointAttributtes, cb) {
    _features.getInfoForm(layer, db_table, id_name, pol_id, edit, pointAttributtes, _info_type, cb);
  }

  function getInfoFormFromCoordinates(x, y, active_layer, visible_layers, editable_layers, epsg, zoomlevel, use_tiled_background, visitable, cb) {
    _features.getInfoFormFromCoordinates(x, y, active_layer, visible_layers, editable_layers, epsg, zoomlevel, _info_type, use_tiled_background, visitable, cb);
  }

  function getInfoFromPolygon(data) {
    data.device = _device;
    return _features.getInfoFromPolygon(data);
  } //****************************************************************
  //*******************       END FEATURES      ********************
  //****************************************************************
  //****************************************************************
  //******************    GET FEATURE TYPE      ********************
  //****************************************************************
  //not used!!! Is for connect tab, solved by faking an info on the map


  function getFeatureType(featurecat_id, layer, cb) {
    _self.emit("log", "form.js", "getFeatureType(" + featurecat_id + "," + layer + ")", "info");

    var dataToSend = {};
    dataToSend.layer = layer;
    dataToSend.featurecat_id = featurecat_id;
    dataToSend.token = _token;
    dataToSend.what = 'GET_FEATURE_TYPE';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      _self.emit("log", "forms.js", "getFeatureType", "success", response.data.message);

      if (response.data.status === "Accepted") {
        cb(null, response.data.message);
      } else {
        cb(response.data.code, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "form.js", "getFeatureType", "error", error);
    });
  } //****************************************************************
  //******************    END GET FEATURE TYPE  ********************
  //****************************************************************
  //****************************************************************
  //********************    FORM AND TABS      *********************
  //****************************************************************

  /***
  	getTableFromLayer_id_name
  		obtains wich db table should be used in a request based on layer_id_name or specific form identifier
  			@param formId <string>
  		@param layer_id_name <string>
  			@return <string>
  ***/


  function getTableFromLayer_id_name(formId, layer_id_name) {
    return _formsContents.getTableFromLayer_id_name(formId, layer_id_name);
  }
  /***
  	getTableFromLayer_id_name
  		obtains wich db table should be used in a request based on layer_id_name or specific form identifier
  			@param formId <string>
  		@param layer_id_name <string>
  			@return <string>
  	***/


  function getFormByFormId(formId) {
    return _formsContents.getFormByFormId(formId);
  } //****************************************************************
  //*******************    END FORM AND TABS   *********************
  //****************************************************************
  //****************************************************************
  //*************                FILTERS             ***************
  //****************************************************************


  function initFilters(use_tiled_background) {
    _filters = new Filters({
      project_type: _project_type,
      token: _token,
      baseHref: _baseHref,
      device: _device,
      use_tiled_background: use_tiled_background,
      expected_api_version: _expected_api_version,
      strings: _options.strings
    });

    _filters.on('log', function (mod, data, level, extraData) {
      _self.emit("log", mod, data, level, extraData);
    });

    _filters.on('notifyToMap', function (data, extraData) {
      _self.emit("notifyToMap", data, extraData);
    });
  }

  function getFilters() {
    return _filters.getFilters();
  }

  function getFormFilters(use_tiled_background, cb) {
    _filters.getFormFilters(use_tiled_background, cb);
  }

  function updateFilters(field, value, filterName, cb) {
    _filters.updateFilters(field, value, filterName, cb);
  }

  function updateAllFilters(tabs, selectedTab, value, tabName) {
    return _filters.updateAllFilters(tabs, selectedTab, value, tabName);
  } //****************************************************************
  //*************              END FILTERS           ***************
  //****************************************************************
  //****************************************************************
  //*************                  SEARCH            ***************
  //****************************************************************


  function getSearchForm(cb) {
    _search.getSearchForm(cb);
  }

  function getDataForAddress(extent, val, searchService) {
    return _search.getDataForAddress(extent, val, searchService);
  }

  function updateSearch(fields, tabName, fieldName, val) {
    return _search.updateSearch(fields, tabName, fieldName, val);
  }

  function updateSearchAdd(fields, tabName, fieldName, val) {
    return _search.updateSearchAdd(fields, tabName, fieldName, val);
  } //****************************************************************
  //*************               END SEARCH           ***************
  //****************************************************************
  //****************************************************************
  //*************                  PRINT             ***************
  //****************************************************************


  function getPrintForm(composer, cb) {
    _print.getPrintForm(composer, cb);
  }

  function printComposer(composder, extent, map, tiledLayers, cb) {
    _print.printComposer(composder, extent, map, tiledLayers, cb);
  }

  function updatePrint(formData, extent, use_tiled_background, cb) {
    _print.updatePrint(formData, extent, use_tiled_background, cb);
  }

  function captureScreen(map, cb) {
    _print.captureScreen(map, cb);
  } //****************************************************************
  //*************                END PRINT           ***************
  //****************************************************************
  //****************************************************************
  //*************                 MINCUT             ***************
  //****************************************************************


  function getMincut(x, y, epsg, mincut_id_arg, id_name, cb) {
    _mincut.getMincut(x, y, epsg, mincut_id_arg, id_name, cb);
  }

  function getInfoMincut(id_name, pol_id, fromDate, toDate, cb) {
    _mincut.getInfoMincut(id_name, pol_id, fromDate, toDate, cb);
  }

  function upsertMincut(mincut_id, x, y, srid, id_name, pol_id, formData, cb) {
    _mincut.upsertMincut(mincut_id, x, y, srid, _device, id_name, pol_id, formData, cb);
  }

  function getMincutManager(cb) {
    _mincut.getMincutManager(_device, cb);
  }

  function updateMincutManager(formData, tabName, cb) {
    _mincut.updateMincutManager(formData, tabName, _device, cb);
  }

  function excludeFromMincut(valve_id, mincut_id, cb) {
    _mincut.excludeFromMincut(valve_id, mincut_id, _device, cb);
  }

  function endMincut(mincut_id, id_name, pol_id, formData, cb) {
    _mincut.endMincut(mincut_id, _device, id_name, pol_id, formData, cb);
  }

  function startMincut(mincut_id, cb) {
    _mincut.startMincut(mincut_id, _device, cb);
  }

  function processGetMincut(body, cb) {
    _mincut.processGetMincut(body, cb);
  }

  function updateMincutAdd(fields, tabName, fieldName, val) {
    return _mincut.updateMincutAdd(fields, tabName, fieldName, val);
  }

  function setMincutValveLayerTableName(value) {
    _mincutValveLayerTableName = value;
  }

  function getMincutValveLayerTableName() {
    return _mincutValveLayerTableName;
  }

  function setMincutGeometryForZoom(value) {
    _mincutGeometryForZoom = value;
  }

  function getMincutGeometryForZoom() {
    return _mincutGeometryForZoom;
  }

  function setId_name_mincut(value) {
    _id_name_mincut = value;
  }

  function getId_name_mincut() {
    return _id_name_mincut;
  }

  function setPol_id_mincut(value) {
    _pol_id_mincut = value;
  }

  function getPol_id_mincut() {
    return _pol_id_mincut;
  } //****************************************************************
  //*************                END MINCUT          ***************
  //****************************************************************
  //****************************************************************
  //*************            DATES SELECTOR          ***************
  //****************************************************************


  function getDatesForm(use_tiled_background, cb) {
    _datesSelector.getDatesForm(use_tiled_background, cb);
  }

  function setFilterDate(formData, cb) {
    _datesSelector.setFilterDate(formData, cb);
  } //****************************************************************
  //*************          END DATES SELECTOR        ***************
  //****************************************************************
  //****************************************************************
  //*************        SET FORM COORDINATES        ***************
  //****************************************************************

  /*
  	setFormCoordinates
  
  */


  function setFormCoordinates(pos_x, pos_y, srid, zoom, form_id, uniqueId, cb) {
    try {
      _self.emit("log", "forms.js", "setFormCoordinates(" + pos_x + "," + pos_y + "," + zoom + "," + form_id + "," + uniqueId + ")", "info");

      var dataToSend = {};
      dataToSend.pos_x = pos_x;
      dataToSend.pos_y = pos_y;
      dataToSend.form_id = form_id;
      dataToSend.zoom = zoom;
      dataToSend.device = _device;
      dataToSend.srid = srid;
      dataToSend.uniqueId = uniqueId;
      dataToSend.token = _token;
      dataToSend.what = 'SET_FORM_COORDINATES';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "forms.js", "setFormCoordinates", "success", response.data.message);

        if (response.data.status === "Accepted") {
          cb(null, response.data.message);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "form.js", "setFormCoordinates", "error", error);
      });
    } catch (e) {
      _self.emit("log", "form.js", "setFormCoordinates error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************       END SET FORM COORDINATES        *************
  //****************************************************************

  /*
  	getValueFromEditableField
  		finds a value on editData from an info (used e.g on excludeMincut)
  */


  function getValueFromEditableField(data, fieldToFind) {
    if (typeof data.editData != "undefined") {
      if (typeof data.editData.fields != "undefined") {
        for (var i = 0; i < data.editData.fields.length; i++) {
          if (data.editData.fields[i].name === fieldToFind) {
            return data.editData.fields[i].value;
            break;
          }
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  } //****************************************************************
  //****************   DISPLAY OR NOT INPUTS   *********************
  //****************************************************************

  /***
  	showInput
  		checks if a a DOM element should be displayed or not for a given form
  			@param formId <string> form identifier
  		@param inputName <string> DOM element
  			@return <BOOLEAN>
  	***/


  function showInput(formId, inputName) {
    if (formId === "F11") {
      switch (inputName) {
        case "btAddVisit":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F12") {
      switch (inputName) {
        case "btAddVisit":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F13") {
      switch (inputName) {
        case "btAddVisit":
        case "btsConnectNode":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F21") {
      switch (inputName) {
        case "btVisitManager":
        case "select_visitcat_id":
        case "code":
        case "btAdd":
        case "tableViewEvents":
        case "checkVisitDone":
        case "checkVisitSuspended":
        case "parameter_type":
        case "parameter_id":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F22") {
      switch (inputName) {
        case "Value":
        case "btAddPhoto":
        case "btViewGallery":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F23") {
      switch (inputName) {
        case "Value":
        case "position_id":
        case "position_value":
        case "btAddPhoto":
        case "btViewGallery":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F24") {
      switch (inputName) {
        case "Value":
        case "position_id":
        case "position_value":
        case "value1":
        case "value2":
        case "geom1":
        case "geom2":
        case "geom3":
        case "btAddPhoto":
        case "btViewGallery":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F27") {
      switch (inputName) {
        case "btDeletePicture":
        case "btSeePicture":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F51") {
      switch (inputName) {
        case "review.arc_id":
        case "review.y1":
        case "review.y2":
        case "review.arc_type":
        case "review.matcat_id":
        case "review.shape":
        case "review.geom1":
        case "review.geom2":
        case "review.annotation":
        case "review.observ":
        case "review.done":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F52") {
      switch (inputName) {
        case "review.node_id":
        case "review.top_elev":
        case "review.node_type":
        case "review.matcat_id":
        case "review.shape":
        case "review.geom1":
        case "review.geom2":
        case "review.annotation":
        case "review.observ":
        case "review.done":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F53") {
      switch (inputName) {
        case "review.connec_id":
        case "review.y1":
        case "review.y2":
        case "review.connec_type":
        case "review.matcat_id":
        case "review.shape":
        case "review.geom1":
        case "review.geom2":
        case "review.annotation":
        case "review.observ":
        case "review.done":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F54") {
      switch (inputName) {
        case "review.gully_id":
        case "review.top_elev":
        case "review.ymax":
        case "review.sandbox":
        case "review.matcat_id":
        case "review.gratecat_id":
        case "review.units":
        case "review.groove":
        case "review.siphon":
        case "review.connec_matcat":
        case "review.shape":
        case "review.geom1":
        case "review.geom2":
        case "review.featurecat_id":
        case "review.feature_id":
        case "review.annotation":
        case "review.observ":
        case "review.done":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F55") {
      switch (inputName) {
        case "review.arc_id":
        case "review.matcat_id":
        case "review.pnom":
        case "review.dnom":
        case "review.annotation":
        case "review.observ":
        case "review.done":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F56") {
      switch (inputName) {
        case "review.node_id":
        case "review.elevation":
        case "review.depth":
        case "review.from_plot":
        case "review.node_type":
        case "review.nodecat_id":
        case "review.annotation":
        case "review.observ":
        case "review.done":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else if (formId === "F57") {
      switch (inputName) {
        case "review.connec_id":
        case "review.matcat_id":
        case "review.pnom":
        case "review.dnom":
        case "review.annotation":
        case "review.observ":
        case "review.done":
          return true;
          break;

        default:
          return false;
          break;
      }
    } else {
      return false;
    }
  } //****************************************************************
  //*************     END DISPLAY OR NOT INPUTS   ******************
  //****************************************************************


  function cleanInputs(value, type) {
    var retorn;

    if (value == "undefined" || typeof value === "undefined" || typeof type === "undefined") {
      return "";
    }

    if (type === "int") {
      retorn = parseInt(value);

      if (isNaN(retorn)) {
        retorn = "";
      }
    } else if (type === "double") {
      if (!isNaN(parseFloat(value))) {
        if (!isFinite(value)) {
          retorn = "";
        } else {
          retorn = parseFloat(parseFloat(value).toFixed(2));
        }
      } else {
        retorn = "";
      }
    } else if (type === "string") {
      retorn = value;
    } else {
      retorn = "";
    }

    return retorn;
  }

  function validateInput(value, type) {
    var retorn;

    if (value == "undefined" || typeof value === "undefined" || typeof type === "undefined") {
      retorn = false;
    } else {
      if (type === "int") {
        retorn = parseInt(value);

        if (isNaN(retorn)) {
          retorn = false;
        } else {
          retorn = true;
        }
      } else if (type === "double") {
        if (!isNaN(parseFloat(value))) {
          if (!isFinite(value)) {
            retorn = false;
          } else {
            retorn = true;
          }
        } else {
          retorn = false;
        }
      } else {
        retorn = true;
      }
    }

    return retorn;
  } //****************************************************************
  //*************             FORM HISTORY        ******************
  //****************************************************************

  /***
  	getFormHistory
  		gets form history for navigation in forms
  			@return <JSON> or NULL
  	***/


  function getFormHistory() {
    _self.emit("log", "form.js", "getFormHistory()", "info", _historyObj);

    if (_historyObj.length > 0) {
      return _historyObj[_historyObj.length - 1];
    } else {
      return _historyObj;
    }
  }
  /***
  	addFormHistory
  		add form history object
  			@param info <JSON> or NULL
  			@return <BOOLEAN>
  	***/


  function addFormHistory(info) {
    _self.emit("log", "form.js", "addFormHistory()", "info", info);

    if (_typeof(info) != "object" || info === null) {
      return false;
    } else {
      var canAdd = true;

      for (var i = 0; i < _historyObj.length; i++) {
        if (_historyObj[i].formId === info.formId) {
          canAdd = false;
          break;
        }
      }

      if (canAdd) {
        _historyObj.push(info);
      }

      return true;
    }
  }

  function removeFormHistory(title) {
    _self.emit("log", "form.js", "removeFormHistory(" + title + ")", "info");

    if (typeof title != "string" || title === null) {
      return false;
    } else {
      for (var i = 0; i < _historyObj.length; i++) {
        if (_historyObj[i].formId === title) {
          _historyObj.splice(i, 1);
        }
      }

      return true;
    }
  }
  /***
  	resetFormHistory
  		empty form history object
  		@return <BOOLEAN>
  	***/


  function resetFormHistory() {
    _self.emit("log", "form.js", "resetFormHistory()", "info");

    _historyObj = new Array();
    return true;
  }
  /***
  	showBackBt
  		checks if a a backButton element should be displayed or not
  			@return <BOOLEAN>
  	***/


  function showBackBt() {
    if (_historyObj.length > 1) {
      return true;
    } else {
      return false;
    }
  }
  /***
  	updateHistoryTab
  		updates tab for display correct tab in a form
  			@param tab <int>
  	***/


  function updateHistoryTab(tab) {
    if (_historyObj && !isNaN(tab) && tab !== null) {
      _historyObj.tab = tab;
    } else {
      if (_historyObj) {
        delete _historyObj['tab'];
      }
    }
  } //****************************************************************
  //*************           END  FORM HISTORY       ****************
  //****************************************************************
  //****************************************************************
  //*************          Exclude for mincut       ****************
  //****************************************************************


  function setExcludingMincut(bool) {
    _excludingMincut = bool;
  }

  function getExcludingMincut() {
    return _excludingMincut;
  } //****************************************************************
  //*************       END Exclude for mincut       ****************
  //****************************************************************


  module.exports = FormsSewernet;
  window.FormsSewernet = FormsSewernet;

  FormsSewernet.prototype.getVersion = function () {
    return _package.version;
  };

  FormsSewernet.prototype.getInfoForm = getInfoForm;
  FormsSewernet.prototype.getInfoFormFromCoordinates = getInfoFormFromCoordinates;
  FormsSewernet.prototype.getInfoFromPolygon = getInfoFromPolygon;
  FormsSewernet.prototype.getWebForms = getWebForms;
  FormsSewernet.prototype.getInfoFiles = getInfoFiles;
  FormsSewernet.prototype.setFeatureFile = setFeatureFile;
  FormsSewernet.prototype.deleteFeatureFile = deleteFeatureFile;
  FormsSewernet.prototype.getFormHistory = getFormHistory;
  FormsSewernet.prototype.addFormHistory = addFormHistory;
  FormsSewernet.prototype.resetFormHistory = resetFormHistory;
  FormsSewernet.prototype.showBackBt = showBackBt;
  FormsSewernet.prototype.removeFormHistory = removeFormHistory;
  FormsSewernet.prototype.updateHistoryTab = updateHistoryTab;
  FormsSewernet.prototype.setLocalizedStrings = setLocalizedStrings;
  FormsSewernet.prototype.showInput = showInput;
  FormsSewernet.prototype.deleteVisit = deleteVisit;
  FormsSewernet.prototype.upsertVisit = upsertVisit;
  FormsSewernet.prototype.getVisitsFromFeature = getVisitsFromFeature;
  FormsSewernet.prototype.getParameterIdFromParameterType = getParameterIdFromParameterType;
  FormsSewernet.prototype.updateVisit = updateVisit;
  FormsSewernet.prototype.getEventFormTypeAndEvent = getEventFormTypeAndEvent;
  FormsSewernet.prototype.insertEvent = insertEvent;
  FormsSewernet.prototype.getEvent = getEvent;
  FormsSewernet.prototype.updateEvent = updateEvent;
  FormsSewernet.prototype.deleteEvent = deleteEvent;
  FormsSewernet.prototype.getWebFormsForConnect = getWebFormsForConnect;
  FormsSewernet.prototype.getWebFormsForVisit = getWebFormsForVisit;
  FormsSewernet.prototype.cleanInputs = cleanInputs;
  FormsSewernet.prototype.validateInput = validateInput;
  FormsSewernet.prototype.getTableFromLayer_id_name = getTableFromLayer_id_name; //TBR!!!!

  FormsSewernet.prototype.getFormByFormId = getFormByFormId;
  FormsSewernet.prototype.getGallery = getGallery;
  FormsSewernet.prototype.deletePhoto = deletePhoto;
  FormsSewernet.prototype.getInsertFeatureForm = getInsertFeatureForm;
  FormsSewernet.prototype.insertFeature = insertFeature;
  FormsSewernet.prototype.deleteFeature = deleteFeature;
  FormsSewernet.prototype.updateFeature = updateFeature;
  FormsSewernet.prototype.updateFeatureGeometry = updateFeatureGeometry;
  FormsSewernet.prototype.initFilters = initFilters;
  FormsSewernet.prototype.updateFilters = updateFilters;
  FormsSewernet.prototype.getFilters = getFilters;
  FormsSewernet.prototype.getFormFilters = getFormFilters;
  FormsSewernet.prototype.getSearchForm = getSearchForm;
  FormsSewernet.prototype.getDataForAddress = getDataForAddress;
  FormsSewernet.prototype.updateSearch = updateSearch;
  FormsSewernet.prototype.updateSearchAdd = updateSearchAdd;
  FormsSewernet.prototype.getPrintForm = getPrintForm;
  FormsSewernet.prototype.updatePrint = updatePrint;
  FormsSewernet.prototype.printComposer = printComposer;
  FormsSewernet.prototype.captureScreen = captureScreen;
  FormsSewernet.prototype.getInfoMincut = getInfoMincut;
  FormsSewernet.prototype.getMincut = getMincut;
  FormsSewernet.prototype.getExcludingMincut = getExcludingMincut;
  FormsSewernet.prototype.setExcludingMincut = setExcludingMincut;
  FormsSewernet.prototype.upsertMincut = upsertMincut;
  FormsSewernet.prototype.getMincutManager = getMincutManager;
  FormsSewernet.prototype.updateMincutManager = updateMincutManager;
  FormsSewernet.prototype.excludeFromMincut = excludeFromMincut;
  FormsSewernet.prototype.processGetMincut = processGetMincut;
  FormsSewernet.prototype.setFormCoordinates = setFormCoordinates;
  FormsSewernet.prototype.updateMincutAdd = updateMincutAdd;
  FormsSewernet.prototype.endMincut = endMincut;
  FormsSewernet.prototype.startMincut = startMincut;
  FormsSewernet.prototype.setMincutValveLayerTableName = setMincutValveLayerTableName;
  FormsSewernet.prototype.getMincutValveLayerTableName = getMincutValveLayerTableName;
  FormsSewernet.prototype.setMincutGeometryForZoom = setMincutGeometryForZoom;
  FormsSewernet.prototype.getMincutGeometryForZoom = getMincutGeometryForZoom;
  FormsSewernet.prototype.setId_name_mincut = setId_name_mincut;
  FormsSewernet.prototype.getId_name_mincut = getId_name_mincut;
  FormsSewernet.prototype.setPol_id_mincut = setPol_id_mincut;
  FormsSewernet.prototype.getPol_id_mincut = getPol_id_mincut;
  FormsSewernet.prototype.getValueFromEditableField = getValueFromEditableField;
  FormsSewernet.prototype.getDatesForm = getDatesForm;
  FormsSewernet.prototype.setFilterDate = setFilterDate;
  FormsSewernet.prototype.gwGetVisit = gwGetVisit;
  FormsSewernet.prototype.gwSetVisit = gwSetVisit;
  FormsSewernet.prototype.gwSetDelete = gwSetDelete;
  FormsSewernet.prototype.gwGetVisitManager = gwGetVisitManager;
  FormsSewernet.prototype.gw_api_setvisitmanagerstart = gw_api_setvisitmanagerstart;
  FormsSewernet.prototype.gw_api_setvisitmanagerend = gw_api_setvisitmanagerend;
  FormsSewernet.prototype.gwSetVisitManager = gwSetVisitManager;
  FormsSewernet.prototype.gwGetLot = gwGetLot;
  FormsSewernet.prototype.gwSetLot = gwSetLot;
  FormsSewernet.prototype.gwSetVehicleLoad = gwSetVehicleLoad;
  FormsSewernet.prototype.setUpOfflineVisit = setUpOfflineVisit;
  FormsSewernet.prototype.storeVisitForms = storeVisitForms;
  FormsSewernet.prototype.clearOfflineVisits = clearOfflineVisits;
  FormsSewernet.prototype.clearVisitedSpots = clearVisitedSpots;
  FormsSewernet.prototype.dumpOfflineVisits = dumpOfflineVisits;
  FormsSewernet.prototype.saveVisitPicture = saveVisitPicture;
  FormsSewernet.prototype.toggleVisitedSpots = toggleVisitedSpots;
  FormsSewernet.prototype.renderVisitedSpotsLayer = renderVisitedSpotsLayer;
  FormsSewernet.prototype.setToken = setToken;
  FormsSewernet.prototype.updateAllFilters = updateAllFilters;
  FormsSewernet.prototype.storeDownloadDate = storeDownloadDate;
  FormsSewernet.prototype.storeDownloadDate = storeDownloadDate;

  FormsSewernet.prototype.getgo2epa = function () {
    return _go2epa.getgo2epa();
  };

  FormsSewernet.prototype.setgo2epa = function () {
    return _go2epa.setgo2epa();
  };

  FormsSewernet.prototype.showThumb = function (hash) {
    _self.emit("log", "form.js", "showThumb(" + hash + ")", "info");

    var noCache = Math.floor(Math.random() * 100 + 1);
    return axios.get("".concat(_baseHref, "external.thumb.php?img=").concat(hash, "&noCache=").concat(noCache)).then(function (result) {
      return result.data;
    });
  };

  FormsSewernet.prototype.getInfoFile = function (hash) {
    _self.emit("log", "form.js", "getInfoFile(" + hash + ")", "info");

    var noCache = Math.floor(Math.random() * 100 + 1);
    return axios.get("".concat(_baseHref, "external.getinfofile.php?img=").concat(hash, "&noCache=").concat(noCache)).then(function (result) {
      return result.data;
    });
  };
})();

},{"./dateselector":1,"./events":2,"./features":3,"./filters":4,"./formsContents":7,"./go2epa":8,"./mincut":9,"./package.json":46,"./print":47,"./search":48,"./visits":49,"axios":10,"events":84,"mobile-detect":37,"util":109}],7:[function(require,module,exports){
"use strict";

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var _project_type = "ws"; //<string> ws or ud

  var _expected_api_version;

  var _self;

  util.inherits(FormsContentsSewernet, _events);

  function FormsContentsSewernet(options) {
    if (typeof options.project_type !== "undefined") {
      _project_type = options.project_type.toLowerCase();
    }

    _expected_api_version = options.expected_api_version;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "form.js", "FormsContentsSewernet loaded", "success");
    }, 500);
  } //****************************************************************
  //********************    FORM AND TABS      *********************
  //****************************************************************

  /***
  	getFormByFormId
  		obtains form based on formID
  			@param formId <string>
  			@return <JSON>
  	***/


  function getFormByFormId(id) {
    var formId;
    var formName;
    var formParent;
    var availableTabs;
    var docSelectorForWebForms;

    if (id === "F16") {
      formId = 'F16';
      formName = 'INFO_GENERIC';
      formParent = 'formInfo';
    } else if (id === "F21") {
      formId = id;
      formName = 'VISIT';
      formParent = 'formInfo';
    } else if (id === "F22" || id === "F23" || id === "F24") {
      formId = id;
      formName = 'EVENT_FORM';
      formParent = 'formInfo';
    } else if (id === "F25") {
      formId = id;
      formName = 'VISIT_MANAGER';
      formParent = 'formInfo';
    } else if (id === "F27") {
      formId = id;
      formName = 'GALLERY';
      formParent = 'formInfo';
    } else if (id === "F51") {
      formId = id;
      formName = 'REVIEW_UD_ARC';
      formParent = 'formReview';
    } else if (id === "F52") {
      formId = id;
      formName = 'REVIEW_UD_NODE';
      formParent = 'formReview';
    } else if (id === "F53") {
      formId = id;
      formName = 'REVIEW_UD_CONNEC';
      formParent = 'formReview';
    } else if (id === "F54") {
      formId = id;
      formName = 'REVIEW_UD_GULLY';
      formParent = 'formReview';
    } else if (id === "F55") {
      formId = id;
      formName = 'REVIEW_WS_ARC';
      formParent = 'formReview';
    } else if (id === "F56") {
      formId = id;
      formName = 'REVIEW_WS_NODE';
      formParent = 'formReview';
    } else if (id === "F57") {
      formId = id;
      formName = 'REVIEW_WS_CONNEC';
      formParent = 'formReview';
    } else {
      formId = 'F11';
      formName = 'INFO_UD_NODE';
      formParent = 'formInfo';
      elementSelectorForWebForms = 'v_ui_element_x_node';
      docSelectorForWebForms = 'v_ui_doc_x_node';
    }

    var retorn = {};
    retorn.formId = formId;
    retorn.formName = formName;
    retorn.formParent = formParent;
    retorn.formTabs = _getTabsForFormID(formId);
    return retorn;
  }
  /***
  	getTabsForFormID
  		obtains an array with available tabs for an specific form
  			@param formId <string>
  			@return <ARRAY>
  	***/


  function _getTabsForFormID(formId) {
    var retorno;

    if (formId === "F21") {
      retorno = [];
    } else if (formId === "F22") {
      retorno = ['tabEvent_standard'];
    } else if (formId === "F23") {
      retorno = ['tabEvent_ud_arc_standard'];
    } else if (formId === "F24") {
      retorno = ['tabEvent_ud_arc_rehabit'];
    } else if (formId === "F25") {
      retorno = [];
    } else if (formId === "F27") {
      retorno = ['tabGallery'];
    } else if (formId === "F51" || formId === "F52" || formId === "F53" || formId === "F54" || formId === "F55" || formId === "F56" || formId === "F57") {
      retorno = [];
    } else {
      retorno = ['tabInfo'];
    }

    return retorno;
  } //****************************************************************
  //*******************    END FORM AND TABS   *********************
  //****************************************************************


  function getTableFromLayer_id_name(formId, layer_id_name) {
    if (formId === "F25") {
      if (layer_id_name === "node_id") {
        return "v_ui_om_visitman_x_node";
      } else if (layer_id_name === "arc_id") {
        return "v_ui_om_visitman_x_arc";
      } else if (layer_id_name === "gully_id") {
        return "v_ui_om_visitman_x_gully";
      }
    }
  }

  module.exports = FormsContentsSewernet; //FormsContentsSewernet.prototype.getFormAndTabs 		= getFormAndTabs;

  FormsContentsSewernet.prototype.getFormByFormId = getFormByFormId;
  FormsContentsSewernet.prototype.getTableFromLayer_id_name = getTableFromLayer_id_name;
})();

},{"events":84,"util":109}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _richLogger = _interopRequireDefault(require("../src/richLogger"));

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _self = null,
    _version = '1.0.0',
    _token = null,
    _events = null,
    _logger = null;

var Go2Epa =
/*#__PURE__*/
function () {
  function Go2Epa(options) {
    _classCallCheck(this, Go2Epa);

    if (typeof options === 'undefined') {
      throw new TypeError('no data');
    }

    if (typeof options.baseHref === 'undefined') {
      throw new TypeError('no options baseHref');
    }

    if (typeof options.token === 'undefined') {
      throw new TypeError('no token');
    }

    _token = options.token;
    _logger = new _richLogger["default"](options.env);
    _self = this;
    _self._fileName = 'go2epa.js';
    _self.options = options;

    _logger.info(_self._fileName, "Module loaded v.".concat(_version), options);
  }
  /**
     getgo2epa
  
       @param  <int>
       @param  <string> geom string
     **/


  _createClass(Go2Epa, [{
    key: "getgo2epa",
    value: function getgo2epa() {
      _logger.info(_self._fileName, "getgo2epa()");

      var dataToSend = {};
      dataToSend.token = _token;
      dataToSend.what = 'GET_GO_2_EPA';
      return _self._sendRequest(dataToSend, 'getgo2epa');
    }
    /**
      setgo2epa
          @param  <int>
        @param  <string> geom string
      **/

  }, {
    key: "setgo2epa",
    value: function setgo2epa() {
      _logger.info(_self._fileName, "setgo2epa()");

      var dataToSend = {};
      dataToSend.token = _token;
      dataToSend.what = 'SET_GO_2_EPA';
      return _self._sendRequest(dataToSend, 'setgo2epa');
    } //****************************************************************
    //********************          HELPERS      *********************
    //****************************************************************

  }, {
    key: "_sendRequest",
    value: function _sendRequest(dataToSend, action) {
      _logger.info(_self._fileName, "_sendRequest(".concat(action, ")"), dataToSend);

      return new Promise(function (resolve, reject) {
        _axios["default"].post(_self.options.basehref + '/notifications.ajax.php', dataToSend).then(function (response) {
          _logger.success(_self._fileName, "_sendRequest()", response.data);

          if (response.data.status === "Accepted") {
            resolve(response.data.message);
          } else {
            reject(response.data.message);
          }
        })["catch"](function (error) {
          _logger.error(_self._fileName, "_sendRequest()", error);

          reject(error);
        });
      });
    } //****************************************************************
    //***********************    END HELPERS    **********************
    //****************************************************************

  }]);

  return Go2Epa;
}();

exports["default"] = Go2Epa;

},{"../src/richLogger":79,"axios":10}],9:[function(require,module,exports){
"use strict";

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _expected_api_version;

  var _tabs;

  util.inherits(Mincut, _events);

  function Mincut(options) {
    _token = options.token;
    _baseHref = options.baseHref;
    _device = options.device;
    _expected_api_version = options.expected_api_version;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "mincut.js", "Mincut module loaded", "success");
    }, 500);
  }

  function setToken(token) {
    _token = token;
  } //****************************************************************
  //*************              GET MINCUT            ***************
  //****************************************************************

  /*
  	method getMincut
  		obtains form for mincut
  			@scope private
  		@param x <float> - x coordinate
  		@param y <float> - y coordinate
  		@param epsg <string> - SRID
  		@param mincut_id_arg <int> - mincut ID
  		@param cb <function> - callback
  	*/


  function getMincut(x, y, epsg, mincut_id_arg, id_name, cb) {
    try {
      _self.emit("log", "mincut.js", "getMincut(" + x + "," + y + "," + epsg + "," + mincut_id_arg + "," + id_name + ")", "info");

      var dataToSend = {};
      dataToSend.x = x;
      dataToSend.y = y;
      dataToSend.epsg = epsg;
      dataToSend.mincut_id_arg = mincut_id_arg;
      dataToSend.id_name = id_name;
      dataToSend.device = _device;
      dataToSend.token = _token;
      dataToSend.what = 'GET_MINCUT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "mincut.js", "getMincut response", "success", response.data.message);

          processGetMincut(response.data.message, cb);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "mincut.js", "getMincut", "error", error);
      });
    } catch (e) {
      _self.emit("log", "mincut.js", "getMincut error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*************            END GET MINCUT          ***************
  //****************************************************************
  //****************************************************************
  //*************              GET INFO MINCUT       ***************
  //****************************************************************

  /*
  	getInfoMincut
  		gets mincut data for Mincut tab on info form
  	*/


  function getInfoMincut(id_name, pol_id, fromDate, toDate, cb) {
    try {
      _self.emit("log", "mincut.js", "getInfoMincut(" + id_name + "," + pol_id + "," + fromDate + "," + toDate + ")", "info");

      var dataToSend = {};
      dataToSend.id_name = id_name;
      dataToSend.pol_id = pol_id;
      dataToSend.toDate = toDate;
      dataToSend.fromDate = fromDate;
      dataToSend.device = _device;
      dataToSend.token = _token;
      dataToSend.what = 'GET_INFO_MINCUT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "mincut.js", "getInfoMincut response", "success", response.data.message);

          cb(null, response.data.message);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "mincut.js", "getInfoMincut", "error", error);
      });
    } catch (e) {
      _self.emit("log", "mincut.js", "getInfoMincut error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*************         END GET INFO MINCUT         **************
  //****************************************************************
  //****************************************************************
  //*************             UPSERT MINCUT           **************
  //****************************************************************

  /***
  	upsertMincut
  
  		@param mincut_id <string>
  		@param x <float>
  		@param y <float>
  		@param srid <string> - epsg
  		@param device <int>
  		@param id_name <string>
  		@param pol_id <array>
  		@param formData <string>
  			@return callback
  	***/


  function upsertMincut(mincut_id, x, y, srid, device, id_name, pol_id, formData, cb) {
    _self.emit("log", "mincut.js", "upsertMincut(" + mincut_id + "," + x + "," + y + "," + srid + "," + device + "," + id_name + "," + pol_id + ")", "info", formData);

    var dataToSend = {};
    dataToSend.mincut_id = mincut_id;
    dataToSend.x = x;
    dataToSend.y = y;
    dataToSend.device = device;
    dataToSend.id_name = id_name;
    dataToSend.pol_id = pol_id;
    dataToSend.srid = srid; //dynamic attributes

    for (var k in formData) {
      if (k) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }
    }

    dataToSend.token = _token;
    dataToSend.what = 'UPSERT_MINCUT';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        _self.emit("log", "mincut.js", "upsertMincut response", "success", response.data.message);

        cb(null, response.data.message);
      } else {
        _self.emit("log", "mincut.js", "upsertMincut", "error", response.data.message);

        cb(response.data.message, response.data.message);
      }
    })["catch"](function (error) {
      _self.emit("log", "mincut.js", "upsertMincut", "error", error);

      cb(error, false);
      return false;
    });
  } //****************************************************************
  //*************         END UPSERT MINCUT           **************
  //****************************************************************
  //****************************************************************
  //*************          GET  MINCUT MANAGER       ***************
  //****************************************************************

  /*
  	getMincutManager
  		gets mincut data for Mincut tab on info form
  	*/


  function getMincutManager(device, cb) {
    try {
      _self.emit("log", "mincut.js", "getMincutManager(" + device + ")", "info");

      var dataToSend = {};
      dataToSend.device = _device;
      dataToSend.token = _token;
      dataToSend.what = 'GET_MINCUT_MANAGER';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "mincut.js", "getMincutManager response", "success", response.data.message);

          var retorno;

          if (typeof response.data.message.formTabs != "undefined") {
            retorno = response.data.message.formTabs;

            for (var i = 0; i < retorno.length; i++) {
              retorno[i].fields = _processMincutManagerFields(retorno[i].fields, retorno[i].tabName);
            }
          }

          var activeTabIndex = _getActiveTab(response.data.message.formTabs);

          retorno.activeTab = response.data.message.formTabs[activeTabIndex];
          retorno.activeTab.activeTabIndex = activeTabIndex;
          retorno.formName = response.data.message.formInfo.formName;
          _tabs = retorno;
          cb(null, retorno);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "mincut.js", "getMincutManager", "error", error);
      });
    } catch (e) {
      _self.emit("log", "mincut.js", "getMincutManager error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*************         END GET INFO MINCUT         **************
  //****************************************************************
  //****************************************************************
  //*************         UPDATE MINCUT MANAGER      ***************
  //****************************************************************

  /*
  	updateMincutManager
  		updates mincut manager
  	*/


  function updateMincutManager(formData, tabName, device, cb) {
    try {
      _self.emit("log", "mincut.js", "updateMincutManager(" + tabName + "," + device + ")", "info", formData);

      var dataToSend = {}; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.device = _device;
      dataToSend.token = _token;
      dataToSend.tab = tabName;
      dataToSend.what = 'GET_MINCUT_MANAGER';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "mincut.js", "updateMincutManager response", "success", response.data.message);

          var retorno;

          if (typeof response.data.message.formTabs != "undefined") {
            retorno = response.data.message.formTabs;

            for (var i = 0; i < retorno.length; i++) {
              retorno[i].fields = _processMincutManagerFields(retorno[i].fields, retorno[i].tabName);
            }
          }

          var activeTabIndex = _getActiveTab(response.data.message.formTabs);

          retorno.activeTab = response.data.message.formTabs[activeTabIndex];
          retorno.activeTab.activeTabIndex = activeTabIndex;
          _tabs = retorno;
          cb(null, retorno);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "mincut.js", "updateMincutManager", "error", error);
      });
    } catch (e) {
      _self.emit("log", "mincut.js", "updateMincutManager", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*************       END UPDATE MINCUT MANAGER    ***************
  //****************************************************************
  //****************************************************************
  //**********    UPDATE MINCUT ADD (typeahead field)  *************
  //****************************************************************


  function updateMincutAdd(fields, tabName, fieldName, val) {
    _self.emit("log", "mincut.js", "updateMincutAdd(" + tabName + "," + fieldName + "," + val + ")", "info", fields);

    var _processedFields = _processDataToSend(tabName, fields);

    var dataToSend = {};
    dataToSend.device = _device;
    dataToSend.token = _token;
    dataToSend.what = 'UPDATE_MINCUT_ADD';
    dataToSend.expected_api_version = _expected_api_version;
    dataToSend.searchData = JSON.stringify(_processedFields);
    dataToSend.json = 1;
    return axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        return response.data.message.data.map(function (item) {
          return item;
        });
      } else {
        return response;
      }
    })["catch"](function (error) {
      return error;
    });
    /*	var options = {
    			method: 'POST',
    			uri: _baseHref+"/ajax.sewernet.php",
    			body: dataToSend,
    			headers: {
    					'User-Agent': 'Request-Promise'
    			},
    			json: true
    	};
    	return rp(options).then(function (response) {
    		if(response.status==="Accepted"){
    			return response.message.data.map(function(item){
    				return item;
    			});
    		}else{
    			return response;
    		}
    	}).catch(function (err) {
    		return err;
    	});*/
  } //****************************************************************
  //****************      END UPDATE MINCUT ADD      ***************
  //****************************************************************
  //****************************************************************
  //*************          EXCLUDE FROM MINCUT       ***************
  //****************************************************************

  /*
  	excludeFromMincut
  		excludes a valve from mincut
  	*/


  function excludeFromMincut(valve_id, mincut_id, device, cb) {
    try {
      _self.emit("log", "mincut.js", "excludeFromMincut(" + valve_id + "," + mincut_id + "," + device + ")", "info");

      var dataToSend = {};
      dataToSend.valve_id = valve_id;
      dataToSend.mincut_id = mincut_id;
      dataToSend.device = device;
      dataToSend.token = _token;
      dataToSend.what = 'EXCLUDE_FROM_MINCUT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "mincut.js", "excludeFromMincut response", "success", response.data.message);

          cb(null, response.data.message);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "mincut.js", "excludeFromMincut", "error", error);
      });
    } catch (e) {
      _self.emit("log", "mincut.js", "excludeFromMincut", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************       END EXCLUDE FROM MINCUT         *************
  //****************************************************************
  //****************************************************************
  //*************             START MINCUT           ***************
  //****************************************************************

  /*
  	startMincut
  
  */


  function startMincut(mincut_id, device, cb) {
    try {
      _self.emit("log", "mincut.js", "startMincut(" + mincut_id + "," + device + ")", "info");

      var dataToSend = {};
      dataToSend.mincut_id = mincut_id;
      dataToSend.device = device;
      dataToSend.token = _token;
      dataToSend.what = 'START_MINCUT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "mincut.js", "startMincut response", "success", response.data.message);

          cb(null, response.data.message);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "mincut.js", "startMincut", "error", error);
      });
    } catch (e) {
      _self.emit("log", "mincut.js", "startMincut error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************            END END MINCUT             *************
  //****************************************************************
  //****************************************************************
  //*************               END MINCUT           ***************
  //****************************************************************

  /*
  	endMincut
  
  */


  function endMincut(mincut_id, device, id_name, pol_id, formData, cb) {
    try {
      _self.emit("log", "mincut.js", "endMincut(" + mincut_id + "," + device + "," + id_name + "," + pol_id + ")", "info", formData);

      var dataToSend = {};
      dataToSend.mincut_id = mincut_id;
      dataToSend.device = device;
      dataToSend.token = _token;
      dataToSend.id_name = id_name;
      dataToSend.pol_id = pol_id; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'END_MINCUT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "mincut.js", "endMincut response", "success", response.data.message);

          cb(null, response.data.message);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "mincut.js", "endMincut", "error", error);
      });
    } catch (e) {
      _self.emit("log", "mincut.js", "endMincut error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************            END END MINCUT             *************
  //****************************************************************
  //****************************************************************
  //************          PROCESS MINCUT FORM          *************
  //****************************************************************

  /*
  	processGetMincut
  		formats combos and buttons for getMincut
  			@param obj <json> getMincut response
  		@param cb <function> callback
  */


  function processGetMincut(obj, cb) {
    _self.emit("log", "mincut.js", "processGetMincut response", "info", obj);

    var retorno = {};

    if (typeof obj.formTabs != "undefined") {
      retorno = obj.formTabs;

      for (var i = 0; i < retorno.length; i++) {
        for (var f = 0; f < retorno[i].fields.length; f++) {
          if (retorno[i].fields[f]) {
            if (retorno[i].fields[f].type === "combo") {
              retorno[i].fields[f].comboValues = _assignValuesToCombo(retorno[i].fields[f]);
            } else if (retorno[i].fields[f].type === "button") {
              retorno[i].fields[f].buttonAction = _assignActionsToButton(retorno[i].fields[f]);
            }
          }
        }
      }

      var activeTabIndex = _getActiveTab(obj.formTabs);

      obj.activeTab = obj.formTabs[activeTabIndex];
      obj.activeTab.activeTabIndex = activeTabIndex;
      obj.formTabs = retorno;
      cb(null, obj);
    } else {
      cb("no fields", "no fields");
    }
  } //****************************************************************
  //************       END PROCESS MINCUT FORM         *************
  //****************************************************************
  //****************************************************************
  //*************           SETTERS/GETTERS          ***************
  //****************************************************************


  function _processMincutManagerFields(fields, tabName) {
    for (var f = 0; f < fields.length; f++) {
      if (fields[f]) {
        if (fields[f].type === "combo") {
          fields[f].comboValues = _assignValuesToCombo(fields[f]);
          fields[f].changeAction = "updateMincutManager";
        }

        if (fields[f].type === "list") {
          fields[f].changeAction = "getMincut";
        } else if (fields[f].type === "typeahead") {
          fields[f].getDataAction = "updatemincut_add";
          fields[f].selectAction = 'select_updatemincut_add';
          fields[f].tabName = tabName;
          fields[f].searchService = null;
        }
      }
    }

    return fields;
  } //****************************************************************
  //*************          END SETTERS/GETTERS       ***************
  //****************************************************************
  //****************************************************************
  //*************               HELPERS              ***************
  //****************************************************************


  function _assignValuesToCombo(object) {
    var comboValues = Array();

    try {
      for (var i = 0; i < object.comboIds.length; i++) {
        comboValues.push({
          id: object.comboIds[i],
          name: object.comboNames[i]
        });
      }

      return comboValues;
    } catch (e) {
      _self.emit("log", "mincut.js", "_assignValuesToCombo error formatting combo", "error", e.message);

      return false;
    }
  }

  function _assignActionsToButton(object) {
    try {
      if (object.name === "gw_fct_setcoordinates") {
        return "mincutLocation";
      } else if (object.name === "gw_fct_setmincut_start") {
        return "mincutStartMincut";
      } else if (object.name === "gw_fct_setmincut_end") {
        return "mincutEndMincut";
      }
    } catch (e) {
      _self.emit("log", "mincut.js", "_assignActionsToButton error formatting button", "error", e.message);

      return false;
    }
  }
  /***
  	_processDataToSend
  		gets the fields&values from a tab
  			@scope private
  		@param tabName<string>
  		@param fields<json>
  			@return <json>
  ***/


  function _processDataToSend(tabName, fields) {
    var retorno = [];

    for (var i = 0; i < _tabs.length; i++) {
      if (_tabs[i].tabName === tabName) {
        var item = {};
        item['tabName'] = _tabs[i].tabName.toLowerCase();

        for (var key in fields) {
          for (var f = 0; f < _tabs[i].fields.length; f++) {
            if (_tabs[i].fields[f].name === key) {
              if (_tabs[i].fields[f].type === "combo") {
                //find comboName
                var name = _tabs[i].fields[f].comboNames[_tabs[i].fields[f].comboIds.indexOf(fields[key])];

                item[key] = {
                  "id": fields[key],
                  "name": name
                };
              } else if (_tabs[i].fields[f].type === "typeahead") {
                item[key] = {
                  "text": fields[key]
                };
              }
            }
          }
        }

        retorno.push(item);
      }
    }

    return retorno;
  }

  function _getActiveTab(tabs) {
    if (tabs.length > 0) {
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].active) {
          return i;
          break;
        }
      }
    }
  }

  function _arrayToObj(array) {
    var output = {};

    for (var k in array) {
      if (array.hasOwnProperty(k)) {
        output[k] = array[k];
      }
    }

    return output;
  } //****************************************************************
  //*************                END HELPERS         ***************
  //****************************************************************


  module.exports = Mincut;
  Mincut.prototype.getMincut = getMincut;
  Mincut.prototype.getInfoMincut = getInfoMincut;
  Mincut.prototype.upsertMincut = upsertMincut;
  Mincut.prototype.getMincutManager = getMincutManager;
  Mincut.prototype.updateMincutManager = updateMincutManager;
  Mincut.prototype.excludeFromMincut = excludeFromMincut;
  Mincut.prototype.processGetMincut = processGetMincut;
  Mincut.prototype.updateMincutAdd = updateMincutAdd;
  Mincut.prototype.endMincut = endMincut;
  Mincut.prototype.startMincut = startMincut;
  Mincut.prototype.setToken = setToken;
})();

},{"axios":10,"events":84,"util":109}],10:[function(require,module,exports){
"use strict";

module.exports = require('./lib/axios');

},{"./lib/axios":12}],11:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var settle = require('./../core/settle');

var buildURL = require('./../helpers/buildURL');

var buildFullPath = require('../core/buildFullPath');

var parseHeaders = require('./../helpers/parseHeaders');

var isURLSameOrigin = require('./../helpers/isURLSameOrigin');

var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies'); // Add xsrf header


      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

},{"../core/buildFullPath":18,"../core/createError":19,"./../core/settle":23,"./../helpers/buildURL":27,"./../helpers/cookies":29,"./../helpers/isURLSameOrigin":31,"./../helpers/parseHeaders":33,"./../utils":35}],12:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var bind = require('./helpers/bind');

var Axios = require('./core/Axios');

var mergeConfig = require('./core/mergeConfig');

var defaults = require('./defaults');
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel'); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = require('./helpers/spread');
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

},{"./cancel/Cancel":13,"./cancel/CancelToken":14,"./cancel/isCancel":15,"./core/Axios":16,"./core/mergeConfig":22,"./defaults":25,"./helpers/bind":26,"./helpers/spread":34,"./utils":35}],13:[function(require,module,exports){
'use strict';
/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

},{}],14:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":13}],15:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],16:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var buildURL = require('../helpers/buildURL');

var InterceptorManager = require('./InterceptorManager');

var dispatchRequest = require('./dispatchRequest');

var mergeConfig = require('./mergeConfig');
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  } // Hook up interceptors middleware


  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

},{"../helpers/buildURL":27,"./../utils":35,"./InterceptorManager":17,"./dispatchRequest":20,"./mergeConfig":22}],17:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":35}],18:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');

var combineURLs = require('../helpers/combineURLs');
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

},{"../helpers/combineURLs":28,"../helpers/isAbsoluteURL":30}],19:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":21}],20:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var transformData = require('./transformData');

var isCancel = require('../cancel/isCancel');

var defaults = require('../defaults');
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":15,"../defaults":25,"./../utils":35,"./transformData":24}],21:[function(require,module,exports){
'use strict';
/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function () {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

},{}],22:[function(require,module,exports){
'use strict';

var utils = require('../utils');
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
  var defaultToConfig2Keys = ['baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath'];
  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys);
  var otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  return config;
};

},{"../utils":35}],23:[function(require,module,exports){
'use strict';

var createError = require('./createError');
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

},{"./createError":19}],24:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

},{"./../utils":35}],25:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./utils');

var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

}).call(this,require('_process'))
},{"./adapters/http":11,"./adapters/xhr":11,"./helpers/normalizeHeaderName":32,"./utils":35,"_process":90}],26:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

},{}],27:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":35}],28:[function(require,module,exports){
'use strict';
/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

},{}],29:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

},{"./../utils":35}],30:[function(require,module,exports){
'use strict';
/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],31:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

},{"./../utils":35}],32:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":35}],33:[function(require,module,exports){
'use strict';

var utils = require('./../utils'); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

},{"./../utils":35}],34:[function(require,module,exports){
'use strict';
/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],35:[function(require,module,exports){
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var bind = require('./helpers/bind');
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && _typeof(val) === 'object';
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function deepMerge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (_typeof(val) === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":26}],36:[function(require,module,exports){
(function (global){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (t) {
  "function" == typeof define && define.amd ? define(t) : t();
}(function () {
  "use strict";
  /** @license
     * jsPDF - PDF Document creation from JavaScript
     * Version 1.5.3 Built on 2018-12-27T14:11:42.696Z
     *                      CommitID d93d28db14
     *
     * Copyright (c) 2010-2016 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
     *               2010 Aaron Spike, https://github.com/acspike
     *               2012 Willow Systems Corporation, willow-systems.com
     *               2012 Pablo Hess, https://github.com/pablohess
     *               2012 Florian Jenett, https://github.com/fjenett
     *               2013 Warren Weckesser, https://github.com/warrenweckesser
     *               2013 Youssef Beddad, https://github.com/lifof
     *               2013 Lee Driscoll, https://github.com/lsdriscoll
     *               2013 Stefan Slonevskiy, https://github.com/stefslon
     *               2013 Jeremy Morel, https://github.com/jmorel
     *               2013 Christoph Hartmann, https://github.com/chris-rock
     *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
     *               2014 James Makes, https://github.com/dollaruw
     *               2014 Diego Casorran, https://github.com/diegocr
     *               2014 Steven Spungin, https://github.com/Flamenco
     *               2014 Kenneth Glassey, https://github.com/Gavvers
     *
     * Licensed under the MIT License
     *
     * Contributor(s):
     *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
     *    kim3er, mfo, alnorth, Flamenco
     */

  function se(t) {
    return (se = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
      return _typeof(t);
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
    })(t);
  }

  !function (t) {
    if ("object" !== se(t.console)) {
      t.console = {};

      for (var e, n, r = t.console, i = function i() {}, o = ["memory"], a = "assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn".split(","); e = o.pop();) {
        r[e] || (r[e] = {});
      }

      for (; n = a.pop();) {
        r[n] || (r[n] = i);
      }
    }

    var s,
        l,
        h,
        u,
        c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    void 0 === t.btoa && (t.btoa = function (t) {
      var e,
          n,
          r,
          i,
          o,
          a = 0,
          s = 0,
          l = "",
          h = [];
      if (!t) return t;

      for (; e = (o = t.charCodeAt(a++) << 16 | t.charCodeAt(a++) << 8 | t.charCodeAt(a++)) >> 18 & 63, n = o >> 12 & 63, r = o >> 6 & 63, i = 63 & o, h[s++] = c.charAt(e) + c.charAt(n) + c.charAt(r) + c.charAt(i), a < t.length;) {
        ;
      }

      l = h.join("");
      var u = t.length % 3;
      return (u ? l.slice(0, u - 3) : l) + "===".slice(u || 3);
    }), void 0 === t.atob && (t.atob = function (t) {
      var e,
          n,
          r,
          i,
          o,
          a,
          s = 0,
          l = 0,
          h = [];
      if (!t) return t;

      for (t += ""; e = (a = c.indexOf(t.charAt(s++)) << 18 | c.indexOf(t.charAt(s++)) << 12 | (i = c.indexOf(t.charAt(s++))) << 6 | (o = c.indexOf(t.charAt(s++)))) >> 16 & 255, n = a >> 8 & 255, r = 255 & a, h[l++] = 64 == i ? String.fromCharCode(e) : 64 == o ? String.fromCharCode(e, n) : String.fromCharCode(e, n, r), s < t.length;) {
        ;
      }

      return h.join("");
    }), Array.prototype.map || (Array.prototype.map = function (t) {
      if (null == this || "function" != typeof t) throw new TypeError();

      for (var e = Object(this), n = e.length >>> 0, r = new Array(n), i = 1 < arguments.length ? arguments[1] : void 0, o = 0; o < n; o++) {
        o in e && (r[o] = t.call(i, e[o], o, e));
      }

      return r;
    }), Array.isArray || (Array.isArray = function (t) {
      return "[object Array]" === Object.prototype.toString.call(t);
    }), Array.prototype.forEach || (Array.prototype.forEach = function (t, e) {
      if (null == this || "function" != typeof t) throw new TypeError();

      for (var n = Object(this), r = n.length >>> 0, i = 0; i < r; i++) {
        i in n && t.call(e, n[i], i, n);
      }
    }), Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
      value: function value(t) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var e = Object(this),
            n = e.length >>> 0;
        if ("function" != typeof t) throw new TypeError("predicate must be a function");

        for (var r = arguments[1], i = 0; i < n;) {
          var o = e[i];
          if (t.call(r, o, i, e)) return o;
          i++;
        }
      },
      configurable: !0,
      writable: !0
    }), Object.keys || (Object.keys = (s = Object.prototype.hasOwnProperty, l = !{
      toString: null
    }.propertyIsEnumerable("toString"), u = (h = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"]).length, function (t) {
      if ("object" !== se(t) && ("function" != typeof t || null === t)) throw new TypeError();
      var e,
          n,
          r = [];

      for (e in t) {
        s.call(t, e) && r.push(e);
      }

      if (l) for (n = 0; n < u; n++) {
        s.call(t, h[n]) && r.push(h[n]);
      }
      return r;
    })), "function" != typeof Object.assign && (Object.assign = function (t) {
      if (null == t) throw new TypeError("Cannot convert undefined or null to object");
      t = Object(t);

      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        if (null != n) for (var r in n) {
          Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
        }
      }

      return t;
    }), String.prototype.trim || (String.prototype.trim = function () {
      return this.replace(/^\s+|\s+$/g, "");
    }), String.prototype.trimLeft || (String.prototype.trimLeft = function () {
      return this.replace(/^\s+/g, "");
    }), String.prototype.trimRight || (String.prototype.trimRight = function () {
      return this.replace(/\s+$/g, "");
    }), Number.isInteger = Number.isInteger || function (t) {
      return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
    };
  }("undefined" != typeof self && self || "undefined" != typeof window && window || "undefined" != typeof global && global || Function('return typeof this === "object" && this.content')() || Function("return this")());

  var t,
      e,
      n,
      _,
      l,
      F,
      P,
      p,
      d,
      k,
      a,
      o,
      s,
      h,
      u,
      c,
      r,
      i,
      f,
      g,
      m,
      y,
      v,
      w,
      b,
      x,
      I,
      C,
      B,
      N,
      L,
      A,
      S,
      j,
      E,
      M,
      O,
      q,
      T,
      R,
      D,
      U,
      z,
      H,
      W,
      V,
      G,
      Y,
      J,
      X,
      K,
      Z,
      Q,
      $,
      tt,
      et,
      nt,
      rt,
      it,
      ot,
      at,
      st,
      lt = function (ie) {
    function oe(o) {
      if ("object" !== se(o)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
      var a = {};
      this.subscribe = function (t, e, n) {
        if (n = n || !1, "string" != typeof t || "function" != typeof e || "boolean" != typeof n) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
        a.hasOwnProperty(t) || (a[t] = {});
        var r = Math.random().toString(35);
        return a[t][r] = [e, !!n], r;
      }, this.unsubscribe = function (t) {
        for (var e in a) {
          if (a[e][t]) return delete a[e][t], 0 === Object.keys(a[e]).length && delete a[e], !0;
        }

        return !1;
      }, this.publish = function (t) {
        if (a.hasOwnProperty(t)) {
          var e = Array.prototype.slice.call(arguments, 1),
              n = [];

          for (var r in a[t]) {
            var i = a[t][r];

            try {
              i[0].apply(o, e);
            } catch (t) {
              ie.console && console.error("jsPDF PubSub Error", t.message, t);
            }

            i[1] && n.push(r);
          }

          n.length && n.forEach(this.unsubscribe);
        }
      }, this.getTopics = function () {
        return a;
      };
    }

    function ae(t, e, i, n) {
      var r = {},
          o = [],
          a = 1;
      "object" === se(t) && (t = (r = t).orientation, e = r.unit || e, i = r.format || i, n = r.compress || r.compressPdf || n, o = r.filters || (!0 === n ? ["FlateEncode"] : o), a = "number" == typeof r.userUnit ? Math.abs(r.userUnit) : 1), e = e || "mm", t = ("" + (t || "P")).toLowerCase();
      var s = r.putOnlyUsedFonts || !0,
          K = {},
          l = {
        internal: {},
        __private__: {}
      };
      l.__private__.PubSub = oe;

      var h = "1.3",
          u = l.__private__.getPdfVersion = function () {
        return h;
      },
          c = (l.__private__.setPdfVersion = function (t) {
        h = t;
      }, {
        a0: [2383.94, 3370.39],
        a1: [1683.78, 2383.94],
        a2: [1190.55, 1683.78],
        a3: [841.89, 1190.55],
        a4: [595.28, 841.89],
        a5: [419.53, 595.28],
        a6: [297.64, 419.53],
        a7: [209.76, 297.64],
        a8: [147.4, 209.76],
        a9: [104.88, 147.4],
        a10: [73.7, 104.88],
        b0: [2834.65, 4008.19],
        b1: [2004.09, 2834.65],
        b2: [1417.32, 2004.09],
        b3: [1000.63, 1417.32],
        b4: [708.66, 1000.63],
        b5: [498.9, 708.66],
        b6: [354.33, 498.9],
        b7: [249.45, 354.33],
        b8: [175.75, 249.45],
        b9: [124.72, 175.75],
        b10: [87.87, 124.72],
        c0: [2599.37, 3676.54],
        c1: [1836.85, 2599.37],
        c2: [1298.27, 1836.85],
        c3: [918.43, 1298.27],
        c4: [649.13, 918.43],
        c5: [459.21, 649.13],
        c6: [323.15, 459.21],
        c7: [229.61, 323.15],
        c8: [161.57, 229.61],
        c9: [113.39, 161.57],
        c10: [79.37, 113.39],
        dl: [311.81, 623.62],
        letter: [612, 792],
        "government-letter": [576, 756],
        legal: [612, 1008],
        "junior-legal": [576, 360],
        ledger: [1224, 792],
        tabloid: [792, 1224],
        "credit-card": [153, 243]
      }),
          f = (l.__private__.getPageFormats = function () {
        return c;
      }, l.__private__.getPageFormat = function (t) {
        return c[t];
      });

      "string" == typeof i && (i = f(i)), i = i || f("a4");

      var p,
          Z = l.f2 = l.__private__.f2 = function (t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.f2");
        return t.toFixed(2);
      },
          Q = l.__private__.f3 = function (t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.f3");
        return t.toFixed(3);
      },
          d = "00000000000000000000000000000000",
          g = l.__private__.getFileId = function () {
        return d;
      },
          m = l.__private__.setFileId = function (t) {
        return t = t || "12345678901234567890123456789012".split("").map(function () {
          return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
        }).join(""), d = t;
      };

      l.setFileId = function (t) {
        return m(t), this;
      }, l.getFileId = function () {
        return g();
      };

      var y = l.__private__.convertDateToPDFDate = function (t) {
        var e = t.getTimezoneOffset(),
            n = e < 0 ? "+" : "-",
            r = Math.floor(Math.abs(e / 60)),
            i = Math.abs(e % 60),
            o = [n, P(r), "'", P(i), "'"].join("");
        return ["D:", t.getFullYear(), P(t.getMonth() + 1), P(t.getDate()), P(t.getHours()), P(t.getMinutes()), P(t.getSeconds()), o].join("");
      },
          v = l.__private__.convertPDFDateToDate = function (t) {
        var e = parseInt(t.substr(2, 4), 10),
            n = parseInt(t.substr(6, 2), 10) - 1,
            r = parseInt(t.substr(8, 2), 10),
            i = parseInt(t.substr(10, 2), 10),
            o = parseInt(t.substr(12, 2), 10),
            a = parseInt(t.substr(14, 2), 10);
        parseInt(t.substr(16, 2), 10), parseInt(t.substr(20, 2), 10);
        return new Date(e, n, r, i, o, a, 0);
      },
          w = l.__private__.setCreationDate = function (t) {
        var e;
        if (void 0 === t && (t = new Date()), "object" === se(t) && "[object Date]" === Object.prototype.toString.call(t)) e = y(t);else {
          if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|\-0[0-9]|\-1[0-1])\'(0[0-9]|[1-5][0-9])\'?$/.test(t)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
          e = t;
        }
        return p = e;
      },
          b = l.__private__.getCreationDate = function (t) {
        var e = p;
        return "jsDate" === t && (e = v(p)), e;
      };

      l.setCreationDate = function (t) {
        return w(t), this;
      }, l.getCreationDate = function (t) {
        return b(t);
      };

      var x,
          N,
          L,
          A,
          S,
          $,
          _,
          F,
          P = l.__private__.padd2 = function (t) {
        return ("0" + parseInt(t)).slice(-2);
      },
          k = !1,
          I = [],
          C = [],
          B = 0,
          tt = (l.__private__.setCustomOutputDestination = function (t) {
        N = t;
      }, l.__private__.resetCustomOutputDestination = function (t) {
        N = void 0;
      }, l.__private__.out = function (t) {
        var e;
        return t = "string" == typeof t ? t : t.toString(), (e = void 0 === N ? k ? I[x] : C : N).push(t), k || (B += t.length + 1), e;
      }),
          j = l.__private__.write = function (t) {
        return tt(1 === arguments.length ? t.toString() : Array.prototype.join.call(arguments, " "));
      },
          E = l.__private__.getArrayBuffer = function (t) {
        for (var e = t.length, n = new ArrayBuffer(e), r = new Uint8Array(n); e--;) {
          r[e] = t.charCodeAt(e);
        }

        return n;
      },
          M = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]],
          et = (l.__private__.getStandardFonts = function (t) {
        return M;
      }, r.fontSize || 16),
          O = (l.__private__.setFontSize = l.setFontSize = function (t) {
        return et = t, this;
      }, l.__private__.getFontSize = l.getFontSize = function () {
        return et;
      }),
          nt = r.R2L || !1,
          q = (l.__private__.setR2L = l.setR2L = function (t) {
        return nt = t, this;
      }, l.__private__.getR2L = l.getR2L = function (t) {
        return nt;
      }, l.__private__.setZoomMode = function (t) {
        var e = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
        if (/^\d*\.?\d*\%$/.test(t)) L = t;else if (isNaN(t)) {
          if (-1 === e.indexOf(t)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t + '" is not recognized.');
          L = t;
        } else L = parseInt(t, 10);
      }),
          T = (l.__private__.getZoomMode = function () {
        return L;
      }, l.__private__.setPageMode = function (t) {
        if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t + '" is not recognized.');
        A = t;
      }),
          R = (l.__private__.getPageMode = function () {
        return A;
      }, l.__private__.setLayoutMode = function (t) {
        if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t + '" is not recognized.');
        S = t;
      }),
          D = (l.__private__.getLayoutMode = function () {
        return S;
      }, l.__private__.setDisplayMode = l.setDisplayMode = function (t, e, n) {
        return q(t), R(e), T(n), this;
      }, {
        title: "",
        subject: "",
        author: "",
        keywords: "",
        creator: ""
      }),
          U = (l.__private__.getDocumentProperty = function (t) {
        if (-1 === Object.keys(D).indexOf(t)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
        return D[t];
      }, l.__private__.getDocumentProperties = function (t) {
        return D;
      }, l.__private__.setDocumentProperties = l.setProperties = l.setDocumentProperties = function (t) {
        for (var e in D) {
          D.hasOwnProperty(e) && t[e] && (D[e] = t[e]);
        }

        return this;
      }, l.__private__.setDocumentProperty = function (t, e) {
        if (-1 === Object.keys(D).indexOf(t)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
        return D[t] = e;
      }, 0),
          z = [],
          rt = {},
          H = {},
          W = 0,
          V = [],
          G = [],
          it = new oe(l),
          Y = r.hotfixes || [],
          J = l.__private__.newObject = function () {
        var t = X();
        return ot(t, !0), t;
      },
          X = l.__private__.newObjectDeferred = function () {
        return z[++U] = function () {
          return B;
        }, U;
      },
          ot = function ot(t, e) {
        return e = "boolean" == typeof e && e, z[t] = B, e && tt(t + " 0 obj"), t;
      },
          at = l.__private__.newAdditionalObject = function () {
        var t = {
          objId: X(),
          content: ""
        };
        return G.push(t), t;
      },
          st = X(),
          lt = X(),
          ht = l.__private__.decodeColorString = function (t) {
        var e = t.split(" ");

        if (2 === e.length && ("g" === e[1] || "G" === e[1])) {
          var n = parseFloat(e[0]);
          e = [n, n, n, "r"];
        }

        for (var r = "#", i = 0; i < 3; i++) {
          r += ("0" + Math.floor(255 * parseFloat(e[i])).toString(16)).slice(-2);
        }

        return r;
      },
          ut = l.__private__.encodeColorString = function (t) {
        var e;
        "string" == typeof t && (t = {
          ch1: t
        });
        var n = t.ch1,
            r = t.ch2,
            i = t.ch3,
            o = t.ch4,
            a = (t.precision, "draw" === t.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"]);

        if ("string" == typeof n && "#" !== n.charAt(0)) {
          var s = new RGBColor(n);
          if (s.ok) n = s.toHex();else if (!/^\d*\.?\d*$/.test(n)) throw new Error('Invalid color "' + n + '" passed to jsPDF.encodeColorString.');
        }

        if ("string" == typeof n && /^#[0-9A-Fa-f]{3}$/.test(n) && (n = "#" + n[1] + n[1] + n[2] + n[2] + n[3] + n[3]), "string" == typeof n && /^#[0-9A-Fa-f]{6}$/.test(n)) {
          var l = parseInt(n.substr(1), 16);
          n = l >> 16 & 255, r = l >> 8 & 255, i = 255 & l;
        }

        if (void 0 === r || void 0 === o && n === r && r === i) {
          if ("string" == typeof n) e = n + " " + a[0];else switch (t.precision) {
            case 2:
              e = Z(n / 255) + " " + a[0];
              break;

            case 3:
            default:
              e = Q(n / 255) + " " + a[0];
          }
        } else if (void 0 === o || "object" === se(o)) {
          if (o && !isNaN(o.a) && 0 === o.a) return e = ["1.000", "1.000", "1.000", a[1]].join(" ");
          if ("string" == typeof n) e = [n, r, i, a[1]].join(" ");else switch (t.precision) {
            case 2:
              e = [Z(n / 255), Z(r / 255), Z(i / 255), a[1]].join(" ");
              break;

            default:
            case 3:
              e = [Q(n / 255), Q(r / 255), Q(i / 255), a[1]].join(" ");
          }
        } else if ("string" == typeof n) e = [n, r, i, o, a[2]].join(" ");else switch (t.precision) {
          case 2:
            e = [Z(n / 255), Z(r / 255), Z(i / 255), Z(o / 255), a[2]].join(" ");
            break;

          case 3:
          default:
            e = [Q(n / 255), Q(r / 255), Q(i / 255), Q(o / 255), a[2]].join(" ");
        }
        return e;
      },
          ct = l.__private__.getFilters = function () {
        return o;
      },
          ft = l.__private__.putStream = function (t) {
        var e = (t = t || {}).data || "",
            n = t.filters || ct(),
            r = t.alreadyAppliedFilters || [],
            i = t.addLength1 || !1,
            o = e.length,
            a = {};
        !0 === n && (n = ["FlateEncode"]);
        var s = t.additionalKeyValues || [],
            l = (a = void 0 !== ae.API.processDataByFilters ? ae.API.processDataByFilters(e, n) : {
          data: e,
          reverseChain: []
        }).reverseChain + (Array.isArray(r) ? r.join(" ") : r.toString());
        0 !== a.data.length && (s.push({
          key: "Length",
          value: a.data.length
        }), !0 === i && s.push({
          key: "Length1",
          value: o
        })), 0 != l.length && (l.split("/").length - 1 == 1 ? s.push({
          key: "Filter",
          value: l
        }) : s.push({
          key: "Filter",
          value: "[" + l + "]"
        })), tt("<<");

        for (var h = 0; h < s.length; h++) {
          tt("/" + s[h].key + " " + s[h].value);
        }

        tt(">>"), 0 !== a.data.length && (tt("stream"), tt(a.data), tt("endstream"));
      },
          pt = l.__private__.putPage = function (t) {
        t.mediaBox;
        var e = t.number,
            n = t.data,
            r = t.objId,
            i = t.contentsObjId;
        ot(r, !0);
        V[x].mediaBox.topRightX, V[x].mediaBox.bottomLeftX, V[x].mediaBox.topRightY, V[x].mediaBox.bottomLeftY;
        tt("<</Type /Page"), tt("/Parent " + t.rootDictionaryObjId + " 0 R"), tt("/Resources " + t.resourceDictionaryObjId + " 0 R"), tt("/MediaBox [" + parseFloat(Z(t.mediaBox.bottomLeftX)) + " " + parseFloat(Z(t.mediaBox.bottomLeftY)) + " " + Z(t.mediaBox.topRightX) + " " + Z(t.mediaBox.topRightY) + "]"), null !== t.cropBox && tt("/CropBox [" + Z(t.cropBox.bottomLeftX) + " " + Z(t.cropBox.bottomLeftY) + " " + Z(t.cropBox.topRightX) + " " + Z(t.cropBox.topRightY) + "]"), null !== t.bleedBox && tt("/BleedBox [" + Z(t.bleedBox.bottomLeftX) + " " + Z(t.bleedBox.bottomLeftY) + " " + Z(t.bleedBox.topRightX) + " " + Z(t.bleedBox.topRightY) + "]"), null !== t.trimBox && tt("/TrimBox [" + Z(t.trimBox.bottomLeftX) + " " + Z(t.trimBox.bottomLeftY) + " " + Z(t.trimBox.topRightX) + " " + Z(t.trimBox.topRightY) + "]"), null !== t.artBox && tt("/ArtBox [" + Z(t.artBox.bottomLeftX) + " " + Z(t.artBox.bottomLeftY) + " " + Z(t.artBox.topRightX) + " " + Z(t.artBox.topRightY) + "]"), "number" == typeof t.userUnit && 1 !== t.userUnit && tt("/UserUnit " + t.userUnit), it.publish("putPage", {
          objId: r,
          pageContext: V[e],
          pageNumber: e,
          page: n
        }), tt("/Contents " + i + " 0 R"), tt(">>"), tt("endobj");
        var o = n.join("\n");
        return ot(i, !0), ft({
          data: o,
          filters: ct()
        }), tt("endobj"), r;
      },
          dt = l.__private__.putPages = function () {
        var t,
            e,
            n = [];

        for (t = 1; t <= W; t++) {
          V[t].objId = X(), V[t].contentsObjId = X();
        }

        for (t = 1; t <= W; t++) {
          n.push(pt({
            number: t,
            data: I[t],
            objId: V[t].objId,
            contentsObjId: V[t].contentsObjId,
            mediaBox: V[t].mediaBox,
            cropBox: V[t].cropBox,
            bleedBox: V[t].bleedBox,
            trimBox: V[t].trimBox,
            artBox: V[t].artBox,
            userUnit: V[t].userUnit,
            rootDictionaryObjId: st,
            resourceDictionaryObjId: lt
          }));
        }

        ot(st, !0), tt("<</Type /Pages");
        var r = "/Kids [";

        for (e = 0; e < W; e++) {
          r += n[e] + " 0 R ";
        }

        tt(r + "]"), tt("/Count " + W), tt(">>"), tt("endobj"), it.publish("postPutPages");
      },
          gt = function gt() {
        !function () {
          for (var t in rt) {
            rt.hasOwnProperty(t) && (!1 === s || !0 === s && K.hasOwnProperty(t)) && (e = rt[t], it.publish("putFont", {
              font: e,
              out: tt,
              newObject: J,
              putStream: ft
            }), !0 !== e.isAlreadyPutted && (e.objectNumber = J(), tt("<<"), tt("/Type /Font"), tt("/BaseFont /" + e.postScriptName), tt("/Subtype /Type1"), "string" == typeof e.encoding && tt("/Encoding /" + e.encoding), tt("/FirstChar 32"), tt("/LastChar 255"), tt(">>"), tt("endobj")));
          }

          var e;
        }(), it.publish("putResources"), ot(lt, !0), tt("<<"), function () {
          for (var t in tt("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), tt("/Font <<"), rt) {
            rt.hasOwnProperty(t) && (!1 === s || !0 === s && K.hasOwnProperty(t)) && tt("/" + t + " " + rt[t].objectNumber + " 0 R");
          }

          tt(">>"), tt("/XObject <<"), it.publish("putXobjectDict"), tt(">>");
        }(), tt(">>"), tt("endobj"), it.publish("postPutResources");
      },
          mt = function mt(t, e, n) {
        H.hasOwnProperty(e) || (H[e] = {}), H[e][n] = t;
      },
          yt = function yt(t, e, n, r, i) {
        i = i || !1;
        var o = "F" + (Object.keys(rt).length + 1).toString(10),
            a = {
          id: o,
          postScriptName: t,
          fontName: e,
          fontStyle: n,
          encoding: r,
          isStandardFont: i,
          metadata: {}
        };
        return it.publish("addFont", {
          font: a,
          instance: this
        }), void 0 !== o && (rt[o] = a, mt(o, e, n)), o;
      },
          vt = l.__private__.pdfEscape = l.pdfEscape = function (t, e) {
        return function (t, e) {
          var n, r, i, o, a, s, l, h, u;

          if (i = (e = e || {}).sourceEncoding || "Unicode", a = e.outputEncoding, (e.autoencode || a) && rt[$].metadata && rt[$].metadata[i] && rt[$].metadata[i].encoding && (o = rt[$].metadata[i].encoding, !a && rt[$].encoding && (a = rt[$].encoding), !a && o.codePages && (a = o.codePages[0]), "string" == typeof a && (a = o[a]), a)) {
            for (l = !1, s = [], n = 0, r = t.length; n < r; n++) {
              (h = a[t.charCodeAt(n)]) ? s.push(String.fromCharCode(h)) : s.push(t[n]), s[n].charCodeAt(0) >> 8 && (l = !0);
            }

            t = s.join("");
          }

          for (n = t.length; void 0 === l && 0 !== n;) {
            t.charCodeAt(n - 1) >> 8 && (l = !0), n--;
          }

          if (!l) return t;

          for (s = e.noBOM ? [] : [254, 255], n = 0, r = t.length; n < r; n++) {
            if ((u = (h = t.charCodeAt(n)) >> 8) >> 8) throw new Error("Character at position " + n + " of string '" + t + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
            s.push(u), s.push(h - (u << 8));
          }

          return String.fromCharCode.apply(void 0, s);
        }(t, e).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
      },
          wt = l.__private__.beginPage = function (t, e) {
        var n,
            r = "string" == typeof e && e.toLowerCase();

        if ("string" == typeof t && (n = f(t.toLowerCase())) && (t = n[0], e = n[1]), Array.isArray(t) && (e = t[1], t = t[0]), (isNaN(t) || isNaN(e)) && (t = i[0], e = i[1]), r) {
          switch (r.substr(0, 1)) {
            case "l":
              t < e && (r = "s");
              break;

            case "p":
              e < t && (r = "s");
          }

          "s" === r && (n = t, t = e, e = n);
        }

        (14400 < t || 14400 < e) && (console.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), t = Math.min(14400, t), e = Math.min(14400, e)), i = [t, e], k = !0, I[++W] = [], V[W] = {
          objId: 0,
          contentsObjId: 0,
          userUnit: Number(a),
          artBox: null,
          bleedBox: null,
          cropBox: null,
          trimBox: null,
          mediaBox: {
            bottomLeftX: 0,
            bottomLeftY: 0,
            topRightX: Number(t),
            topRightY: Number(e)
          }
        }, xt(W);
      },
          bt = function bt() {
        wt.apply(this, arguments), Dt(Rt), tt(Jt), 0 !== te && tt(te + " J"), 0 !== ne && tt(ne + " j"), it.publish("addPage", {
          pageNumber: W
        });
      },
          xt = function xt(t) {
        0 < t && t <= W && (x = t);
      },
          Nt = l.__private__.getNumberOfPages = l.getNumberOfPages = function () {
        return I.length - 1;
      },
          Lt = function Lt(t, e, n) {
        var r,
            i = void 0;
        return n = n || {}, t = void 0 !== t ? t : rt[$].fontName, e = void 0 !== e ? e : rt[$].fontStyle, r = t.toLowerCase(), void 0 !== H[r] && void 0 !== H[r][e] ? i = H[r][e] : void 0 !== H[t] && void 0 !== H[t][e] ? i = H[t][e] : !1 === n.disableWarning && console.warn("Unable to look up font label for font '" + t + "', '" + e + "'. Refer to getFontList() for available fonts."), i || n.noFallback || null == (i = H.times[e]) && (i = H.times.normal), i;
      },
          At = l.__private__.putInfo = function () {
        for (var t in J(), tt("<<"), tt("/Producer (jsPDF " + ae.version + ")"), D) {
          D.hasOwnProperty(t) && D[t] && tt("/" + t.substr(0, 1).toUpperCase() + t.substr(1) + " (" + vt(D[t]) + ")");
        }

        tt("/CreationDate (" + p + ")"), tt(">>"), tt("endobj");
      },
          St = l.__private__.putCatalog = function (t) {
        var e = (t = t || {}).rootDictionaryObjId || st;

        switch (J(), tt("<<"), tt("/Type /Catalog"), tt("/Pages " + e + " 0 R"), L || (L = "fullwidth"), L) {
          case "fullwidth":
            tt("/OpenAction [3 0 R /FitH null]");
            break;

          case "fullheight":
            tt("/OpenAction [3 0 R /FitV null]");
            break;

          case "fullpage":
            tt("/OpenAction [3 0 R /Fit]");
            break;

          case "original":
            tt("/OpenAction [3 0 R /XYZ null null 1]");
            break;

          default:
            var n = "" + L;
            "%" === n.substr(n.length - 1) && (L = parseInt(L) / 100), "number" == typeof L && tt("/OpenAction [3 0 R /XYZ null null " + Z(L) + "]");
        }

        switch (S || (S = "continuous"), S) {
          case "continuous":
            tt("/PageLayout /OneColumn");
            break;

          case "single":
            tt("/PageLayout /SinglePage");
            break;

          case "two":
          case "twoleft":
            tt("/PageLayout /TwoColumnLeft");
            break;

          case "tworight":
            tt("/PageLayout /TwoColumnRight");
        }

        A && tt("/PageMode /" + A), it.publish("putCatalog"), tt(">>"), tt("endobj");
      },
          _t = l.__private__.putTrailer = function () {
        tt("trailer"), tt("<<"), tt("/Size " + (U + 1)), tt("/Root " + U + " 0 R"), tt("/Info " + (U - 1) + " 0 R"), tt("/ID [ <" + d + "> <" + d + "> ]"), tt(">>");
      },
          Ft = l.__private__.putHeader = function () {
        tt("%PDF-" + h), tt("%ºß¬à");
      },
          Pt = l.__private__.putXRef = function () {
        var t = 1,
            e = "0000000000";

        for (tt("xref"), tt("0 " + (U + 1)), tt("0000000000 65535 f "), t = 1; t <= U; t++) {
          "function" == typeof z[t] ? tt((e + z[t]()).slice(-10) + " 00000 n ") : void 0 !== z[t] ? tt((e + z[t]).slice(-10) + " 00000 n ") : tt("0000000000 00000 n ");
        }
      },
          kt = l.__private__.buildDocument = function () {
        k = !1, B = U = 0, C = [], z = [], G = [], st = X(), lt = X(), it.publish("buildDocument"), Ft(), dt(), function () {
          it.publish("putAdditionalObjects");

          for (var t = 0; t < G.length; t++) {
            var e = G[t];
            ot(e.objId, !0), tt(e.content), tt("endobj");
          }

          it.publish("postPutAdditionalObjects");
        }(), gt(), At(), St();
        var t = B;
        return Pt(), _t(), tt("startxref"), tt("" + t), tt("%%EOF"), k = !0, C.join("\n");
      },
          It = l.__private__.getBlob = function (t) {
        return new Blob([E(t)], {
          type: "application/pdf"
        });
      },
          Ct = l.output = l.__private__.output = ((F = function F(t, e) {
        e = e || {};
        var n = kt();

        switch ("string" == typeof e ? e = {
          filename: e
        } : e.filename = e.filename || "generated.pdf", t) {
          case void 0:
            return n;

          case "save":
            l.save(e.filename);
            break;

          case "arraybuffer":
            return E(n);

          case "blob":
            return It(n);

          case "bloburi":
          case "bloburl":
            if (void 0 !== ie.URL && "function" == typeof ie.URL.createObjectURL) return ie.URL && ie.URL.createObjectURL(It(n)) || void 0;
            console.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
            break;

          case "datauristring":
          case "dataurlstring":
            return "data:application/pdf;filename=" + e.filename + ";base64," + btoa(n);

          case "dataurlnewwindow":
            var r = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring") + '"></iframe></body></html>',
                i = ie.open();
            if (null !== i && i.document.write(r), i || "undefined" == typeof safari) return i;

          case "datauri":
          case "dataurl":
            return ie.document.location.href = "data:application/pdf;filename=" + e.filename + ";base64," + btoa(n);

          default:
            return null;
        }
      }).foo = function () {
        try {
          return F.apply(this, arguments);
        } catch (t) {
          var e = t.stack || "";
          ~e.indexOf(" at ") && (e = e.split(" at ")[1]);
          var n = "Error in function " + e.split("\n")[0].split("<")[0] + ": " + t.message;
          if (!ie.console) throw new Error(n);
          ie.console.error(n, t), ie.alert && alert(n);
        }
      }, (F.foo.bar = F).foo),
          Bt = function Bt(t) {
        return !0 === Array.isArray(Y) && -1 < Y.indexOf(t);
      };

      switch (e) {
        case "pt":
          _ = 1;
          break;

        case "mm":
          _ = 72 / 25.4;
          break;

        case "cm":
          _ = 72 / 2.54;
          break;

        case "in":
          _ = 72;
          break;

        case "px":
          _ = 1 == Bt("px_scaling") ? .75 : 96 / 72;
          break;

        case "pc":
        case "em":
          _ = 12;
          break;

        case "ex":
          _ = 6;
          break;

        default:
          throw new Error("Invalid unit: " + e);
      }

      w(), m();

      var jt = l.__private__.getPageInfo = function (t) {
        if (isNaN(t) || t % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
        return {
          objId: V[t].objId,
          pageNumber: t,
          pageContext: V[t]
        };
      },
          Et = l.__private__.getPageInfoByObjId = function (t) {
        for (var e in V) {
          if (V[e].objId === t) break;
        }

        if (isNaN(t) || t % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
        return jt(e);
      },
          Mt = l.__private__.getCurrentPageInfo = function () {
        return {
          objId: V[x].objId,
          pageNumber: x,
          pageContext: V[x]
        };
      };

      l.addPage = function () {
        return bt.apply(this, arguments), this;
      }, l.setPage = function () {
        return xt.apply(this, arguments), this;
      }, l.insertPage = function (t) {
        return this.addPage(), this.movePage(x, t), this;
      }, l.movePage = function (t, e) {
        if (e < t) {
          for (var n = I[t], r = V[t], i = t; e < i; i--) {
            I[i] = I[i - 1], V[i] = V[i - 1];
          }

          I[e] = n, V[e] = r, this.setPage(e);
        } else if (t < e) {
          for (n = I[t], r = V[t], i = t; i < e; i++) {
            I[i] = I[i + 1], V[i] = V[i + 1];
          }

          I[e] = n, V[e] = r, this.setPage(e);
        }

        return this;
      }, l.deletePage = function () {
        return function (t) {
          0 < t && t <= W && (I.splice(t, 1), --W < x && (x = W), this.setPage(x));
        }.apply(this, arguments), this;
      };
      l.__private__.text = l.text = function (t, e, n, i) {
        var r;
        "number" != typeof t || "number" != typeof e || "string" != typeof n && !Array.isArray(n) || (r = n, n = e, e = t, t = r);
        var o = arguments[3],
            a = arguments[4],
            s = arguments[5];
        if ("object" === se(o) && null !== o || ("string" == typeof a && (s = a, a = null), "string" == typeof o && (s = o, o = null), "number" == typeof o && (a = o, o = null), i = {
          flags: o,
          angle: a,
          align: s
        }), (o = o || {}).noBOM = o.noBOM || !0, o.autoencode = o.autoencode || !0, isNaN(e) || isNaN(n) || null == t) throw new Error("Invalid arguments passed to jsPDF.text");
        if (0 === t.length) return c;
        var l,
            h = "",
            u = "number" == typeof i.lineHeightFactor ? i.lineHeightFactor : Tt,
            c = i.scope || this;

        function f(t) {
          for (var e, n = t.concat(), r = [], i = n.length; i--;) {
            "string" == typeof (e = n.shift()) ? r.push(e) : Array.isArray(t) && 1 === e.length ? r.push(e[0]) : r.push([e[0], e[1], e[2]]);
          }

          return r;
        }

        function p(t, e) {
          var n;
          if ("string" == typeof t) n = e(t)[0];else if (Array.isArray(t)) {
            for (var r, i, o = t.concat(), a = [], s = o.length; s--;) {
              "string" == typeof (r = o.shift()) ? a.push(e(r)[0]) : Array.isArray(r) && "string" === r[0] && (i = e(r[0], r[1], r[2]), a.push([i[0], i[1], i[2]]));
            }

            n = a;
          }
          return n;
        }

        var d = !1,
            g = !0;
        if ("string" == typeof t) d = !0;else if (Array.isArray(t)) {
          for (var m, y = t.concat(), v = [], w = y.length; w--;) {
            ("string" != typeof (m = y.shift()) || Array.isArray(m) && "string" != typeof m[0]) && (g = !1);
          }

          d = g;
        }
        if (!1 === d) throw new Error('Type of text must be string or Array. "' + t + '" is not recognized.');
        var b = rt[$].encoding;
        "WinAnsiEncoding" !== b && "StandardEncoding" !== b || (t = p(t, function (t, e, n) {
          return [(r = t, r = r.split("\t").join(Array(i.TabLen || 9).join(" ")), vt(r, o)), e, n];
          var r;
        })), "string" == typeof t && (t = t.match(/[\r?\n]/) ? t.split(/\r\n|\r|\n/g) : [t]);
        var x = et / c.internal.scaleFactor,
            N = x * (Tt - 1);

        switch (i.baseline) {
          case "bottom":
            n -= N;
            break;

          case "top":
            n += x - N;
            break;

          case "hanging":
            n += x - 2 * N;
            break;

          case "middle":
            n += x / 2 - N;
        }

        0 < (O = i.maxWidth || 0) && ("string" == typeof t ? t = c.splitTextToSize(t, O) : "[object Array]" === Object.prototype.toString.call(t) && (t = c.splitTextToSize(t.join(" "), O)));
        var L = {
          text: t,
          x: e,
          y: n,
          options: i,
          mutex: {
            pdfEscape: vt,
            activeFontKey: $,
            fonts: rt,
            activeFontSize: et
          }
        };
        it.publish("preProcessText", L), t = L.text;
        a = (i = L.options).angle;
        var A = c.internal.scaleFactor,
            S = [];

        if (a) {
          a *= Math.PI / 180;

          var _ = Math.cos(a),
              F = Math.sin(a);

          S = [Z(_), Z(F), Z(-1 * F), Z(_)];
        }

        void 0 !== (M = i.charSpace) && (h += Q(M * A) + " Tc\n");
        i.lang;
        var P = -1,
            k = void 0 !== i.renderingMode ? i.renderingMode : i.stroke,
            I = c.internal.getCurrentPageInfo().pageContext;

        switch (k) {
          case 0:
          case !1:
          case "fill":
            P = 0;
            break;

          case 1:
          case !0:
          case "stroke":
            P = 1;
            break;

          case 2:
          case "fillThenStroke":
            P = 2;
            break;

          case 3:
          case "invisible":
            P = 3;
            break;

          case 4:
          case "fillAndAddForClipping":
            P = 4;
            break;

          case 5:
          case "strokeAndAddPathForClipping":
            P = 5;
            break;

          case 6:
          case "fillThenStrokeAndAddToPathForClipping":
            P = 6;
            break;

          case 7:
          case "addToPathForClipping":
            P = 7;
        }

        var C = void 0 !== I.usedRenderingMode ? I.usedRenderingMode : -1;
        -1 !== P ? h += P + " Tr\n" : -1 !== C && (h += "0 Tr\n"), -1 !== P && (I.usedRenderingMode = P);
        s = i.align || "left";
        var B = et * u,
            j = c.internal.pageSize.getWidth(),
            E = (A = c.internal.scaleFactor, rt[$]),
            M = i.charSpace || Qt,
            O = i.maxWidth || 0,
            q = (o = {}, []);

        if ("[object Array]" === Object.prototype.toString.call(t)) {
          var T, R;
          v = f(t);
          "left" !== s && (R = v.map(function (t) {
            return c.getStringUnitWidth(t, {
              font: E,
              charSpace: M,
              fontSize: et
            }) * et / A;
          }));
          var D,
              U = Math.max.apply(Math, R),
              z = 0;

          if ("right" === s) {
            e -= R[0], t = [];
            var H = 0;

            for (w = v.length; H < w; H++) {
              U - R[H], T = 0 === H ? (D = Wt(e), Vt(n)) : (D = (z - R[H]) * A, -B), t.push([v[H], D, T]), z = R[H];
            }
          } else if ("center" === s) {
            e -= R[0] / 2, t = [];

            for (H = 0, w = v.length; H < w; H++) {
              (U - R[H]) / 2, T = 0 === H ? (D = Wt(e), Vt(n)) : (D = (z - R[H]) / 2 * A, -B), t.push([v[H], D, T]), z = R[H];
            }
          } else if ("left" === s) {
            t = [];

            for (H = 0, w = v.length; H < w; H++) {
              T = 0 === H ? Vt(n) : -B, D = 0 === H ? Wt(e) : 0, t.push(v[H]);
            }
          } else {
            if ("justify" !== s) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
            t = [];

            for (O = 0 !== O ? O : j, H = 0, w = v.length; H < w; H++) {
              T = 0 === H ? Vt(n) : -B, D = 0 === H ? Wt(e) : 0, H < w - 1 && q.push(((O - R[H]) / (v[H].split(" ").length - 1) * A).toFixed(2)), t.push([v[H], D, T]);
            }
          }
        }

        !0 === ("boolean" == typeof i.R2L ? i.R2L : nt) && (t = p(t, function (t, e, n) {
          return [t.split("").reverse().join(""), e, n];
        }));
        L = {
          text: t,
          x: e,
          y: n,
          options: i,
          mutex: {
            pdfEscape: vt,
            activeFontKey: $,
            fonts: rt,
            activeFontSize: et
          }
        };
        it.publish("postProcessText", L), t = L.text, l = L.mutex.isHex;
        v = f(t);
        t = [];
        var W,
            V,
            G,
            Y = 0,
            J = (w = v.length, "");

        for (H = 0; H < w; H++) {
          J = "", Array.isArray(v[H]) ? (W = parseFloat(v[H][1]), V = parseFloat(v[H][2]), G = (l ? "<" : "(") + v[H][0] + (l ? ">" : ")"), Y = 1) : (W = Wt(e), V = Vt(n), G = (l ? "<" : "(") + v[H] + (l ? ">" : ")")), void 0 !== q && void 0 !== q[H] && (J = q[H] + " Tw\n"), 0 !== S.length && 0 === H ? t.push(J + S.join(" ") + " " + W.toFixed(2) + " " + V.toFixed(2) + " Tm\n" + G) : 1 === Y || 0 === Y && 0 === H ? t.push(J + W.toFixed(2) + " " + V.toFixed(2) + " Td\n" + G) : t.push(J + G);
        }

        t = 0 === Y ? t.join(" Tj\nT* ") : t.join(" Tj\n"), t += " Tj\n";
        var X = "BT\n/" + $ + " " + et + " Tf\n" + (et * u).toFixed(2) + " TL\n" + Kt + "\n";
        return X += h, X += t, tt(X += "ET"), K[$] = !0, c;
      }, l.__private__.lstext = l.lstext = function (t, e, n, r) {
        return console.warn("jsPDF.lstext is deprecated"), this.text(t, e, n, {
          charSpace: r
        });
      }, l.__private__.clip = l.clip = function (t) {
        tt("evenodd" === t ? "W*" : "W"), tt("n");
      }, l.__private__.clip_fixed = l.clip_fixed = function (t) {
        console.log("clip_fixed is deprecated"), l.clip(t);
      };

      var Ot = l.__private__.isValidStyle = function (t) {
        var e = !1;
        return -1 !== [void 0, null, "S", "F", "DF", "FD", "f", "f*", "B", "B*"].indexOf(t) && (e = !0), e;
      },
          qt = l.__private__.getStyle = function (t) {
        var e = "S";
        return "F" === t ? e = "f" : "FD" === t || "DF" === t ? e = "B" : "f" !== t && "f*" !== t && "B" !== t && "B*" !== t || (e = t), e;
      };

      l.__private__.line = l.line = function (t, e, n, r) {
        if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r)) throw new Error("Invalid arguments passed to jsPDF.line");
        return this.lines([[n - t, r - e]], t, e);
      }, l.__private__.lines = l.lines = function (t, e, n, r, i, o) {
        var a, s, l, h, u, c, f, p, d, g, m, y;
        if ("number" == typeof t && (y = n, n = e, e = t, t = y), r = r || [1, 1], o = o || !1, isNaN(e) || isNaN(n) || !Array.isArray(t) || !Array.isArray(r) || !Ot(i) || "boolean" != typeof o) throw new Error("Invalid arguments passed to jsPDF.lines");

        for (tt(Q(Wt(e)) + " " + Q(Vt(n)) + " m "), a = r[0], s = r[1], h = t.length, g = e, m = n, l = 0; l < h; l++) {
          2 === (u = t[l]).length ? (g = u[0] * a + g, m = u[1] * s + m, tt(Q(Wt(g)) + " " + Q(Vt(m)) + " l")) : (c = u[0] * a + g, f = u[1] * s + m, p = u[2] * a + g, d = u[3] * s + m, g = u[4] * a + g, m = u[5] * s + m, tt(Q(Wt(c)) + " " + Q(Vt(f)) + " " + Q(Wt(p)) + " " + Q(Vt(d)) + " " + Q(Wt(g)) + " " + Q(Vt(m)) + " c"));
        }

        return o && tt(" h"), null !== i && tt(qt(i)), this;
      }, l.__private__.rect = l.rect = function (t, e, n, r, i) {
        if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r) || !Ot(i)) throw new Error("Invalid arguments passed to jsPDF.rect");
        return tt([Z(Wt(t)), Z(Vt(e)), Z(n * _), Z(-r * _), "re"].join(" ")), null !== i && tt(qt(i)), this;
      }, l.__private__.triangle = l.triangle = function (t, e, n, r, i, o, a) {
        if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r) || isNaN(i) || isNaN(o) || !Ot(a)) throw new Error("Invalid arguments passed to jsPDF.triangle");
        return this.lines([[n - t, r - e], [i - n, o - r], [t - i, e - o]], t, e, [1, 1], a, !0), this;
      }, l.__private__.roundedRect = l.roundedRect = function (t, e, n, r, i, o, a) {
        if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r) || isNaN(i) || isNaN(o) || !Ot(a)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
        var s = 4 / 3 * (Math.SQRT2 - 1);
        return this.lines([[n - 2 * i, 0], [i * s, 0, i, o - o * s, i, o], [0, r - 2 * o], [0, o * s, -i * s, o, -i, o], [2 * i - n, 0], [-i * s, 0, -i, -o * s, -i, -o], [0, 2 * o - r], [0, -o * s, i * s, -o, i, -o]], t + i, e, [1, 1], a), this;
      }, l.__private__.ellipse = l.ellipse = function (t, e, n, r, i) {
        if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r) || !Ot(i)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
        var o = 4 / 3 * (Math.SQRT2 - 1) * n,
            a = 4 / 3 * (Math.SQRT2 - 1) * r;
        return tt([Z(Wt(t + n)), Z(Vt(e)), "m", Z(Wt(t + n)), Z(Vt(e - a)), Z(Wt(t + o)), Z(Vt(e - r)), Z(Wt(t)), Z(Vt(e - r)), "c"].join(" ")), tt([Z(Wt(t - o)), Z(Vt(e - r)), Z(Wt(t - n)), Z(Vt(e - a)), Z(Wt(t - n)), Z(Vt(e)), "c"].join(" ")), tt([Z(Wt(t - n)), Z(Vt(e + a)), Z(Wt(t - o)), Z(Vt(e + r)), Z(Wt(t)), Z(Vt(e + r)), "c"].join(" ")), tt([Z(Wt(t + o)), Z(Vt(e + r)), Z(Wt(t + n)), Z(Vt(e + a)), Z(Wt(t + n)), Z(Vt(e)), "c"].join(" ")), null !== i && tt(qt(i)), this;
      }, l.__private__.circle = l.circle = function (t, e, n, r) {
        if (isNaN(t) || isNaN(e) || isNaN(n) || !Ot(r)) throw new Error("Invalid arguments passed to jsPDF.circle");
        return this.ellipse(t, e, n, n, r);
      };
      l.setFont = function (t, e) {
        return $ = Lt(t, e, {
          disableWarning: !1
        }), this;
      }, l.setFontStyle = l.setFontType = function (t) {
        return $ = Lt(void 0, t), this;
      };

      l.__private__.getFontList = l.getFontList = function () {
        var t,
            e,
            n,
            r = {};

        for (t in H) {
          if (H.hasOwnProperty(t)) for (e in r[t] = n = [], H[t]) {
            H[t].hasOwnProperty(e) && n.push(e);
          }
        }

        return r;
      };

      l.addFont = function (t, e, n, r) {
        yt.call(this, t, e, n, r = r || "Identity-H");
      };

      var Tt,
          Rt = r.lineWidth || .200025,
          Dt = l.__private__.setLineWidth = l.setLineWidth = function (t) {
        return tt((t * _).toFixed(2) + " w"), this;
      },
          Ut = (l.__private__.setLineDash = ae.API.setLineDash = function (t, e) {
        if (t = t || [], e = e || 0, isNaN(e) || !Array.isArray(t)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
        return t = t.map(function (t) {
          return (t * _).toFixed(3);
        }).join(" "), e = parseFloat((e * _).toFixed(3)), tt("[" + t + "] " + e + " d"), this;
      }, l.__private__.getLineHeight = l.getLineHeight = function () {
        return et * Tt;
      }),
          zt = (Ut = l.__private__.getLineHeight = l.getLineHeight = function () {
        return et * Tt;
      }, l.__private__.setLineHeightFactor = l.setLineHeightFactor = function (t) {
        return "number" == typeof (t = t || 1.15) && (Tt = t), this;
      }),
          Ht = l.__private__.getLineHeightFactor = l.getLineHeightFactor = function () {
        return Tt;
      };

      zt(r.lineHeight);

      var Wt = l.__private__.getHorizontalCoordinate = function (t) {
        return t * _;
      },
          Vt = l.__private__.getVerticalCoordinate = function (t) {
        return V[x].mediaBox.topRightY - V[x].mediaBox.bottomLeftY - t * _;
      },
          Gt = l.__private__.getHorizontalCoordinateString = function (t) {
        return Z(t * _);
      },
          Yt = l.__private__.getVerticalCoordinateString = function (t) {
        return Z(V[x].mediaBox.topRightY - V[x].mediaBox.bottomLeftY - t * _);
      },
          Jt = r.strokeColor || "0 G",
          Xt = (l.__private__.getStrokeColor = l.getDrawColor = function () {
        return ht(Jt);
      }, l.__private__.setStrokeColor = l.setDrawColor = function (t, e, n, r) {
        return Jt = ut({
          ch1: t,
          ch2: e,
          ch3: n,
          ch4: r,
          pdfColorType: "draw",
          precision: 2
        }), tt(Jt), this;
      }, r.fillColor || "0 g"),
          Kt = (l.__private__.getFillColor = l.getFillColor = function () {
        return ht(Xt);
      }, l.__private__.setFillColor = l.setFillColor = function (t, e, n, r) {
        return Xt = ut({
          ch1: t,
          ch2: e,
          ch3: n,
          ch4: r,
          pdfColorType: "fill",
          precision: 2
        }), tt(Xt), this;
      }, r.textColor || "0 g"),
          Zt = l.__private__.getTextColor = l.getTextColor = function () {
        return ht(Kt);
      },
          Qt = (l.__private__.setTextColor = l.setTextColor = function (t, e, n, r) {
        return Kt = ut({
          ch1: t,
          ch2: e,
          ch3: n,
          ch4: r,
          pdfColorType: "text",
          precision: 3
        }), this;
      }, r.charSpace || 0),
          $t = l.__private__.getCharSpace = l.getCharSpace = function () {
        return Qt;
      },
          te = (l.__private__.setCharSpace = l.setCharSpace = function (t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
        return Qt = t, this;
      }, 0);

      l.CapJoinStyles = {
        0: 0,
        butt: 0,
        but: 0,
        miter: 0,
        1: 1,
        round: 1,
        rounded: 1,
        circle: 1,
        2: 2,
        projecting: 2,
        project: 2,
        square: 2,
        bevel: 2
      };

      l.__private__.setLineCap = l.setLineCap = function (t) {
        var e = l.CapJoinStyles[t];
        if (void 0 === e) throw new Error("Line cap style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        return tt((te = e) + " J"), this;
      };

      var ee,
          ne = 0;
      l.__private__.setLineJoin = l.setLineJoin = function (t) {
        var e = l.CapJoinStyles[t];
        if (void 0 === e) throw new Error("Line join style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        return tt((ne = e) + " j"), this;
      }, l.__private__.setMiterLimit = l.setMiterLimit = function (t) {
        if (t = t || 0, isNaN(t)) throw new Error("Invalid argument passed to jsPDF.setMiterLimit");
        return ee = parseFloat(Z(t * _)), tt(ee + " M"), this;
      };

      for (var re in l.save = function (r, t) {
        if (r = r || "generated.pdf", (t = t || {}).returnPromise = t.returnPromise || !1, !1 !== t.returnPromise) return new Promise(function (t, e) {
          try {
            var n = le(It(kt()), r);
            "function" == typeof le.unload && ie.setTimeout && setTimeout(le.unload, 911), t(n);
          } catch (t) {
            e(t.message);
          }
        });
        le(It(kt()), r), "function" == typeof le.unload && ie.setTimeout && setTimeout(le.unload, 911);
      }, ae.API) {
        ae.API.hasOwnProperty(re) && ("events" === re && ae.API.events.length ? function (t, e) {
          var n, r, i;

          for (i = e.length - 1; -1 !== i; i--) {
            n = e[i][0], r = e[i][1], t.subscribe.apply(t, [n].concat("function" == typeof r ? [r] : r));
          }
        }(it, ae.API.events) : l[re] = ae.API[re]);
      }

      return l.internal = {
        pdfEscape: vt,
        getStyle: qt,
        getFont: function getFont() {
          return rt[Lt.apply(l, arguments)];
        },
        getFontSize: O,
        getCharSpace: $t,
        getTextColor: Zt,
        getLineHeight: Ut,
        getLineHeightFactor: Ht,
        write: j,
        getHorizontalCoordinate: Wt,
        getVerticalCoordinate: Vt,
        getCoordinateString: Gt,
        getVerticalCoordinateString: Yt,
        collections: {},
        newObject: J,
        newAdditionalObject: at,
        newObjectDeferred: X,
        newObjectDeferredBegin: ot,
        getFilters: ct,
        putStream: ft,
        events: it,
        scaleFactor: _,
        pageSize: {
          getWidth: function getWidth() {
            return (V[x].mediaBox.topRightX - V[x].mediaBox.bottomLeftX) / _;
          },
          setWidth: function setWidth(t) {
            V[x].mediaBox.topRightX = t * _ + V[x].mediaBox.bottomLeftX;
          },
          getHeight: function getHeight() {
            return (V[x].mediaBox.topRightY - V[x].mediaBox.bottomLeftY) / _;
          },
          setHeight: function setHeight(t) {
            V[x].mediaBox.topRightY = t * _ + V[x].mediaBox.bottomLeftY;
          }
        },
        output: Ct,
        getNumberOfPages: Nt,
        pages: I,
        out: tt,
        f2: Z,
        f3: Q,
        getPageInfo: jt,
        getPageInfoByObjId: Et,
        getCurrentPageInfo: Mt,
        getPDFVersion: u,
        hasHotfix: Bt
      }, Object.defineProperty(l.internal.pageSize, "width", {
        get: function get() {
          return (V[x].mediaBox.topRightX - V[x].mediaBox.bottomLeftX) / _;
        },
        set: function set(t) {
          V[x].mediaBox.topRightX = t * _ + V[x].mediaBox.bottomLeftX;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(l.internal.pageSize, "height", {
        get: function get() {
          return (V[x].mediaBox.topRightY - V[x].mediaBox.bottomLeftY) / _;
        },
        set: function set(t) {
          V[x].mediaBox.topRightY = t * _ + V[x].mediaBox.bottomLeftY;
        },
        enumerable: !0,
        configurable: !0
      }), function (t) {
        for (var e = 0, n = M.length; e < n; e++) {
          var r = yt(t[e][0], t[e][1], t[e][2], M[e][3], !0);
          K[r] = !0;
          var i = t[e][0].split("-");
          mt(r, i[0], i[1] || "");
        }

        it.publish("addFonts", {
          fonts: rt,
          dictionary: H
        });
      }(M), $ = "F1", bt(i, t), it.publish("initialized"), l;
    }

    return ae.API = {
      events: []
    }, ae.version = "1.5.3", "function" == typeof define && define.amd ? define("jsPDF", function () {
      return ae;
    }) : "undefined" != typeof module && module.exports ? (module.exports = ae, module.exports.jsPDF = ae) : ie.jsPDF = ae, ae;
  }("undefined" != typeof self && self || "undefined" != typeof window && window || "undefined" != typeof global && global || Function('return typeof this === "object" && this.content')() || Function("return this")());
  /**
     * @license
     * Copyright (c) 2016 Alexander Weidt,
     * https://github.com/BiggA94
     * 
     * Licensed under the MIT License. http://opensource.org/licenses/mit-license
     */


  (function (t, e) {
    var A,
        n = 1,
        S = function S(t) {
      return t.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
    },
        y = function y(t) {
      return t.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
    },
        _ = function _(t) {
      if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.f2");
      return t.toFixed(2);
    },
        s = function s(t) {
      if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.f2");
      return t.toFixed(5);
    };

    t.__acroform__ = {};

    var r = function r(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t;
    },
        v = function v(t) {
      return t * n;
    },
        w = function w(t) {
      return t / n;
    },
        l = function l(t) {
      var e = new j(),
          n = Y.internal.getHeight(t) || 0,
          r = Y.internal.getWidth(t) || 0;
      return e.BBox = [0, 0, Number(_(r)), Number(_(n))], e;
    },
        i = t.__acroform__.setBit = function (t, e) {
      if (t = t || 0, e = e || 0, isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
      return t |= 1 << e;
    },
        o = t.__acroform__.clearBit = function (t, e) {
      if (t = t || 0, e = e || 0, isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
      return t &= ~(1 << e);
    },
        a = t.__acroform__.getBit = function (t, e) {
      if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
      return 0 == (t & 1 << e) ? 0 : 1;
    },
        b = t.__acroform__.getBitForPdf = function (t, e) {
      if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
      return a(t, e - 1);
    },
        x = t.__acroform__.setBitForPdf = function (t, e) {
      if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
      return i(t, e - 1);
    },
        N = t.__acroform__.clearBitForPdf = function (t, e, n) {
      if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
      return o(t, e - 1);
    },
        c = t.__acroform__.calculateCoordinates = function (t) {
      var e = this.internal.getHorizontalCoordinate,
          n = this.internal.getVerticalCoordinate,
          r = t[0],
          i = t[1],
          o = t[2],
          a = t[3],
          s = {};
      return s.lowerLeft_X = e(r) || 0, s.lowerLeft_Y = n(i + a) || 0, s.upperRight_X = e(r + o) || 0, s.upperRight_Y = n(i) || 0, [Number(_(s.lowerLeft_X)), Number(_(s.lowerLeft_Y)), Number(_(s.upperRight_X)), Number(_(s.upperRight_Y))];
    },
        f = function f(t) {
      if (t.appearanceStreamContent) return t.appearanceStreamContent;

      if (t.V || t.DV) {
        var e = [],
            n = t.V || t.DV,
            r = h(t, n),
            i = A.internal.getFont(t.fontName, t.fontStyle).id;
        e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(A.__private__.encodeColorString(t.color)), e.push("/" + i + " " + _(r.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(r.text), e.push("ET"), e.push("Q"), e.push("EMC");
        var o = new l(t);
        return o.stream = e.join("\n"), o;
      }
    },
        h = function h(i, t) {
      var e = i.maxFontSize || 12,
          n = (i.fontName, {
        text: "",
        fontSize: ""
      }),
          o = (t = ")" == (t = "(" == t.substr(0, 1) ? t.substr(1) : t).substr(t.length - 1) ? t.substr(0, t.length - 1) : t).split(" "),
          r = (A.__private__.encodeColorString(i.color), e),
          a = Y.internal.getHeight(i) || 0;
      a = a < 0 ? -a : a;
      var s = Y.internal.getWidth(i) || 0;
      s = s < 0 ? -s : s;

      var l = function l(t, e, n) {
        if (t + 1 < o.length) {
          var r = e + " " + o[t + 1];
          return F(r, i, n).width <= s - 4;
        }

        return !1;
      };

      r++;

      t: for (;;) {
        t = "";
        var h = F("3", i, --r).height,
            u = i.multiline ? a - r : (a - h) / 2,
            c = -2,
            f = u += 2,
            p = 0,
            d = 0,
            g = 0;

        if (r <= 0) {
          t = "(...) Tj\n", t += "% Width of Text: " + F(t, i, r = 12).width + ", FieldWidth:" + s + "\n";
          break;
        }

        g = F(o[0] + " ", i, r).width;
        var m = "",
            y = 0;

        for (var v in o) {
          if (o.hasOwnProperty(v)) {
            m = " " == (m += o[v] + " ").substr(m.length - 1) ? m.substr(0, m.length - 1) : m;
            var w = parseInt(v);
            g = F(m + " ", i, r).width;
            var b = l(w, m, r),
                x = v >= o.length - 1;

            if (b && !x) {
              m += " ";
              continue;
            }

            if (b || x) {
              if (x) d = w;else if (i.multiline && a < (h + 2) * (y + 2) + 2) continue t;
            } else {
              if (!i.multiline) continue t;
              if (a < (h + 2) * (y + 2) + 2) continue t;
              d = w;
            }

            for (var N = "", L = p; L <= d; L++) {
              N += o[L] + " ";
            }

            switch (N = " " == N.substr(N.length - 1) ? N.substr(0, N.length - 1) : N, g = F(N, i, r).width, i.textAlign) {
              case "right":
                c = s - g - 2;
                break;

              case "center":
                c = (s - g) / 2;
                break;

              case "left":
              default:
                c = 2;
            }

            t += _(c) + " " + _(f) + " Td\n", t += "(" + S(N) + ") Tj\n", t += -_(c) + " 0 Td\n", f = -(r + 2), g = 0, p = d + 1, y++, m = "";
          } else ;
        }

        break;
      }

      return n.text = t, n.fontSize = r, n;
    },
        F = function F(t, e, n) {
      var r = A.internal.getFont(e.fontName, e.fontStyle),
          i = A.getStringUnitWidth(t, {
        font: r,
        fontSize: parseFloat(n),
        charSpace: 0
      }) * parseFloat(n);
      return {
        height: A.getStringUnitWidth("3", {
          font: r,
          fontSize: parseFloat(n),
          charSpace: 0
        }) * parseFloat(n) * 1.5,
        width: i
      };
    },
        u = {
      fields: [],
      xForms: [],
      acroFormDictionaryRoot: null,
      printedOut: !1,
      internal: null,
      isInitialized: !1
    },
        p = function p() {
      A.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
      var t = A.internal.acroformPlugin.acroFormDictionaryRoot.Fields;

      for (var e in t) {
        if (t.hasOwnProperty(e)) {
          var n = t[e];
          n.objId = void 0, n.hasAnnotation && d.call(A, n);
        }
      }
    },
        d = function d(t) {
      var e = {
        type: "reference",
        object: t
      };
      void 0 === A.internal.getPageInfo(t.page).pageContext.annotations.find(function (t) {
        return t.type === e.type && t.object === e.object;
      }) && A.internal.getPageInfo(t.page).pageContext.annotations.push(e);
    },
        g = function g() {
      if (void 0 === A.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
      A.internal.write("/AcroForm " + A.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
    },
        m = function m() {
      A.internal.events.unsubscribe(A.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete A.internal.acroformPlugin.acroFormDictionaryRoot._eventID, A.internal.acroformPlugin.printedOut = !0;
    },
        L = function L(t) {
      var e = !t;
      t || (A.internal.newObjectDeferredBegin(A.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), A.internal.acroformPlugin.acroFormDictionaryRoot.putStream());
      t = t || A.internal.acroformPlugin.acroFormDictionaryRoot.Kids;

      for (var n in t) {
        if (t.hasOwnProperty(n)) {
          var r = t[n],
              i = [],
              o = r.Rect;

          if (r.Rect && (r.Rect = c.call(this, r.Rect)), A.internal.newObjectDeferredBegin(r.objId, !0), r.DA = Y.createDefaultAppearanceStream(r), "object" === se(r) && "function" == typeof r.getKeyValueListForStream && (i = r.getKeyValueListForStream()), r.Rect = o, r.hasAppearanceStream && !r.appearanceStreamContent) {
            var a = f.call(this, r);
            i.push({
              key: "AP",
              value: "<</N " + a + ">>"
            }), A.internal.acroformPlugin.xForms.push(a);
          }

          if (r.appearanceStreamContent) {
            var s = "";

            for (var l in r.appearanceStreamContent) {
              if (r.appearanceStreamContent.hasOwnProperty(l)) {
                var h = r.appearanceStreamContent[l];
                if (s += "/" + l + " ", s += "<<", 1 <= Object.keys(h).length || Array.isArray(h)) for (var n in h) {
                  var u;
                  if (h.hasOwnProperty(n)) "function" == typeof (u = h[n]) && (u = u.call(this, r)), s += "/" + n + " " + u + " ", 0 <= A.internal.acroformPlugin.xForms.indexOf(u) || A.internal.acroformPlugin.xForms.push(u);
                } else "function" == typeof (u = h) && (u = u.call(this, r)), s += "/" + n + " " + u, 0 <= A.internal.acroformPlugin.xForms.indexOf(u) || A.internal.acroformPlugin.xForms.push(u);
                s += ">>";
              }
            }

            i.push({
              key: "AP",
              value: "<<\n" + s + ">>"
            });
          }

          A.internal.putStream({
            additionalKeyValues: i
          }), A.internal.out("endobj");
        }
      }

      e && P.call(this, A.internal.acroformPlugin.xForms);
    },
        P = function P(t) {
      for (var e in t) {
        if (t.hasOwnProperty(e)) {
          var n = e,
              r = t[e];
          A.internal.newObjectDeferredBegin(r && r.objId, !0), "object" === se(r) && "function" == typeof r.putStream && r.putStream(), delete t[n];
        }
      }
    },
        k = function k() {
      if (void 0 !== this.internal && (void 0 === this.internal.acroformPlugin || !1 === this.internal.acroformPlugin.isInitialized)) {
        if (A = this, M.FieldNum = 0, this.internal.acroformPlugin = JSON.parse(JSON.stringify(u)), this.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
        n = A.internal.scaleFactor, A.internal.acroformPlugin.acroFormDictionaryRoot = new E(), A.internal.acroformPlugin.acroFormDictionaryRoot._eventID = A.internal.events.subscribe("postPutResources", m), A.internal.events.subscribe("buildDocument", p), A.internal.events.subscribe("putCatalog", g), A.internal.events.subscribe("postPutPages", L), A.internal.acroformPlugin.isInitialized = !0;
      }
    },
        I = t.__acroform__.arrayToPdfArray = function (t) {
      if (Array.isArray(t)) {
        for (var e = "[", n = 0; n < t.length; n++) {
          switch (0 !== n && (e += " "), se(t[n])) {
            case "boolean":
            case "number":
            case "object":
              e += t[n].toString();
              break;

            case "string":
              "/" !== t[n].substr(0, 1) ? e += "(" + S(t[n].toString()) + ")" : e += t[n].toString();
          }
        }

        return e += "]";
      }

      throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
    };

    var C = function C(t) {
      return (t = t || "").toString(), t = "(" + S(t) + ")";
    },
        B = function B() {
      var e;
      Object.defineProperty(this, "objId", {
        configurable: !0,
        get: function get() {
          if (e || (e = A.internal.newObjectDeferred()), !e) throw new Error("AcroFormPDFObject: Couldn't create Object ID");
          return e;
        },
        set: function set(t) {
          e = t;
        }
      });
    };

    B.prototype.toString = function () {
      return this.objId + " 0 R";
    }, B.prototype.putStream = function () {
      var t = this.getKeyValueListForStream();
      A.internal.putStream({
        data: this.stream,
        additionalKeyValues: t
      }), A.internal.out("endobj");
    }, B.prototype.getKeyValueListForStream = function () {
      return function (t) {
        var e = [],
            n = Object.getOwnPropertyNames(t).filter(function (t) {
          return "content" != t && "appearanceStreamContent" != t && "_" != t.substring(0, 1);
        });

        for (var r in n) {
          if (!1 === Object.getOwnPropertyDescriptor(t, n[r]).configurable) {
            var i = n[r],
                o = t[i];
            o && (Array.isArray(o) ? e.push({
              key: i,
              value: I(o)
            }) : o instanceof B ? e.push({
              key: i,
              value: o.objId + " 0 R"
            }) : "function" != typeof o && e.push({
              key: i,
              value: o
            }));
          }
        }

        return e;
      }(this);
    };

    var j = function j() {
      B.call(this), Object.defineProperty(this, "Type", {
        value: "/XObject",
        configurable: !1,
        writeable: !0
      }), Object.defineProperty(this, "Subtype", {
        value: "/Form",
        configurable: !1,
        writeable: !0
      }), Object.defineProperty(this, "FormType", {
        value: 1,
        configurable: !1,
        writeable: !0
      });
      var e,
          n = [];
      Object.defineProperty(this, "BBox", {
        configurable: !1,
        writeable: !0,
        get: function get() {
          return n;
        },
        set: function set(t) {
          n = t;
        }
      }), Object.defineProperty(this, "Resources", {
        value: "2 0 R",
        configurable: !1,
        writeable: !0
      }), Object.defineProperty(this, "stream", {
        enumerable: !1,
        configurable: !0,
        set: function set(t) {
          e = t.trim();
        },
        get: function get() {
          return e || null;
        }
      });
    };

    r(j, B);

    var E = function E() {
      B.call(this);
      var e,
          t = [];
      Object.defineProperty(this, "Kids", {
        enumerable: !1,
        configurable: !0,
        get: function get() {
          return 0 < t.length ? t : void 0;
        }
      }), Object.defineProperty(this, "Fields", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          return t;
        }
      }), Object.defineProperty(this, "DA", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          if (e) return "(" + e + ")";
        },
        set: function set(t) {
          e = t;
        }
      });
    };

    r(E, B);

    var M = function t() {
      B.call(this);
      var e = 4;
      Object.defineProperty(this, "F", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          return e;
        },
        set: function set(t) {
          if (isNaN(t)) throw new Error('Invalid value "' + t + '" for attribute F supplied.');
          e = t;
        }
      }), Object.defineProperty(this, "showWhenPrinted", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(e, 3));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.F = x(e, 3) : this.F = N(e, 3);
        }
      });
      var n = 0;
      Object.defineProperty(this, "Ff", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          return n;
        },
        set: function set(t) {
          if (isNaN(t)) throw new Error('Invalid value "' + t + '" for attribute Ff supplied.');
          n = t;
        }
      });
      var r = [];
      Object.defineProperty(this, "Rect", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          if (0 !== r.length) return r;
        },
        set: function set(t) {
          r = void 0 !== t ? t : [];
        }
      }), Object.defineProperty(this, "x", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return !r || isNaN(r[0]) ? 0 : w(r[0]);
        },
        set: function set(t) {
          r[0] = v(t);
        }
      }), Object.defineProperty(this, "y", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return !r || isNaN(r[1]) ? 0 : w(r[1]);
        },
        set: function set(t) {
          r[1] = v(t);
        }
      }), Object.defineProperty(this, "width", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return !r || isNaN(r[2]) ? 0 : w(r[2]);
        },
        set: function set(t) {
          r[2] = v(t);
        }
      }), Object.defineProperty(this, "height", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return !r || isNaN(r[3]) ? 0 : w(r[3]);
        },
        set: function set(t) {
          r[3] = v(t);
        }
      });
      var i = "";
      Object.defineProperty(this, "FT", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          return i;
        },
        set: function set(t) {
          switch (t) {
            case "/Btn":
            case "/Tx":
            case "/Ch":
            case "/Sig":
              i = t;
              break;

            default:
              throw new Error('Invalid value "' + t + '" for attribute FT supplied.');
          }
        }
      });
      var o = null;
      Object.defineProperty(this, "T", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          if (!o || o.length < 1) {
            if (this instanceof H) return;
            o = "FieldObject" + t.FieldNum++;
          }

          return "(" + S(o) + ")";
        },
        set: function set(t) {
          o = t.toString();
        }
      }), Object.defineProperty(this, "fieldName", {
        configurable: !0,
        enumerable: !0,
        get: function get() {
          return o;
        },
        set: function set(t) {
          o = t;
        }
      });
      var a = "helvetica";
      Object.defineProperty(this, "fontName", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return a;
        },
        set: function set(t) {
          a = t;
        }
      });
      var s = "normal";
      Object.defineProperty(this, "fontStyle", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return s;
        },
        set: function set(t) {
          s = t;
        }
      });
      var l = 0;
      Object.defineProperty(this, "fontSize", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return w(l);
        },
        set: function set(t) {
          l = v(t);
        }
      });
      var h = 50;
      Object.defineProperty(this, "maxFontSize", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return w(h);
        },
        set: function set(t) {
          h = v(t);
        }
      });
      var u = "black";
      Object.defineProperty(this, "color", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return u;
        },
        set: function set(t) {
          u = t;
        }
      });
      var c = "/F1 0 Tf 0 g";
      Object.defineProperty(this, "DA", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          if (!(!c || this instanceof H || this instanceof V)) return C(c);
        },
        set: function set(t) {
          t = t.toString(), c = t;
        }
      });
      var f = null;
      Object.defineProperty(this, "DV", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          if (f) return this instanceof D == !1 ? C(f) : f;
        },
        set: function set(t) {
          t = t.toString(), f = this instanceof D == !1 ? "(" === t.substr(0, 1) ? y(t.substr(1, t.length - 2)) : y(t) : t;
        }
      }), Object.defineProperty(this, "defaultValue", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return this instanceof D == !0 ? y(f.substr(1, f.length - 1)) : f;
        },
        set: function set(t) {
          t = t.toString(), f = this instanceof D == !0 ? "/" + t : t;
        }
      });
      var p = null;
      Object.defineProperty(this, "V", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          if (p) return this instanceof D == !1 ? C(p) : p;
        },
        set: function set(t) {
          t = t.toString(), p = this instanceof D == !1 ? "(" === t.substr(0, 1) ? y(t.substr(1, t.length - 2)) : y(t) : t;
        }
      }), Object.defineProperty(this, "value", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return this instanceof D == !0 ? y(p.substr(1, p.length - 1)) : p;
        },
        set: function set(t) {
          t = t.toString(), p = this instanceof D == !0 ? "/" + t : t;
        }
      }), Object.defineProperty(this, "hasAnnotation", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return this.Rect;
        }
      }), Object.defineProperty(this, "Type", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          return this.hasAnnotation ? "/Annot" : null;
        }
      }), Object.defineProperty(this, "Subtype", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          return this.hasAnnotation ? "/Widget" : null;
        }
      });
      var d,
          g = !1;
      Object.defineProperty(this, "hasAppearanceStream", {
        enumerable: !0,
        configurable: !0,
        writeable: !0,
        get: function get() {
          return g;
        },
        set: function set(t) {
          t = Boolean(t), g = t;
        }
      }), Object.defineProperty(this, "page", {
        enumerable: !0,
        configurable: !0,
        writeable: !0,
        get: function get() {
          if (d) return d;
        },
        set: function set(t) {
          d = t;
        }
      }), Object.defineProperty(this, "readOnly", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 1));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 1) : this.Ff = N(this.Ff, 1);
        }
      }), Object.defineProperty(this, "required", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 2));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 2) : this.Ff = N(this.Ff, 2);
        }
      }), Object.defineProperty(this, "noExport", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 3));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 3) : this.Ff = N(this.Ff, 3);
        }
      });
      var m = null;
      Object.defineProperty(this, "Q", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          if (null !== m) return m;
        },
        set: function set(t) {
          if (-1 === [0, 1, 2].indexOf(t)) throw new Error('Invalid value "' + t + '" for attribute Q supplied.');
          m = t;
        }
      }), Object.defineProperty(this, "textAlign", {
        get: function get() {
          var t = "left";

          switch (m) {
            case 0:
            default:
              t = "left";
              break;

            case 1:
              t = "center";
              break;

            case 2:
              t = "right";
          }

          return t;
        },
        configurable: !0,
        enumerable: !0,
        set: function set(t) {
          switch (t) {
            case "right":
            case 2:
              m = 2;
              break;

            case "center":
            case 1:
              m = 1;
              break;

            case "left":
            case 0:
            default:
              m = 0;
          }
        }
      });
    };

    r(M, B);

    var O = function O() {
      M.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
      var e = 0;
      Object.defineProperty(this, "TI", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          return e;
        },
        set: function set(t) {
          e = t;
        }
      }), Object.defineProperty(this, "topIndex", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return e;
        },
        set: function set(t) {
          e = t;
        }
      });
      var r = [];
      Object.defineProperty(this, "Opt", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          return I(r);
        },
        set: function set(t) {
          var e, n;
          n = [], "string" == typeof (e = t) && (n = function (t, e, n) {
            n || (n = 1);

            for (var r, i = []; r = e.exec(t);) {
              i.push(r[n]);
            }

            return i;
          }(e, /\((.*?)\)/g)), r = n;
        }
      }), this.getOptions = function () {
        return r;
      }, this.setOptions = function (t) {
        r = t, this.sort && r.sort();
      }, this.addOption = function (t) {
        t = (t = t || "").toString(), r.push(t), this.sort && r.sort();
      }, this.removeOption = function (t, e) {
        for (e = e || !1, t = (t = t || "").toString(); -1 !== r.indexOf(t) && (r.splice(r.indexOf(t), 1), !1 !== e);) {
          ;
        }
      }, Object.defineProperty(this, "combo", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 18));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 18) : this.Ff = N(this.Ff, 18);
        }
      }), Object.defineProperty(this, "edit", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 19));
        },
        set: function set(t) {
          !0 === this.combo && (!0 === Boolean(t) ? this.Ff = x(this.Ff, 19) : this.Ff = N(this.Ff, 19));
        }
      }), Object.defineProperty(this, "sort", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 20));
        },
        set: function set(t) {
          !0 === Boolean(t) ? (this.Ff = x(this.Ff, 20), r.sort()) : this.Ff = N(this.Ff, 20);
        }
      }), Object.defineProperty(this, "multiSelect", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 22));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 22) : this.Ff = N(this.Ff, 22);
        }
      }), Object.defineProperty(this, "doNotSpellCheck", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 23));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 23) : this.Ff = N(this.Ff, 23);
        }
      }), Object.defineProperty(this, "commitOnSelChange", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 27));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 27) : this.Ff = N(this.Ff, 27);
        }
      }), this.hasAppearanceStream = !1;
    };

    r(O, M);

    var q = function q() {
      O.call(this), this.fontName = "helvetica", this.combo = !1;
    };

    r(q, O);

    var T = function T() {
      q.call(this), this.combo = !0;
    };

    r(T, q);

    var R = function R() {
      T.call(this), this.edit = !0;
    };

    r(R, T);

    var D = function D() {
      M.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 15));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 15) : this.Ff = N(this.Ff, 15);
        }
      }), Object.defineProperty(this, "radio", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 16));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 16) : this.Ff = N(this.Ff, 16);
        }
      }), Object.defineProperty(this, "pushButton", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 17));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 17) : this.Ff = N(this.Ff, 17);
        }
      }), Object.defineProperty(this, "radioIsUnison", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 26));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 26) : this.Ff = N(this.Ff, 26);
        }
      });
      var e,
          n = {};
      Object.defineProperty(this, "MK", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          if (0 !== Object.keys(n).length) {
            var t,
                e = [];

            for (t in e.push("<<"), n) {
              e.push("/" + t + " (" + n[t] + ")");
            }

            return e.push(">>"), e.join("\n");
          }
        },
        set: function set(t) {
          "object" === se(t) && (n = t);
        }
      }), Object.defineProperty(this, "caption", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return n.CA || "";
        },
        set: function set(t) {
          "string" == typeof t && (n.CA = t);
        }
      }), Object.defineProperty(this, "AS", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          return e;
        },
        set: function set(t) {
          e = t;
        }
      }), Object.defineProperty(this, "appearanceState", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return e.substr(1, e.length - 1);
        },
        set: function set(t) {
          e = "/" + t;
        }
      });
    };

    r(D, M);

    var U = function U() {
      D.call(this), this.pushButton = !0;
    };

    r(U, D);

    var z = function z() {
      D.call(this), this.radio = !0, this.pushButton = !1;
      var e = [];
      Object.defineProperty(this, "Kids", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          return e;
        },
        set: function set(t) {
          e = void 0 !== t ? t : [];
        }
      });
    };

    r(z, D);

    var H = function H() {
      var e, n;
      M.call(this), Object.defineProperty(this, "Parent", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          return e;
        },
        set: function set(t) {
          e = t;
        }
      }), Object.defineProperty(this, "optionName", {
        enumerable: !1,
        configurable: !0,
        get: function get() {
          return n;
        },
        set: function set(t) {
          n = t;
        }
      });
      var r,
          i = {};
      Object.defineProperty(this, "MK", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          var t,
              e = [];

          for (t in e.push("<<"), i) {
            e.push("/" + t + " (" + i[t] + ")");
          }

          return e.push(">>"), e.join("\n");
        },
        set: function set(t) {
          "object" === se(t) && (i = t);
        }
      }), Object.defineProperty(this, "caption", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return i.CA || "";
        },
        set: function set(t) {
          "string" == typeof t && (i.CA = t);
        }
      }), Object.defineProperty(this, "AS", {
        enumerable: !1,
        configurable: !1,
        get: function get() {
          return r;
        },
        set: function set(t) {
          r = t;
        }
      }), Object.defineProperty(this, "appearanceState", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return r.substr(1, r.length - 1);
        },
        set: function set(t) {
          r = "/" + t;
        }
      }), this.optionName = name, this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Y.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(name);
    };

    r(H, M), z.prototype.setAppearance = function (t) {
      if (!("createAppearanceStream" in t && "getCA" in t)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");

      for (var e in this.Kids) {
        if (this.Kids.hasOwnProperty(e)) {
          var n = this.Kids[e];
          n.appearanceStreamContent = t.createAppearanceStream(n.optionName), n.caption = t.getCA();
        }
      }
    }, z.prototype.createOption = function (t) {
      this.Kids.length;
      var e = new H();
      return e.Parent = this, e.optionName = t, this.Kids.push(e), J.call(this, e), e;
    };

    var W = function W() {
      D.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Y.CheckBox.createAppearanceStream();
    };

    r(W, D);

    var V = function V() {
      M.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 13));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 13) : this.Ff = N(this.Ff, 13);
        }
      }), Object.defineProperty(this, "fileSelect", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 21));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 21) : this.Ff = N(this.Ff, 21);
        }
      }), Object.defineProperty(this, "doNotSpellCheck", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 23));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 23) : this.Ff = N(this.Ff, 23);
        }
      }), Object.defineProperty(this, "doNotScroll", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 24));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 24) : this.Ff = N(this.Ff, 24);
        }
      }), Object.defineProperty(this, "comb", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 25));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 25) : this.Ff = N(this.Ff, 25);
        }
      }), Object.defineProperty(this, "richText", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 26));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 26) : this.Ff = N(this.Ff, 26);
        }
      });
      var e = null;
      Object.defineProperty(this, "MaxLen", {
        enumerable: !0,
        configurable: !1,
        get: function get() {
          return e;
        },
        set: function set(t) {
          e = t;
        }
      }), Object.defineProperty(this, "maxLength", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return e;
        },
        set: function set(t) {
          Number.isInteger(t) && (e = t);
        }
      }), Object.defineProperty(this, "hasAppearanceStream", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return this.V || this.DV;
        }
      });
    };

    r(V, M);

    var G = function G() {
      V.call(this), Object.defineProperty(this, "password", {
        enumerable: !0,
        configurable: !0,
        get: function get() {
          return Boolean(b(this.Ff, 14));
        },
        set: function set(t) {
          !0 === Boolean(t) ? this.Ff = x(this.Ff, 14) : this.Ff = N(this.Ff, 14);
        }
      }), this.password = !0;
    };

    r(G, V);
    var Y = {
      CheckBox: {
        createAppearanceStream: function createAppearanceStream() {
          return {
            N: {
              On: Y.CheckBox.YesNormal
            },
            D: {
              On: Y.CheckBox.YesPushDown,
              Off: Y.CheckBox.OffPushDown
            }
          };
        },
        YesPushDown: function YesPushDown(t) {
          var e = l(t),
              n = [],
              r = A.internal.getFont(t.fontName, t.fontStyle).id,
              i = A.__private__.encodeColorString(t.color),
              o = h(t, t.caption);

          return n.push("0.749023 g"), n.push("0 0 " + _(Y.internal.getWidth(t)) + " " + _(Y.internal.getHeight(t)) + " re"), n.push("f"), n.push("BMC"), n.push("q"), n.push("0 0 1 rg"), n.push("/" + r + " " + _(o.fontSize) + " Tf " + i), n.push("BT"), n.push(o.text), n.push("ET"), n.push("Q"), n.push("EMC"), e.stream = n.join("\n"), e;
        },
        YesNormal: function YesNormal(t) {
          var e = l(t),
              n = A.internal.getFont(t.fontName, t.fontStyle).id,
              r = A.__private__.encodeColorString(t.color),
              i = [],
              o = Y.internal.getHeight(t),
              a = Y.internal.getWidth(t),
              s = h(t, t.caption);

          return i.push("1 g"), i.push("0 0 " + _(a) + " " + _(o) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + _(a - 1) + " " + _(o - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + n + " " + _(s.fontSize) + " Tf " + r), i.push(s.text), i.push("ET"), i.push("Q"), e.stream = i.join("\n"), e;
        },
        OffPushDown: function OffPushDown(t) {
          var e = l(t),
              n = [];
          return n.push("0.749023 g"), n.push("0 0 " + _(Y.internal.getWidth(t)) + " " + _(Y.internal.getHeight(t)) + " re"), n.push("f"), e.stream = n.join("\n"), e;
        }
      },
      RadioButton: {
        Circle: {
          createAppearanceStream: function createAppearanceStream(t) {
            var e = {
              D: {
                Off: Y.RadioButton.Circle.OffPushDown
              },
              N: {}
            };
            return e.N[t] = Y.RadioButton.Circle.YesNormal, e.D[t] = Y.RadioButton.Circle.YesPushDown, e;
          },
          getCA: function getCA() {
            return "l";
          },
          YesNormal: function YesNormal(t) {
            var e = l(t),
                n = [],
                r = Y.internal.getWidth(t) <= Y.internal.getHeight(t) ? Y.internal.getWidth(t) / 4 : Y.internal.getHeight(t) / 4;
            r = Number((.9 * r).toFixed(5));
            var i = Y.internal.Bezier_C,
                o = Number((r * i).toFixed(5));
            return n.push("q"), n.push("1 0 0 1 " + s(Y.internal.getWidth(t) / 2) + " " + s(Y.internal.getHeight(t) / 2) + " cm"), n.push(r + " 0 m"), n.push(r + " " + o + " " + o + " " + r + " 0 " + r + " c"), n.push("-" + o + " " + r + " -" + r + " " + o + " -" + r + " 0 c"), n.push("-" + r + " -" + o + " -" + o + " -" + r + " 0 -" + r + " c"), n.push(o + " -" + r + " " + r + " -" + o + " " + r + " 0 c"), n.push("f"), n.push("Q"), e.stream = n.join("\n"), e;
          },
          YesPushDown: function YesPushDown(t) {
            var e = l(t),
                n = [],
                r = Y.internal.getWidth(t) <= Y.internal.getHeight(t) ? Y.internal.getWidth(t) / 4 : Y.internal.getHeight(t) / 4,
                i = (r = Number((.9 * r).toFixed(5)), Number((2 * r).toFixed(5))),
                o = Number((i * Y.internal.Bezier_C).toFixed(5)),
                a = Number((r * Y.internal.Bezier_C).toFixed(5));
            return n.push("0.749023 g"), n.push("q"), n.push("1 0 0 1 " + s(Y.internal.getWidth(t) / 2) + " " + s(Y.internal.getHeight(t) / 2) + " cm"), n.push(i + " 0 m"), n.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), n.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), n.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), n.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), n.push("f"), n.push("Q"), n.push("0 g"), n.push("q"), n.push("1 0 0 1 " + s(Y.internal.getWidth(t) / 2) + " " + s(Y.internal.getHeight(t) / 2) + " cm"), n.push(r + " 0 m"), n.push(r + " " + a + " " + a + " " + r + " 0 " + r + " c"), n.push("-" + a + " " + r + " -" + r + " " + a + " -" + r + " 0 c"), n.push("-" + r + " -" + a + " -" + a + " -" + r + " 0 -" + r + " c"), n.push(a + " -" + r + " " + r + " -" + a + " " + r + " 0 c"), n.push("f"), n.push("Q"), e.stream = n.join("\n"), e;
          },
          OffPushDown: function OffPushDown(t) {
            var e = l(t),
                n = [],
                r = Y.internal.getWidth(t) <= Y.internal.getHeight(t) ? Y.internal.getWidth(t) / 4 : Y.internal.getHeight(t) / 4,
                i = (r = Number((.9 * r).toFixed(5)), Number((2 * r).toFixed(5))),
                o = Number((i * Y.internal.Bezier_C).toFixed(5));
            return n.push("0.749023 g"), n.push("q"), n.push("1 0 0 1 " + s(Y.internal.getWidth(t) / 2) + " " + s(Y.internal.getHeight(t) / 2) + " cm"), n.push(i + " 0 m"), n.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), n.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), n.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), n.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), n.push("f"), n.push("Q"), e.stream = n.join("\n"), e;
          }
        },
        Cross: {
          createAppearanceStream: function createAppearanceStream(t) {
            var e = {
              D: {
                Off: Y.RadioButton.Cross.OffPushDown
              },
              N: {}
            };
            return e.N[t] = Y.RadioButton.Cross.YesNormal, e.D[t] = Y.RadioButton.Cross.YesPushDown, e;
          },
          getCA: function getCA() {
            return "8";
          },
          YesNormal: function YesNormal(t) {
            var e = l(t),
                n = [],
                r = Y.internal.calculateCross(t);
            return n.push("q"), n.push("1 1 " + _(Y.internal.getWidth(t) - 2) + " " + _(Y.internal.getHeight(t) - 2) + " re"), n.push("W"), n.push("n"), n.push(_(r.x1.x) + " " + _(r.x1.y) + " m"), n.push(_(r.x2.x) + " " + _(r.x2.y) + " l"), n.push(_(r.x4.x) + " " + _(r.x4.y) + " m"), n.push(_(r.x3.x) + " " + _(r.x3.y) + " l"), n.push("s"), n.push("Q"), e.stream = n.join("\n"), e;
          },
          YesPushDown: function YesPushDown(t) {
            var e = l(t),
                n = Y.internal.calculateCross(t),
                r = [];
            return r.push("0.749023 g"), r.push("0 0 " + _(Y.internal.getWidth(t)) + " " + _(Y.internal.getHeight(t)) + " re"), r.push("f"), r.push("q"), r.push("1 1 " + _(Y.internal.getWidth(t) - 2) + " " + _(Y.internal.getHeight(t) - 2) + " re"), r.push("W"), r.push("n"), r.push(_(n.x1.x) + " " + _(n.x1.y) + " m"), r.push(_(n.x2.x) + " " + _(n.x2.y) + " l"), r.push(_(n.x4.x) + " " + _(n.x4.y) + " m"), r.push(_(n.x3.x) + " " + _(n.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join("\n"), e;
          },
          OffPushDown: function OffPushDown(t) {
            var e = l(t),
                n = [];
            return n.push("0.749023 g"), n.push("0 0 " + _(Y.internal.getWidth(t)) + " " + _(Y.internal.getHeight(t)) + " re"), n.push("f"), e.stream = n.join("\n"), e;
          }
        }
      },
      createDefaultAppearanceStream: function createDefaultAppearanceStream(t) {
        var e = A.internal.getFont(t.fontName, t.fontStyle).id,
            n = A.__private__.encodeColorString(t.color);

        return "/" + e + " " + t.fontSize + " Tf " + n;
      }
    };
    Y.internal = {
      Bezier_C: .551915024494,
      calculateCross: function calculateCross(t) {
        var e = Y.internal.getWidth(t),
            n = Y.internal.getHeight(t),
            r = Math.min(e, n);
        return {
          x1: {
            x: (e - r) / 2,
            y: (n - r) / 2 + r
          },
          x2: {
            x: (e - r) / 2 + r,
            y: (n - r) / 2
          },
          x3: {
            x: (e - r) / 2,
            y: (n - r) / 2
          },
          x4: {
            x: (e - r) / 2 + r,
            y: (n - r) / 2 + r
          }
        };
      }
    }, Y.internal.getWidth = function (t) {
      var e = 0;
      return "object" === se(t) && (e = v(t.Rect[2])), e;
    }, Y.internal.getHeight = function (t) {
      var e = 0;
      return "object" === se(t) && (e = v(t.Rect[3])), e;
    };

    var J = t.addField = function (t) {
      if (k.call(this), !(t instanceof M)) throw new Error("Invalid argument passed to jsPDF.addField.");
      return function (t) {
        A.internal.acroformPlugin.printedOut && (A.internal.acroformPlugin.printedOut = !1, A.internal.acroformPlugin.acroFormDictionaryRoot = null), A.internal.acroformPlugin.acroFormDictionaryRoot || k.call(A), A.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t);
      }.call(this, t), t.page = A.internal.getCurrentPageInfo().pageNumber, this;
    };

    t.addButton = function (t) {
      if (t instanceof D == !1) throw new Error("Invalid argument passed to jsPDF.addButton.");
      return J.call(this, t);
    }, t.addTextField = function (t) {
      if (t instanceof V == !1) throw new Error("Invalid argument passed to jsPDF.addTextField.");
      return J.call(this, t);
    }, t.addChoiceField = function (t) {
      if (t instanceof O == !1) throw new Error("Invalid argument passed to jsPDF.addChoiceField.");
      return J.call(this, t);
    };
    "object" == se(e) && void 0 === e.ChoiceField && void 0 === e.ListBox && void 0 === e.ComboBox && void 0 === e.EditBox && void 0 === e.Button && void 0 === e.PushButton && void 0 === e.RadioButton && void 0 === e.CheckBox && void 0 === e.TextField && void 0 === e.PasswordField ? (e.ChoiceField = O, e.ListBox = q, e.ComboBox = T, e.EditBox = R, e.Button = D, e.PushButton = U, e.RadioButton = z, e.CheckBox = W, e.TextField = V, e.PasswordField = G, e.AcroForm = {
      Appearance: Y
    }) : console.warn("AcroForm-Classes are not populated into global-namespace, because the class-Names exist already."), t.AcroFormChoiceField = O, t.AcroFormListBox = q, t.AcroFormComboBox = T, t.AcroFormEditBox = R, t.AcroFormButton = D, t.AcroFormPushButton = U, t.AcroFormRadioButton = z, t.AcroFormCheckBox = W, t.AcroFormTextField = V, t.AcroFormPasswordField = G, t.AcroFormAppearance = Y, t.AcroForm = {
      ChoiceField: O,
      ListBox: q,
      ComboBox: T,
      EditBox: R,
      Button: D,
      PushButton: U,
      RadioButton: z,
      CheckBox: W,
      TextField: V,
      PasswordField: G,
      Appearance: Y
    };
  })((window.tmp = lt).API, "undefined" != typeof window && window || "undefined" != typeof global && global),
  /** @license
     * jsPDF addImage plugin
     * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/
     *               2013 Chris Dowling, https://github.com/gingerchris
     *               2013 Trinh Ho, https://github.com/ineedfat
     *               2013 Edwin Alejandro Perez, https://github.com/eaparango
     *               2013 Norah Smith, https://github.com/burnburnrocket
     *               2014 Diego Casorran, https://github.com/diegocr
     *               2014 James Robb, https://github.com/jamesbrobb
     *
     * 
     */
  function (x) {
    var N = "addImage_",
        l = {
      PNG: [[137, 80, 78, 71]],
      TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]],
      JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0]],
      JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]],
      GIF87a: [[71, 73, 70, 56, 55, 97]],
      GIF89a: [[71, 73, 70, 56, 57, 97]],
      BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]]
    },
        h = x.getImageFileTypeByImageData = function (t, e) {
      var n, r;
      e = e || "UNKNOWN";
      var i,
          o,
          a,
          s = "UNKNOWN";

      for (a in x.isArrayBufferView(t) && (t = x.arrayBufferToBinaryString(t)), l) {
        for (i = l[a], n = 0; n < i.length; n += 1) {
          for (o = !0, r = 0; r < i[n].length; r += 1) {
            if (void 0 !== i[n][r] && i[n][r] !== t.charCodeAt(r)) {
              o = !1;
              break;
            }
          }

          if (!0 === o) {
            s = a;
            break;
          }
        }
      }

      return "UNKNOWN" === s && "UNKNOWN" !== e && (console.warn('FileType of Image not recognized. Processing image as "' + e + '".'), s = e), s;
    },
        n = function t(e) {
      for (var n = this.internal.newObject(), r = this.internal.write, i = this.internal.putStream, o = (0, this.internal.getFilters)(); -1 !== o.indexOf("FlateEncode");) {
        o.splice(o.indexOf("FlateEncode"), 1);
      }

      e.n = n;
      var a = [];

      if (a.push({
        key: "Type",
        value: "/XObject"
      }), a.push({
        key: "Subtype",
        value: "/Image"
      }), a.push({
        key: "Width",
        value: e.w
      }), a.push({
        key: "Height",
        value: e.h
      }), e.cs === this.color_spaces.INDEXED ? a.push({
        key: "ColorSpace",
        value: "[/Indexed /DeviceRGB " + (e.pal.length / 3 - 1) + " " + ("smask" in e ? n + 2 : n + 1) + " 0 R]"
      }) : (a.push({
        key: "ColorSpace",
        value: "/" + e.cs
      }), e.cs === this.color_spaces.DEVICE_CMYK && a.push({
        key: "Decode",
        value: "[1 0 1 0 1 0 1 0]"
      })), a.push({
        key: "BitsPerComponent",
        value: e.bpc
      }), "dp" in e && a.push({
        key: "DecodeParms",
        value: "<<" + e.dp + ">>"
      }), "trns" in e && e.trns.constructor == Array) {
        for (var s = "", l = 0, h = e.trns.length; l < h; l++) {
          s += e.trns[l] + " " + e.trns[l] + " ";
        }

        a.push({
          key: "Mask",
          value: "[" + s + "]"
        });
      }

      "smask" in e && a.push({
        key: "SMask",
        value: n + 1 + " 0 R"
      });
      var u = void 0 !== e.f ? ["/" + e.f] : void 0;

      if (i({
        data: e.data,
        additionalKeyValues: a,
        alreadyAppliedFilters: u
      }), r("endobj"), "smask" in e) {
        var c = "/Predictor " + e.p + " /Colors 1 /BitsPerComponent " + e.bpc + " /Columns " + e.w,
            f = {
          w: e.w,
          h: e.h,
          cs: "DeviceGray",
          bpc: e.bpc,
          dp: c,
          data: e.smask
        };
        "f" in e && (f.f = e.f), t.call(this, f);
      }

      e.cs === this.color_spaces.INDEXED && (this.internal.newObject(), i({
        data: this.arrayBufferToBinaryString(new Uint8Array(e.pal))
      }), r("endobj"));
    },
        L = function L() {
      var t = this.internal.collections[N + "images"];

      for (var e in t) {
        n.call(this, t[e]);
      }
    },
        A = function A() {
      var t,
          e = this.internal.collections[N + "images"],
          n = this.internal.write;

      for (var r in e) {
        n("/I" + (t = e[r]).i, t.n, "0", "R");
      }
    },
        S = function S(t) {
      return "function" == typeof x["process" + t.toUpperCase()];
    },
        _ = function _(t) {
      return "object" === se(t) && 1 === t.nodeType;
    },
        F = function F(t, e) {
      if ("IMG" === t.nodeName && t.hasAttribute("src")) {
        var n = "" + t.getAttribute("src");
        if (0 === n.indexOf("data:image/")) return unescape(n);
        var r = x.loadFile(n);
        if (void 0 !== r) return btoa(r);
      }

      if ("CANVAS" === t.nodeName) {
        var i = t;
        return t.toDataURL("image/jpeg", 1);
      }

      (i = document.createElement("canvas")).width = t.clientWidth || t.width, i.height = t.clientHeight || t.height;
      var o = i.getContext("2d");
      if (!o) throw "addImage requires canvas to be supported by browser.";
      return o.drawImage(t, 0, 0, i.width, i.height), i.toDataURL("png" == ("" + e).toLowerCase() ? "image/png" : "image/jpeg");
    },
        P = function P(t, e) {
      var n;
      if (e) for (var r in e) {
        if (t === e[r].alias) {
          n = e[r];
          break;
        }
      }
      return n;
    };

    x.color_spaces = {
      DEVICE_RGB: "DeviceRGB",
      DEVICE_GRAY: "DeviceGray",
      DEVICE_CMYK: "DeviceCMYK",
      CAL_GREY: "CalGray",
      CAL_RGB: "CalRGB",
      LAB: "Lab",
      ICC_BASED: "ICCBased",
      INDEXED: "Indexed",
      PATTERN: "Pattern",
      SEPARATION: "Separation",
      DEVICE_N: "DeviceN"
    }, x.decode = {
      DCT_DECODE: "DCTDecode",
      FLATE_DECODE: "FlateDecode",
      LZW_DECODE: "LZWDecode",
      JPX_DECODE: "JPXDecode",
      JBIG2_DECODE: "JBIG2Decode",
      ASCII85_DECODE: "ASCII85Decode",
      ASCII_HEX_DECODE: "ASCIIHexDecode",
      RUN_LENGTH_DECODE: "RunLengthDecode",
      CCITT_FAX_DECODE: "CCITTFaxDecode"
    }, x.image_compression = {
      NONE: "NONE",
      FAST: "FAST",
      MEDIUM: "MEDIUM",
      SLOW: "SLOW"
    }, x.sHashCode = function (t) {
      var e,
          n = 0;
      if (0 === (t = t || "").length) return n;

      for (e = 0; e < t.length; e++) {
        n = (n << 5) - n + t.charCodeAt(e), n |= 0;
      }

      return n;
    }, x.isString = function (t) {
      return "string" == typeof t;
    }, x.validateStringAsBase64 = function (t) {
      (t = t || "").toString().trim();
      var e = !0;
      return 0 === t.length && (e = !1), t.length % 4 != 0 && (e = !1), !1 === /^[A-Za-z0-9+\/]+$/.test(t.substr(0, t.length - 2)) && (e = !1), !1 === /^[A-Za-z0-9\/][A-Za-z0-9+\/]|[A-Za-z0-9+\/]=|==$/.test(t.substr(-2)) && (e = !1), e;
    }, x.extractInfoFromBase64DataURI = function (t) {
      return /^data:([\w]+?\/([\w]+?));\S*;*base64,(.+)$/g.exec(t);
    }, x.extractImageFromDataUrl = function (t) {
      var e = (t = t || "").split("base64,"),
          n = null;

      if (2 === e.length) {
        var r = /^data:(\w*\/\w*);*(charset=[\w=-]*)*;*$/.exec(e[0]);
        Array.isArray(r) && (n = {
          mimeType: r[1],
          charset: r[2],
          data: e[1]
        });
      }

      return n;
    }, x.supportsArrayBuffer = function () {
      return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
    }, x.isArrayBuffer = function (t) {
      return !!this.supportsArrayBuffer() && t instanceof ArrayBuffer;
    }, x.isArrayBufferView = function (t) {
      return !!this.supportsArrayBuffer() && "undefined" != typeof Uint32Array && (t instanceof Int8Array || t instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array);
    }, x.binaryStringToUint8Array = function (t) {
      for (var e = t.length, n = new Uint8Array(e), r = 0; r < e; r++) {
        n[r] = t.charCodeAt(r);
      }

      return n;
    }, x.arrayBufferToBinaryString = function (t) {
      if ("function" == typeof atob) return atob(this.arrayBufferToBase64(t));
    }, x.arrayBufferToBase64 = function (t) {
      for (var e, n = "", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = new Uint8Array(t), o = i.byteLength, a = o % 3, s = o - a, l = 0; l < s; l += 3) {
        n += r[(16515072 & (e = i[l] << 16 | i[l + 1] << 8 | i[l + 2])) >> 18] + r[(258048 & e) >> 12] + r[(4032 & e) >> 6] + r[63 & e];
      }

      return 1 == a ? n += r[(252 & (e = i[s])) >> 2] + r[(3 & e) << 4] + "==" : 2 == a && (n += r[(64512 & (e = i[s] << 8 | i[s + 1])) >> 10] + r[(1008 & e) >> 4] + r[(15 & e) << 2] + "="), n;
    }, x.createImageInfo = function (t, e, n, r, i, o, a, s, l, h, u, c, f) {
      var p = {
        alias: s,
        w: e,
        h: n,
        cs: r,
        bpc: i,
        i: a,
        data: t
      };
      return o && (p.f = o), l && (p.dp = l), h && (p.trns = h), u && (p.pal = u), c && (p.smask = c), f && (p.p = f), p;
    }, x.addImage = function (t, e, n, r, i, o, a, s, l) {
      var h = "";

      if ("string" != typeof e) {
        var u = o;
        o = i, i = r, r = n, n = e, e = u;
      }

      if ("object" === se(t) && !_(t) && "imageData" in t) {
        var c = t;
        t = c.imageData, e = c.format || e || "UNKNOWN", n = c.x || n || 0, r = c.y || r || 0, i = c.w || i, o = c.h || o, a = c.alias || a, s = c.compression || s, l = c.rotation || c.angle || l;
      }

      var f = this.internal.getFilters();
      if (void 0 === s && -1 !== f.indexOf("FlateEncode") && (s = "SLOW"), "string" == typeof t && (t = unescape(t)), isNaN(n) || isNaN(r)) throw console.error("jsPDF.addImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addImage");

      var p,
          d,
          g,
          m,
          y,
          v,
          w,
          b = function () {
        var t = this.internal.collections[N + "images"];
        return t || (this.internal.collections[N + "images"] = t = {}, this.internal.events.subscribe("putResources", L), this.internal.events.subscribe("putXobjectDict", A)), t;
      }.call(this);

      if (!((p = P(t, b)) || (_(t) && (t = F(t, e)), (null == (w = a) || 0 === w.length) && (a = "string" == typeof (v = t) ? x.sHashCode(v) : x.isArrayBufferView(v) ? x.sHashCode(x.arrayBufferToBinaryString(v)) : null), p = P(a, b)))) {
        if (this.isString(t) && ("" !== (h = this.convertStringToImageData(t)) ? t = h : void 0 !== (h = x.loadFile(t)) && (t = h)), e = this.getImageFileTypeByImageData(t, e), !S(e)) throw new Error("addImage does not support files of type '" + e + "', please ensure that a plugin for '" + e + "' support is added.");
        if (this.supportsArrayBuffer() && (t instanceof Uint8Array || (d = t, t = this.binaryStringToUint8Array(t))), !(p = this["process" + e.toUpperCase()](t, (y = 0, (m = b) && (y = Object.keys ? Object.keys(m).length : function (t) {
          var e = 0;

          for (var n in t) {
            t.hasOwnProperty(n) && e++;
          }

          return e;
        }(m)), y), a, ((g = s) && "string" == typeof g && (g = g.toUpperCase()), g in x.image_compression ? g : x.image_compression.NONE), d))) throw new Error("An unknown error occurred whilst processing the image");
      }

      return function (t, e, n, r, i, o, a, s) {
        var l = function (t, e, n) {
          return t || e || (e = t = -96), t < 0 && (t = -1 * n.w * 72 / t / this.internal.scaleFactor), e < 0 && (e = -1 * n.h * 72 / e / this.internal.scaleFactor), 0 === t && (t = e * n.w / n.h), 0 === e && (e = t * n.h / n.w), [t, e];
        }.call(this, n, r, i),
            h = this.internal.getCoordinateString,
            u = this.internal.getVerticalCoordinateString;

        if (n = l[0], r = l[1], a[o] = i, s) {
          s *= Math.PI / 180;

          var c = Math.cos(s),
              f = Math.sin(s),
              p = function p(t) {
            return t.toFixed(4);
          },
              d = [p(c), p(f), p(-1 * f), p(c), 0, 0, "cm"];
        }

        this.internal.write("q"), s ? (this.internal.write([1, "0", "0", 1, h(t), u(e + r), "cm"].join(" ")), this.internal.write(d.join(" ")), this.internal.write([h(n), "0", "0", h(r), "0", "0", "cm"].join(" "))) : this.internal.write([h(n), "0", "0", h(r), h(t), u(e + r), "cm"].join(" ")), this.internal.write("/I" + i.i + " Do"), this.internal.write("Q");
      }.call(this, n, r, i, o, p, p.i, b, l), this;
    }, x.convertStringToImageData = function (t) {
      var e,
          n = "";

      if (this.isString(t)) {
        var r;
        e = null !== (r = this.extractImageFromDataUrl(t)) ? r.data : t;

        try {
          n = atob(e);
        } catch (t) {
          throw x.validateStringAsBase64(e) ? new Error("atob-Error in jsPDF.convertStringToImageData " + t.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertStringToImageData ");
        }
      }

      return n;
    };

    var u = function u(t, e) {
      return t.subarray(e, e + 5);
    };

    x.processJPEG = function (t, e, n, r, i, o) {
      var a,
          s = this.decode.DCT_DECODE;
      if (!this.isString(t) && !this.isArrayBuffer(t) && !this.isArrayBufferView(t)) return null;
      if (this.isString(t) && (a = function (t) {
        var e;
        if ("JPEG" !== h(t)) throw new Error("getJpegSize requires a binary string jpeg file");

        for (var n = 256 * t.charCodeAt(4) + t.charCodeAt(5), r = 4, i = t.length; r < i;) {
          if (r += n, 255 !== t.charCodeAt(r)) throw new Error("getJpegSize could not find the size of the image");
          if (192 === t.charCodeAt(r + 1) || 193 === t.charCodeAt(r + 1) || 194 === t.charCodeAt(r + 1) || 195 === t.charCodeAt(r + 1) || 196 === t.charCodeAt(r + 1) || 197 === t.charCodeAt(r + 1) || 198 === t.charCodeAt(r + 1) || 199 === t.charCodeAt(r + 1)) return e = 256 * t.charCodeAt(r + 5) + t.charCodeAt(r + 6), [256 * t.charCodeAt(r + 7) + t.charCodeAt(r + 8), e, t.charCodeAt(r + 9)];
          r += 2, n = 256 * t.charCodeAt(r) + t.charCodeAt(r + 1);
        }
      }(t)), this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t) && (a = function (t) {
        if (65496 != (t[0] << 8 | t[1])) throw new Error("Supplied data is not a JPEG");

        for (var e, n = t.length, r = (t[4] << 8) + t[5], i = 4; i < n;) {
          if (r = ((e = u(t, i += r))[2] << 8) + e[3], (192 === e[1] || 194 === e[1]) && 255 === e[0] && 7 < r) return {
            width: ((e = u(t, i + 5))[2] << 8) + e[3],
            height: (e[0] << 8) + e[1],
            numcomponents: e[4]
          };
          i += 2;
        }

        throw new Error("getJpegSizeFromBytes could not find the size of the image");
      }(t), t = i || this.arrayBufferToBinaryString(t)), void 0 === o) switch (a.numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;

        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;

        default:
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      return this.createImageInfo(t, a.width, a.height, o, 8, s, e, n);
    }, x.processJPG = function () {
      return this.processJPEG.apply(this, arguments);
    }, x.getImageProperties = function (t) {
      var e,
          n,
          r = "";
      if (_(t) && (t = F(t)), this.isString(t) && ("" !== (r = this.convertStringToImageData(t)) ? t = r : void 0 !== (r = x.loadFile(t)) && (t = r)), n = this.getImageFileTypeByImageData(t), !S(n)) throw new Error("addImage does not support files of type '" + n + "', please ensure that a plugin for '" + n + "' support is added.");
      if (this.supportsArrayBuffer() && (t instanceof Uint8Array || (t = this.binaryStringToUint8Array(t))), !(e = this["process" + n.toUpperCase()](t))) throw new Error("An unknown error occurred whilst processing the image");
      return {
        fileType: n,
        width: e.w,
        height: e.h,
        colorSpace: e.cs,
        compressionMode: e.f,
        bitsPerComponent: e.bpc
      };
    };
  }(lt.API),
  /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  t = lt.API, lt.API.events.push(["addPage", function (t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), t.events.push(["putPage", function (t) {
    for (var e = this.internal.getPageInfoByObjId(t.objId), n = t.pageContext.annotations, r = function r(t) {
      if (void 0 !== t && "" != t) return !0;
    }, i = !1, o = 0; o < n.length && !i; o++) {
      switch ((l = n[o]).type) {
        case "link":
          if (r(l.options.url) || r(l.options.pageNumber)) {
            i = !0;
            break;
          }

        case "reference":
        case "text":
        case "freetext":
          i = !0;
      }
    }

    if (0 != i) {
      this.internal.write("/Annots ["), this.internal.pageSize.height;
      var a = this.internal.getCoordinateString,
          s = this.internal.getVerticalCoordinateString;

      for (o = 0; o < n.length; o++) {
        var l;

        switch ((l = n[o]).type) {
          case "reference":
            this.internal.write(" " + l.object.objId + " 0 R ");
            break;

          case "text":
            var h = this.internal.newAdditionalObject(),
                u = this.internal.newAdditionalObject(),
                c = l.title || "Note";
            m = "<</Type /Annot /Subtype /Text " + (p = "/Rect [" + a(l.bounds.x) + " " + s(l.bounds.y + l.bounds.h) + " " + a(l.bounds.x + l.bounds.w) + " " + s(l.bounds.y) + "] ") + "/Contents (" + l.contents + ")", m += " /Popup " + u.objId + " 0 R", m += " /P " + e.objId + " 0 R", m += " /T (" + c + ") >>", h.content = m;
            var f = h.objId + " 0 R";
            m = "<</Type /Annot /Subtype /Popup " + (p = "/Rect [" + a(l.bounds.x + 30) + " " + s(l.bounds.y + l.bounds.h) + " " + a(l.bounds.x + l.bounds.w + 30) + " " + s(l.bounds.y) + "] ") + " /Parent " + f, l.open && (m += " /Open true"), m += " >>", u.content = m, this.internal.write(h.objId, "0 R", u.objId, "0 R");
            break;

          case "freetext":
            var p = "/Rect [" + a(l.bounds.x) + " " + s(l.bounds.y) + " " + a(l.bounds.x + l.bounds.w) + " " + s(l.bounds.y + l.bounds.h) + "] ",
                d = l.color || "#000000";
            m = "<</Type /Annot /Subtype /FreeText " + p + "/Contents (" + l.contents + ")", m += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + d + ")", m += " /Border [0 0 0]", m += " >>", this.internal.write(m);
            break;

          case "link":
            if (l.options.name) {
              var g = this.annotations._nameMap[l.options.name];
              l.options.pageNumber = g.page, l.options.top = g.y;
            } else l.options.top || (l.options.top = 0);

            p = "/Rect [" + a(l.x) + " " + s(l.y) + " " + a(l.x + l.w) + " " + s(l.y + l.h) + "] ";
            var m = "";
            if (l.options.url) m = "<</Type /Annot /Subtype /Link " + p + "/Border [0 0 0] /A <</S /URI /URI (" + l.options.url + ") >>";else if (l.options.pageNumber) switch (m = "<</Type /Annot /Subtype /Link " + p + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(l.options.pageNumber).objId + " 0 R", l.options.magFactor = l.options.magFactor || "XYZ", l.options.magFactor) {
              case "Fit":
                m += " /Fit]";
                break;

              case "FitH":
                m += " /FitH " + l.options.top + "]";
                break;

              case "FitV":
                l.options.left = l.options.left || 0, m += " /FitV " + l.options.left + "]";
                break;

              case "XYZ":
              default:
                var y = s(l.options.top);
                l.options.left = l.options.left || 0, void 0 === l.options.zoom && (l.options.zoom = 0), m += " /XYZ " + l.options.left + " " + y + " " + l.options.zoom + "]";
            }
            "" != m && (m += " >>", this.internal.write(m));
        }
      }

      this.internal.write("]");
    }
  }]), t.createAnnotation = function (t) {
    var e = this.internal.getCurrentPageInfo();

    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;

      case "text":
      case "freetext":
        e.pageContext.annotations.push(t);
    }
  }, t.link = function (t, e, n, r, i) {
    this.internal.getCurrentPageInfo().pageContext.annotations.push({
      x: t,
      y: e,
      w: n,
      h: r,
      options: i,
      type: "link"
    });
  }, t.textWithLink = function (t, e, n, r) {
    var i = this.getTextWidth(t),
        o = this.internal.getLineHeight() / this.internal.scaleFactor;
    return this.text(t, e, n), n += .2 * o, this.link(e, n - o, i, o, r), i;
  }, t.getTextWidth = function (t) {
    var e = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * e / this.internal.scaleFactor;
  },
  /**
     * @license
     * Copyright (c) 2017 Aras Abbasi 
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  function (t) {
    var h = {
      1569: [65152],
      1570: [65153, 65154],
      1571: [65155, 65156],
      1572: [65157, 65158],
      1573: [65159, 65160],
      1574: [65161, 65162, 65163, 65164],
      1575: [65165, 65166],
      1576: [65167, 65168, 65169, 65170],
      1577: [65171, 65172],
      1578: [65173, 65174, 65175, 65176],
      1579: [65177, 65178, 65179, 65180],
      1580: [65181, 65182, 65183, 65184],
      1581: [65185, 65186, 65187, 65188],
      1582: [65189, 65190, 65191, 65192],
      1583: [65193, 65194],
      1584: [65195, 65196],
      1585: [65197, 65198],
      1586: [65199, 65200],
      1587: [65201, 65202, 65203, 65204],
      1588: [65205, 65206, 65207, 65208],
      1589: [65209, 65210, 65211, 65212],
      1590: [65213, 65214, 65215, 65216],
      1591: [65217, 65218, 65219, 65220],
      1592: [65221, 65222, 65223, 65224],
      1593: [65225, 65226, 65227, 65228],
      1594: [65229, 65230, 65231, 65232],
      1601: [65233, 65234, 65235, 65236],
      1602: [65237, 65238, 65239, 65240],
      1603: [65241, 65242, 65243, 65244],
      1604: [65245, 65246, 65247, 65248],
      1605: [65249, 65250, 65251, 65252],
      1606: [65253, 65254, 65255, 65256],
      1607: [65257, 65258, 65259, 65260],
      1608: [65261, 65262],
      1609: [65263, 65264, 64488, 64489],
      1610: [65265, 65266, 65267, 65268],
      1649: [64336, 64337],
      1655: [64477],
      1657: [64358, 64359, 64360, 64361],
      1658: [64350, 64351, 64352, 64353],
      1659: [64338, 64339, 64340, 64341],
      1662: [64342, 64343, 64344, 64345],
      1663: [64354, 64355, 64356, 64357],
      1664: [64346, 64347, 64348, 64349],
      1667: [64374, 64375, 64376, 64377],
      1668: [64370, 64371, 64372, 64373],
      1670: [64378, 64379, 64380, 64381],
      1671: [64382, 64383, 64384, 64385],
      1672: [64392, 64393],
      1676: [64388, 64389],
      1677: [64386, 64387],
      1678: [64390, 64391],
      1681: [64396, 64397],
      1688: [64394, 64395],
      1700: [64362, 64363, 64364, 64365],
      1702: [64366, 64367, 64368, 64369],
      1705: [64398, 64399, 64400, 64401],
      1709: [64467, 64468, 64469, 64470],
      1711: [64402, 64403, 64404, 64405],
      1713: [64410, 64411, 64412, 64413],
      1715: [64406, 64407, 64408, 64409],
      1722: [64414, 64415],
      1723: [64416, 64417, 64418, 64419],
      1726: [64426, 64427, 64428, 64429],
      1728: [64420, 64421],
      1729: [64422, 64423, 64424, 64425],
      1733: [64480, 64481],
      1734: [64473, 64474],
      1735: [64471, 64472],
      1736: [64475, 64476],
      1737: [64482, 64483],
      1739: [64478, 64479],
      1740: [64508, 64509, 64510, 64511],
      1744: [64484, 64485, 64486, 64487],
      1746: [64430, 64431],
      1747: [64432, 64433]
    },
        a = {
      65247: {
        65154: 65269,
        65156: 65271,
        65160: 65273,
        65166: 65275
      },
      65248: {
        65154: 65270,
        65156: 65272,
        65160: 65274,
        65166: 65276
      },
      65165: {
        65247: {
          65248: {
            65258: 65010
          }
        }
      },
      1617: {
        1612: 64606,
        1613: 64607,
        1614: 64608,
        1615: 64609,
        1616: 64610
      }
    },
        e = {
      1612: 64606,
      1613: 64607,
      1614: 64608,
      1615: 64609,
      1616: 64610
    },
        n = [1570, 1571, 1573, 1575];
    t.__arabicParser__ = {};

    var r = t.__arabicParser__.isInArabicSubstitutionA = function (t) {
      return void 0 !== h[t.charCodeAt(0)];
    },
        u = t.__arabicParser__.isArabicLetter = function (t) {
      return "string" == typeof t && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t);
    },
        i = t.__arabicParser__.isArabicEndLetter = function (t) {
      return u(t) && r(t) && h[t.charCodeAt(0)].length <= 2;
    },
        o = t.__arabicParser__.isArabicAlfLetter = function (t) {
      return u(t) && 0 <= n.indexOf(t.charCodeAt(0));
    },
        s = (t.__arabicParser__.arabicLetterHasIsolatedForm = function (t) {
      return u(t) && r(t) && 1 <= h[t.charCodeAt(0)].length;
    }, t.__arabicParser__.arabicLetterHasFinalForm = function (t) {
      return u(t) && r(t) && 2 <= h[t.charCodeAt(0)].length;
    }),
        l = (t.__arabicParser__.arabicLetterHasInitialForm = function (t) {
      return u(t) && r(t) && 3 <= h[t.charCodeAt(0)].length;
    }, t.__arabicParser__.arabicLetterHasMedialForm = function (t) {
      return u(t) && r(t) && 4 == h[t.charCodeAt(0)].length;
    }),
        c = t.__arabicParser__.resolveLigatures = function (t) {
      var e = 0,
          n = a,
          r = 0,
          i = "",
          o = 0;

      for (e = 0; e < t.length; e += 1) {
        void 0 !== n[t.charCodeAt(e)] ? (o++, "number" == typeof (n = n[t.charCodeAt(e)]) && (r = -1 !== (r = f(t.charAt(e), t.charAt(e - o), t.charAt(e + 1))) ? r : 0, i += String.fromCharCode(n), n = a, o = 0), e === t.length - 1 && (n = a, i += t.charAt(e - (o - 1)), e -= o - 1, o = 0)) : (n = a, i += t.charAt(e - o), e -= o, o = 0);
      }

      return i;
    },
        f = (t.__arabicParser__.isArabicDiacritic = function (t) {
      return void 0 !== t && void 0 !== e[t.charCodeAt(0)];
    }, t.__arabicParser__.getCorrectForm = function (t, e, n) {
      return u(t) ? !1 === r(t) ? -1 : !s(t) || !u(e) && !u(n) || !u(n) && i(e) || i(t) && !u(e) || i(t) && o(e) || i(t) && i(e) ? 0 : l(t) && u(e) && !i(e) && u(n) && s(n) ? 3 : i(t) || !u(n) ? 1 : 2 : -1;
    }),
        p = t.__arabicParser__.processArabic = t.processArabic = function (t) {
      var e = 0,
          n = 0,
          r = 0,
          i = "",
          o = "",
          a = "",
          s = (t = t || "").split("\\s+"),
          l = [];

      for (e = 0; e < s.length; e += 1) {
        for (l.push(""), n = 0; n < s[e].length; n += 1) {
          i = s[e][n], o = s[e][n - 1], a = s[e][n + 1], u(i) ? (r = f(i, o, a), l[e] += -1 !== r ? String.fromCharCode(h[i.charCodeAt(0)][r]) : i) : l[e] += i;
        }

        l[e] = c(l[e]);
      }

      return l.join(" ");
    };

    t.events.push(["preProcessText", function (t) {
      var e = t.text,
          n = (t.x, t.y, t.options || {}),
          r = (t.mutex, n.lang, []);

      if ("[object Array]" === Object.prototype.toString.call(e)) {
        var i = 0;

        for (r = [], i = 0; i < e.length; i += 1) {
          "[object Array]" === Object.prototype.toString.call(e[i]) ? r.push([p(e[i][0]), e[i][1], e[i][2]]) : r.push([p(e[i])]);
        }

        t.text = r;
      } else t.text = p(e);
    }]);
  }(lt.API), lt.API.autoPrint = function (t) {
    var e;

    switch ((t = t || {}).variant = t.variant || "non-conform", t.variant) {
      case "javascript":
        this.addJS("print({});");
        break;

      case "non-conform":
      default:
        this.internal.events.subscribe("postPutResources", function () {
          e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
        }), this.internal.events.subscribe("putCatalog", function () {
          this.internal.out("/OpenAction " + e + " 0 R");
        });
    }

    return this;
  },
  /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  e = lt.API, (n = function n() {
    var e = void 0;
    Object.defineProperty(this, "pdf", {
      get: function get() {
        return e;
      },
      set: function set(t) {
        e = t;
      }
    });
    var n = 150;
    Object.defineProperty(this, "width", {
      get: function get() {
        return n;
      },
      set: function set(t) {
        n = isNaN(t) || !1 === Number.isInteger(t) || t < 0 ? 150 : t, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = n + 1);
      }
    });
    var r = 300;
    Object.defineProperty(this, "height", {
      get: function get() {
        return r;
      },
      set: function set(t) {
        r = isNaN(t) || !1 === Number.isInteger(t) || t < 0 ? 300 : t, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
      }
    });
    var i = [];
    Object.defineProperty(this, "childNodes", {
      get: function get() {
        return i;
      },
      set: function set(t) {
        i = t;
      }
    });
    var o = {};
    Object.defineProperty(this, "style", {
      get: function get() {
        return o;
      },
      set: function set(t) {
        o = t;
      }
    }), Object.defineProperty(this, "parentNode", {
      get: function get() {
        return !1;
      }
    });
  }).prototype.getContext = function (t, e) {
    var n;
    if ("2d" !== (t = t || "2d")) return null;

    for (n in e) {
      this.pdf.context2d.hasOwnProperty(n) && (this.pdf.context2d[n] = e[n]);
    }

    return (this.pdf.context2d._canvas = this).pdf.context2d;
  }, n.prototype.toDataURL = function () {
    throw new Error("toDataURL is not implemented.");
  }, e.events.push(["initialized", function () {
    this.canvas = new n(), this.canvas.pdf = this;
  }]),
  /** 
     * @license
     * ====================================================================
     * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
     *               2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
     *               2013 Lee Driscoll, https://github.com/lsdriscoll
     *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
     *               2014 James Hall, james@parall.ax
     *               2014 Diego Casorran, https://github.com/diegocr
     *
     * 
     * ====================================================================
     */
  _ = lt.API, F = {
    x: void 0,
    y: void 0,
    w: void 0,
    h: void 0,
    ln: void 0
  }, P = 1, p = function p(t, e, n, r, i) {
    F = {
      x: t,
      y: e,
      w: n,
      h: r,
      ln: i
    };
  }, d = function d() {
    return F;
  }, k = {
    left: 0,
    top: 0,
    bottom: 0
  }, _.setHeaderFunction = function (t) {
    l = t;
  }, _.getTextDimensions = function (t, e) {
    var n = this.table_font_size || this.internal.getFontSize(),
        r = (this.internal.getFont().fontStyle, (e = e || {}).scaleFactor || this.internal.scaleFactor),
        i = 0,
        o = 0,
        a = 0;
    if ("string" == typeof t) 0 != (i = this.getStringUnitWidth(t) * n) && (o = 1);else {
      if ("[object Array]" !== Object.prototype.toString.call(t)) throw new Error("getTextDimensions expects text-parameter to be of type String or an Array of Strings.");

      for (var s = 0; s < t.length; s++) {
        i < (a = this.getStringUnitWidth(t[s]) * n) && (i = a);
      }

      0 !== i && (o = t.length);
    }
    return {
      w: i /= r,
      h: Math.max((o * n * this.getLineHeightFactor() - n * (this.getLineHeightFactor() - 1)) / r, 0)
    };
  }, _.cellAddPage = function () {
    var t = this.margins || k;
    this.addPage(), p(t.left, t.top, void 0, void 0), P += 1;
  }, _.cellInitialize = function () {
    F = {
      x: void 0,
      y: void 0,
      w: void 0,
      h: void 0,
      ln: void 0
    }, P = 1;
  }, _.cell = function (t, e, n, r, i, o, a) {
    var s = d(),
        l = !1;
    if (void 0 !== s.ln) if (s.ln === o) t = s.x + s.w, e = s.y;else {
      var h = this.margins || k;
      s.y + s.h + r + 13 >= this.internal.pageSize.getHeight() - h.bottom && (this.cellAddPage(), l = !0, this.printHeaders && this.tableHeaderRow && this.printHeaderRow(o, !0)), e = d().y + d().h, l && (e = 23);
    }
    if (void 0 !== i[0]) if (this.printingHeaderRow ? this.rect(t, e, n, r, "FD") : this.rect(t, e, n, r), "right" === a) {
      i instanceof Array || (i = [i]);

      for (var u = 0; u < i.length; u++) {
        var c = i[u],
            f = this.getStringUnitWidth(c) * this.internal.getFontSize() / this.internal.scaleFactor;
        this.text(c, t + n - f - 3, e + this.internal.getLineHeight() * (u + 1));
      }
    } else this.text(i, t + 3, e + this.internal.getLineHeight());
    return p(t, e, n, r, o), this;
  }, _.arrayMax = function (t, e) {
    var n,
        r,
        i,
        o = t[0];

    for (n = 0, r = t.length; n < r; n += 1) {
      i = t[n], e ? -1 === e(o, i) && (o = i) : o < i && (o = i);
    }

    return o;
  }, _.table = function (t, e, n, r, i) {
    if (!n) throw "No data for PDF table";
    var o,
        a,
        s,
        l,
        h,
        u,
        c,
        f,
        p,
        d,
        g = [],
        m = [],
        y = {},
        v = {},
        w = [],
        b = [],
        x = !1,
        N = !0,
        L = 12,
        A = k;
    if (A.width = this.internal.pageSize.getWidth(), i && (!0 === i.autoSize && (x = !0), !1 === i.printHeaders && (N = !1), i.fontSize && (L = i.fontSize), i.css && void 0 !== i.css["font-size"] && (L = 16 * i.css["font-size"]), i.margins && (A = i.margins)), this.lnMod = 0, F = {
      x: void 0,
      y: void 0,
      w: void 0,
      h: void 0,
      ln: void 0
    }, P = 1, this.printHeaders = N, this.margins = A, this.setFontSize(L), this.table_font_size = L, null == r) g = Object.keys(n[0]);else if (r[0] && "string" != typeof r[0]) for (a = 0, s = r.length; a < s; a += 1) {
      o = r[a], g.push(o.name), m.push(o.prompt), v[o.name] = o.width * (19.049976 / 25.4);
    } else g = r;
    if (x) for (d = function d(t) {
      return t[o];
    }, a = 0, s = g.length; a < s; a += 1) {
      for (y[o = g[a]] = n.map(d), w.push(this.getTextDimensions(m[a] || o, {
        scaleFactor: 1
      }).w), c = 0, l = (u = y[o]).length; c < l; c += 1) {
        h = u[c], w.push(this.getTextDimensions(h, {
          scaleFactor: 1
        }).w);
      }

      v[o] = _.arrayMax(w), w = [];
    }

    if (N) {
      var S = this.calculateLineHeight(g, v, m.length ? m : g);

      for (a = 0, s = g.length; a < s; a += 1) {
        o = g[a], b.push([t, e, v[o], S, String(m.length ? m[a] : o)]);
      }

      this.setTableHeaderRow(b), this.printHeaderRow(1, !1);
    }

    for (a = 0, s = n.length; a < s; a += 1) {
      for (f = n[a], S = this.calculateLineHeight(g, v, f), c = 0, p = g.length; c < p; c += 1) {
        o = g[c], this.cell(t, e, v[o], S, f[o], a + 2, o.align);
      }
    }

    return this.lastCellPos = F, this.table_x = t, this.table_y = e, this;
  }, _.calculateLineHeight = function (t, e, n) {
    for (var r, i = 0, o = 0; o < t.length; o++) {
      n[r = t[o]] = this.splitTextToSize(String(n[r]), e[r] - 3);
      var a = this.internal.getLineHeight() * n[r].length + 3;
      i < a && (i = a);
    }

    return i;
  }, _.setTableHeaderRow = function (t) {
    this.tableHeaderRow = t;
  }, _.printHeaderRow = function (t, e) {
    if (!this.tableHeaderRow) throw "Property tableHeaderRow does not exist.";
    var n, r, i, o;

    if (this.printingHeaderRow = !0, void 0 !== l) {
      var a = l(this, P);
      p(a[0], a[1], a[2], a[3], -1);
    }

    this.setFontStyle("bold");
    var s = [];

    for (i = 0, o = this.tableHeaderRow.length; i < o; i += 1) {
      this.setFillColor(200, 200, 200), n = this.tableHeaderRow[i], e && (this.margins.top = 13, n[1] = this.margins && this.margins.top || 0, s.push(n)), r = [].concat(n), this.cell.apply(this, r.concat(t));
    }

    0 < s.length && this.setTableHeaderRow(s), this.setFontStyle("normal"), this.printingHeaderRow = !1;
  },
  /**
     * jsPDF Context2D PlugIn Copyright (c) 2014 Steven Spungin (TwelveTone LLC) steven@twelvetone.tv
     *
     * Licensed under the MIT License. http://opensource.org/licenses/mit-license
     */
  function (t, e) {
    var l,
        i,
        o,
        h,
        u,
        c = function c(t) {
      return t = t || {}, this.isStrokeTransparent = t.isStrokeTransparent || !1, this.strokeOpacity = t.strokeOpacity || 1, this.strokeStyle = t.strokeStyle || "#000000", this.fillStyle = t.fillStyle || "#000000", this.isFillTransparent = t.isFillTransparent || !1, this.fillOpacity = t.fillOpacity || 1, this.font = t.font || "10px sans-serif", this.textBaseline = t.textBaseline || "alphabetic", this.textAlign = t.textAlign || "left", this.lineWidth = t.lineWidth || 1, this.lineJoin = t.lineJoin || "miter", this.lineCap = t.lineCap || "butt", this.path = t.path || [], this.transform = void 0 !== t.transform ? t.transform.clone() : new M(), this.globalCompositeOperation = t.globalCompositeOperation || "normal", this.globalAlpha = t.globalAlpha || 1, this.clip_path = t.clip_path || [], this.currentPoint = t.currentPoint || new j(), this.miterLimit = t.miterLimit || 10, this.lastPoint = t.lastPoint || new j(), this.ignoreClearRect = "boolean" != typeof t.ignoreClearRect || t.ignoreClearRect, this;
    };

    t.events.push(["initialized", function () {
      this.context2d = new n(this), l = this.internal.f2, this.internal.f3, i = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, h = this.internal.getHorizontalCoordinate, u = this.internal.getVerticalCoordinate;
    }]);

    var n = function n(t) {
      Object.defineProperty(this, "canvas", {
        get: function get() {
          return {
            parentNode: !1,
            style: !1
          };
        }
      }), Object.defineProperty(this, "pdf", {
        get: function get() {
          return t;
        }
      });
      var e = !1;
      Object.defineProperty(this, "pageWrapXEnabled", {
        get: function get() {
          return e;
        },
        set: function set(t) {
          e = Boolean(t);
        }
      });
      var n = !1;
      Object.defineProperty(this, "pageWrapYEnabled", {
        get: function get() {
          return n;
        },
        set: function set(t) {
          n = Boolean(t);
        }
      });
      var r = 0;
      Object.defineProperty(this, "posX", {
        get: function get() {
          return r;
        },
        set: function set(t) {
          isNaN(t) || (r = t);
        }
      });
      var i = 0;
      Object.defineProperty(this, "posY", {
        get: function get() {
          return i;
        },
        set: function set(t) {
          isNaN(t) || (i = t);
        }
      });
      var o = !1;
      Object.defineProperty(this, "autoPaging", {
        get: function get() {
          return o;
        },
        set: function set(t) {
          o = Boolean(t);
        }
      });
      var a = 0;
      Object.defineProperty(this, "lastBreak", {
        get: function get() {
          return a;
        },
        set: function set(t) {
          a = t;
        }
      });
      var s = [];
      Object.defineProperty(this, "pageBreaks", {
        get: function get() {
          return s;
        },
        set: function set(t) {
          s = t;
        }
      });
      var l = new c();
      Object.defineProperty(this, "ctx", {
        get: function get() {
          return l;
        },
        set: function set(t) {
          t instanceof c && (l = t);
        }
      }), Object.defineProperty(this, "path", {
        get: function get() {
          return l.path;
        },
        set: function set(t) {
          l.path = t;
        }
      });
      var h = [];
      Object.defineProperty(this, "ctxStack", {
        get: function get() {
          return h;
        },
        set: function set(t) {
          h = t;
        }
      }), Object.defineProperty(this, "fillStyle", {
        get: function get() {
          return this.ctx.fillStyle;
        },
        set: function set(t) {
          var e;
          e = f(t), this.ctx.fillStyle = e.style, this.ctx.isFillTransparent = 0 === e.a, this.ctx.fillOpacity = e.a, this.pdf.setFillColor(e.r, e.g, e.b, {
            a: e.a
          }), this.pdf.setTextColor(e.r, e.g, e.b, {
            a: e.a
          });
        }
      }), Object.defineProperty(this, "strokeStyle", {
        get: function get() {
          return this.ctx.strokeStyle;
        },
        set: function set(t) {
          var e = f(t);
          this.ctx.strokeStyle = e.style, this.ctx.isStrokeTransparent = 0 === e.a, this.ctx.strokeOpacity = e.a, 0 === e.a ? this.pdf.setDrawColor(255, 255, 255) : (e.a, this.pdf.setDrawColor(e.r, e.g, e.b));
        }
      }), Object.defineProperty(this, "lineCap", {
        get: function get() {
          return this.ctx.lineCap;
        },
        set: function set(t) {
          -1 !== ["butt", "round", "square"].indexOf(t) && (this.ctx.lineCap = t, this.pdf.setLineCap(t));
        }
      }), Object.defineProperty(this, "lineWidth", {
        get: function get() {
          return this.ctx.lineWidth;
        },
        set: function set(t) {
          isNaN(t) || (this.ctx.lineWidth = t, this.pdf.setLineWidth(t));
        }
      }), Object.defineProperty(this, "lineJoin", {
        get: function get() {
          return this.ctx.lineJoin;
        },
        set: function set(t) {
          -1 !== ["bevel", "round", "miter"].indexOf(t) && (this.ctx.lineJoin = t, this.pdf.setLineJoin(t));
        }
      }), Object.defineProperty(this, "miterLimit", {
        get: function get() {
          return this.ctx.miterLimit;
        },
        set: function set(t) {
          isNaN(t) || (this.ctx.miterLimit = t, this.pdf.setMiterLimit(t));
        }
      }), Object.defineProperty(this, "textBaseline", {
        get: function get() {
          return this.ctx.textBaseline;
        },
        set: function set(t) {
          this.ctx.textBaseline = t;
        }
      }), Object.defineProperty(this, "textAlign", {
        get: function get() {
          return this.ctx.textAlign;
        },
        set: function set(t) {
          -1 !== ["right", "end", "center", "left", "start"].indexOf(t) && (this.ctx.textAlign = t);
        }
      }), Object.defineProperty(this, "font", {
        get: function get() {
          return this.ctx.font;
        },
        set: function set(t) {
          var e;

          if (this.ctx.font = t, null !== (e = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t))) {
            var n = e[1],
                r = (e[2], e[3]),
                i = e[4],
                o = e[5],
                a = e[6];
            i = "px" === o ? Math.floor(parseFloat(i)) : "em" === o ? Math.floor(parseFloat(i) * this.pdf.getFontSize()) : Math.floor(parseFloat(i)), this.pdf.setFontSize(i);
            var s = "";
            ("bold" === r || 700 <= parseInt(r, 10) || "bold" === n) && (s = "bold"), "italic" === n && (s += "italic"), 0 === s.length && (s = "normal");

            for (var l = "", h = a.toLowerCase().replace(/"|'/g, "").split(/\s*,\s*/), u = {
              arial: "Helvetica",
              verdana: "Helvetica",
              helvetica: "Helvetica",
              "sans-serif": "Helvetica",
              fixed: "Courier",
              monospace: "Courier",
              terminal: "Courier",
              courier: "Courier",
              times: "Times",
              cursive: "Times",
              fantasy: "Times",
              serif: "Times"
            }, c = 0; c < h.length; c++) {
              if (void 0 !== this.pdf.internal.getFont(h[c], s, {
                noFallback: !0,
                disableWarning: !0
              })) {
                l = h[c];
                break;
              }

              if ("bolditalic" === s && void 0 !== this.pdf.internal.getFont(h[c], "bold", {
                noFallback: !0,
                disableWarning: !0
              })) l = h[c], s = "bold";else if (void 0 !== this.pdf.internal.getFont(h[c], "normal", {
                noFallback: !0,
                disableWarning: !0
              })) {
                l = h[c], s = "normal";
                break;
              }
            }

            if ("" === l) for (c = 0; c < h.length; c++) {
              if (u[h[c]]) {
                l = u[h[c]];
                break;
              }
            }
            l = "" === l ? "Times" : l, this.pdf.setFont(l, s);
          }
        }
      }), Object.defineProperty(this, "globalCompositeOperation", {
        get: function get() {
          return this.ctx.globalCompositeOperation;
        },
        set: function set(t) {
          this.ctx.globalCompositeOperation = t;
        }
      }), Object.defineProperty(this, "globalAlpha", {
        get: function get() {
          return this.ctx.globalAlpha;
        },
        set: function set(t) {
          this.ctx.globalAlpha = t;
        }
      }), Object.defineProperty(this, "ignoreClearRect", {
        get: function get() {
          return this.ctx.ignoreClearRect;
        },
        set: function set(t) {
          this.ctx.ignoreClearRect = Boolean(t);
        }
      });
    };

    n.prototype.fill = function () {
      r.call(this, "fill", !1);
    }, n.prototype.stroke = function () {
      r.call(this, "stroke", !1);
    }, n.prototype.beginPath = function () {
      this.path = [{
        type: "begin"
      }];
    }, n.prototype.moveTo = function (t, e) {
      if (isNaN(t) || isNaN(e)) throw console.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
      var n = this.ctx.transform.applyToPoint(new j(t, e));
      this.path.push({
        type: "mt",
        x: n.x,
        y: n.y
      }), this.ctx.lastPoint = new j(t, e);
    }, n.prototype.closePath = function () {
      var t = new j(0, 0),
          e = 0;

      for (e = this.path.length - 1; -1 !== e; e--) {
        if ("begin" === this.path[e].type && "object" === se(this.path[e + 1]) && "number" == typeof this.path[e + 1].x) {
          t = new j(this.path[e + 1].x, this.path[e + 1].y), this.path.push({
            type: "lt",
            x: t.x,
            y: t.y
          });
          break;
        }
      }

      "object" === se(this.path[e + 2]) && "number" == typeof this.path[e + 2].x && this.path.push(JSON.parse(JSON.stringify(this.path[e + 2]))), this.path.push({
        type: "close"
      }), this.ctx.lastPoint = new j(t.x, t.y);
    }, n.prototype.lineTo = function (t, e) {
      if (isNaN(t) || isNaN(e)) throw console.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
      var n = this.ctx.transform.applyToPoint(new j(t, e));
      this.path.push({
        type: "lt",
        x: n.x,
        y: n.y
      }), this.ctx.lastPoint = new j(n.x, n.y);
    }, n.prototype.clip = function () {
      this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), r.call(this, null, !0);
    }, n.prototype.quadraticCurveTo = function (t, e, n, r) {
      if (isNaN(n) || isNaN(r) || isNaN(t) || isNaN(e)) throw console.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
      var i = this.ctx.transform.applyToPoint(new j(n, r)),
          o = this.ctx.transform.applyToPoint(new j(t, e));
      this.path.push({
        type: "qct",
        x1: o.x,
        y1: o.y,
        x: i.x,
        y: i.y
      }), this.ctx.lastPoint = new j(i.x, i.y);
    }, n.prototype.bezierCurveTo = function (t, e, n, r, i, o) {
      if (isNaN(i) || isNaN(o) || isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r)) throw console.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
      var a = this.ctx.transform.applyToPoint(new j(i, o)),
          s = this.ctx.transform.applyToPoint(new j(t, e)),
          l = this.ctx.transform.applyToPoint(new j(n, r));
      this.path.push({
        type: "bct",
        x1: s.x,
        y1: s.y,
        x2: l.x,
        y2: l.y,
        x: a.x,
        y: a.y
      }), this.ctx.lastPoint = new j(a.x, a.y);
    }, n.prototype.arc = function (t, e, n, r, i, o) {
      if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r) || isNaN(i)) throw console.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");

      if (o = Boolean(o), !this.ctx.transform.isIdentity) {
        var a = this.ctx.transform.applyToPoint(new j(t, e));
        t = a.x, e = a.y;
        var s = this.ctx.transform.applyToPoint(new j(0, n)),
            l = this.ctx.transform.applyToPoint(new j(0, 0));
        n = Math.sqrt(Math.pow(s.x - l.x, 2) + Math.pow(s.y - l.y, 2));
      }

      Math.abs(i - r) >= 2 * Math.PI && (r = 0, i = 2 * Math.PI), this.path.push({
        type: "arc",
        x: t,
        y: e,
        radius: n,
        startAngle: r,
        endAngle: i,
        counterclockwise: o
      });
    }, n.prototype.arcTo = function (t, e, n, r, i) {
      throw new Error("arcTo not implemented.");
    }, n.prototype.rect = function (t, e, n, r) {
      if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r)) throw console.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
      this.moveTo(t, e), this.lineTo(t + n, e), this.lineTo(t + n, e + r), this.lineTo(t, e + r), this.lineTo(t, e), this.lineTo(t + n, e), this.lineTo(t, e);
    }, n.prototype.fillRect = function (t, e, n, r) {
      if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r)) throw console.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");

      if (!N.call(this)) {
        var i = {};
        "butt" !== this.lineCap && (i.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t, e, n, r), this.fill(), i.hasOwnProperty("lineCap") && (this.lineCap = i.lineCap), i.hasOwnProperty("lineJoin") && (this.lineJoin = i.lineJoin);
      }
    }, n.prototype.strokeRect = function (t, e, n, r) {
      if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r)) throw console.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
      L.call(this) || (this.beginPath(), this.rect(t, e, n, r), this.stroke());
    }, n.prototype.clearRect = function (t, e, n, r) {
      if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r)) throw console.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
      this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t, e, n, r));
    }, n.prototype.save = function (t) {
      t = "boolean" != typeof t || t;

      for (var e = this.pdf.internal.getCurrentPageInfo().pageNumber, n = 0; n < this.pdf.internal.getNumberOfPages(); n++) {
        this.pdf.setPage(n + 1), this.pdf.internal.out("q");
      }

      if (this.pdf.setPage(e), t) {
        this.ctx.fontSize = this.pdf.internal.getFontSize();
        var r = new c(this.ctx);
        this.ctxStack.push(this.ctx), this.ctx = r;
      }
    }, n.prototype.restore = function (t) {
      t = "boolean" != typeof t || t;

      for (var e = this.pdf.internal.getCurrentPageInfo().pageNumber, n = 0; n < this.pdf.internal.getNumberOfPages(); n++) {
        this.pdf.setPage(n + 1), this.pdf.internal.out("Q");
      }

      this.pdf.setPage(e), t && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin);
    }, n.prototype.toDataURL = function () {
      throw new Error("toDataUrl not implemented.");
    };

    var f = function f(t) {
      var e, n, r, i;
      if (!0 === t.isCanvasGradient && (t = t.getColor()), !t) return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        style: t
      };
      if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t)) i = r = n = e = 0;else {
        var o = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t);
        if (null !== o) e = parseInt(o[1]), n = parseInt(o[2]), r = parseInt(o[3]), i = 1;else if (null !== (o = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/.exec(t))) e = parseInt(o[1]), n = parseInt(o[2]), r = parseInt(o[3]), i = parseFloat(o[4]);else {
          if (i = 1, "string" == typeof t && "#" !== t.charAt(0)) {
            var a = new RGBColor(t);
            t = a.ok ? a.toHex() : "#000000";
          }

          4 === t.length ? (e = t.substring(1, 2), e += e, n = t.substring(2, 3), n += n, r = t.substring(3, 4), r += r) : (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7)), e = parseInt(e, 16), n = parseInt(n, 16), r = parseInt(r, 16);
        }
      }
      return {
        r: e,
        g: n,
        b: r,
        a: i,
        style: t
      };
    },
        N = function N() {
      return this.ctx.isFillTransparent || 0 == this.globalAlpha;
    },
        L = function L() {
      return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
    };

    n.prototype.fillText = function (t, e, n, r) {
      if (isNaN(e) || isNaN(n) || "string" != typeof t) throw console.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");

      if (r = isNaN(r) ? void 0 : r, !N.call(this)) {
        n = a.call(this, n);
        var i = B(this.ctx.transform.rotation),
            o = this.ctx.transform.scaleX;
        s.call(this, {
          text: t,
          x: e,
          y: n,
          scale: o,
          angle: i,
          align: this.textAlign,
          maxWidth: r
        });
      }
    }, n.prototype.strokeText = function (t, e, n, r) {
      if (isNaN(e) || isNaN(n) || "string" != typeof t) throw console.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");

      if (!L.call(this)) {
        r = isNaN(r) ? void 0 : r, n = a.call(this, n);
        var i = B(this.ctx.transform.rotation),
            o = this.ctx.transform.scaleX;
        s.call(this, {
          text: t,
          x: e,
          y: n,
          scale: o,
          renderingMode: "stroke",
          angle: i,
          align: this.textAlign,
          maxWidth: r
        });
      }
    }, n.prototype.measureText = function (t) {
      if ("string" != typeof t) throw console.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
      var e = this.pdf,
          n = this.pdf.internal.scaleFactor,
          r = e.internal.getFontSize(),
          i = e.getStringUnitWidth(t) * r / e.internal.scaleFactor;
      return new function (t) {
        var e = (t = t || {}).width || 0;
        return Object.defineProperty(this, "width", {
          get: function get() {
            return e;
          }
        }), this;
      }({
        width: i *= Math.round(96 * n / 72 * 1e4) / 1e4
      });
    }, n.prototype.scale = function (t, e) {
      if (isNaN(t) || isNaN(e)) throw console.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
      var n = new M(t, 0, 0, e, 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(n);
    }, n.prototype.rotate = function (t) {
      if (isNaN(t)) throw console.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
      var e = new M(Math.cos(t), Math.sin(t), -Math.sin(t), Math.cos(t), 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(e);
    }, n.prototype.translate = function (t, e) {
      if (isNaN(t) || isNaN(e)) throw console.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
      var n = new M(1, 0, 0, 1, t, e);
      this.ctx.transform = this.ctx.transform.multiply(n);
    }, n.prototype.transform = function (t, e, n, r, i, o) {
      if (isNaN(t) || isNaN(e) || isNaN(n) || isNaN(r) || isNaN(i) || isNaN(o)) throw console.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
      var a = new M(t, e, n, r, i, o);
      this.ctx.transform = this.ctx.transform.multiply(a);
    }, n.prototype.setTransform = function (t, e, n, r, i, o) {
      t = isNaN(t) ? 1 : t, e = isNaN(e) ? 0 : e, n = isNaN(n) ? 0 : n, r = isNaN(r) ? 1 : r, i = isNaN(i) ? 0 : i, o = isNaN(o) ? 0 : o, this.ctx.transform = new M(t, e, n, r, i, o);
    }, n.prototype.drawImage = function (t, e, n, r, i, o, a, s, l) {
      var h = this.pdf.getImageProperties(t),
          u = 1,
          c = 1,
          f = 1,
          p = 1;
      void 0 !== r && void 0 !== s && (f = s / r, p = l / i, u = h.width / r * s / r, c = h.height / i * l / i), void 0 === o && (o = e, a = n, n = e = 0), void 0 !== r && void 0 === s && (s = r, l = i), void 0 === r && void 0 === s && (s = h.width, l = h.height);
      var d = this.ctx.transform.decompose(),
          g = B(d.rotate.shx);
      d.scale.sx, d.scale.sy;

      for (var m, y = new M(), v = ((y = (y = (y = y.multiply(d.translate)).multiply(d.skew)).multiply(d.scale)).applyToPoint(new j(s, l)), y.applyToRectangle(new E(o - e * f, a - n * p, r * u, i * c))), w = F.call(this, v), b = [], x = 0; x < w.length; x += 1) {
        -1 === b.indexOf(w[x]) && b.push(w[x]);
      }

      if (b.sort(), this.autoPaging) for (var N = b[0], L = b[b.length - 1], A = N; A < L + 1; A++) {
        if (this.pdf.setPage(A), 0 !== this.ctx.clip_path.length) {
          var S = this.path;
          m = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = P(m, this.posX, -1 * this.pdf.internal.pageSize.height * (A - 1) + this.posY), k.call(this, "fill", !0), this.path = S;
        }

        var _ = JSON.parse(JSON.stringify(v));

        _ = P([_], this.posX, -1 * this.pdf.internal.pageSize.height * (A - 1) + this.posY)[0], this.pdf.addImage(t, "jpg", _.x, _.y, _.w, _.h, null, null, g);
      } else this.pdf.addImage(t, "jpg", v.x, v.y, v.w, v.h, null, null, g);
    };

    var F = function F(t, e, n) {
      var r = [];

      switch (e = e || this.pdf.internal.pageSize.width, n = n || this.pdf.internal.pageSize.height, t.type) {
        default:
        case "mt":
        case "lt":
          r.push(Math.floor((t.y + this.posY) / n) + 1);
          break;

        case "arc":
          r.push(Math.floor((t.y + this.posY - t.radius) / n) + 1), r.push(Math.floor((t.y + this.posY + t.radius) / n) + 1);
          break;

        case "qct":
          var i = w(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t.x1, t.y1, t.x, t.y);
          r.push(Math.floor(i.y / n) + 1), r.push(Math.floor((i.y + i.h) / n) + 1);
          break;

        case "bct":
          var o = b(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t.x1, t.y1, t.x2, t.y2, t.x, t.y);
          r.push(Math.floor(o.y / n) + 1), r.push(Math.floor((o.y + o.h) / n) + 1);
          break;

        case "rect":
          r.push(Math.floor((t.y + this.posY) / n) + 1), r.push(Math.floor((t.y + t.h + this.posY) / n) + 1);
      }

      for (var a = 0; a < r.length; a += 1) {
        for (; this.pdf.internal.getNumberOfPages() < r[a];) {
          v.call(this);
        }
      }

      return r;
    },
        v = function v() {
      var t = this.fillStyle,
          e = this.strokeStyle,
          n = this.font,
          r = this.lineCap,
          i = this.lineWidth,
          o = this.lineJoin;
      this.pdf.addPage(), this.fillStyle = t, this.strokeStyle = e, this.font = n, this.lineCap = r, this.lineWidth = i, this.lineJoin = o;
    },
        P = function P(t, e, n) {
      for (var r = 0; r < t.length; r++) {
        switch (t[r].type) {
          case "bct":
            t[r].x2 += e, t[r].y2 += n;

          case "qct":
            t[r].x1 += e, t[r].y1 += n;

          case "mt":
          case "lt":
          case "arc":
          default:
            t[r].x += e, t[r].y += n;
        }
      }

      return t;
    },
        r = function r(t, e) {
      for (var n, r, i = this.fillStyle, o = this.strokeStyle, a = (this.font, this.lineCap), s = this.lineWidth, l = this.lineJoin, h = JSON.parse(JSON.stringify(this.path)), u = JSON.parse(JSON.stringify(this.path)), c = [], f = 0; f < u.length; f++) {
        if (void 0 !== u[f].x) for (var p = F.call(this, u[f]), d = 0; d < p.length; d += 1) {
          -1 === c.indexOf(p[d]) && c.push(p[d]);
        }
      }

      for (f = 0; f < c.length; f++) {
        for (; this.pdf.internal.getNumberOfPages() < c[f];) {
          v.call(this);
        }
      }

      if (c.sort(), this.autoPaging) {
        var g = c[0],
            m = c[c.length - 1];

        for (f = g; f < m + 1; f++) {
          if (this.pdf.setPage(f), this.fillStyle = i, this.strokeStyle = o, this.lineCap = a, this.lineWidth = s, this.lineJoin = l, 0 !== this.ctx.clip_path.length) {
            var y = this.path;
            n = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = P(n, this.posX, -1 * this.pdf.internal.pageSize.height * (f - 1) + this.posY), k.call(this, t, !0), this.path = y;
          }

          r = JSON.parse(JSON.stringify(h)), this.path = P(r, this.posX, -1 * this.pdf.internal.pageSize.height * (f - 1) + this.posY), !1 !== e && 0 !== f || k.call(this, t, e);
        }
      } else k.call(this, t, e);

      this.path = h;
    },
        k = function k(t, e) {
      if (("stroke" !== t || e || !L.call(this)) && ("stroke" === t || e || !N.call(this))) {
        var n = [];
        this.ctx.globalAlpha;
        this.ctx.fillOpacity < 1 && this.ctx.fillOpacity;

        for (var r, i = this.path, o = 0; o < i.length; o++) {
          var a = i[o];

          switch (a.type) {
            case "begin":
              n.push({
                begin: !0
              });
              break;

            case "close":
              n.push({
                close: !0
              });
              break;

            case "mt":
              n.push({
                start: a,
                deltas: [],
                abs: []
              });
              break;

            case "lt":
              var s = n.length;

              if (!isNaN(i[o - 1].x)) {
                var l = [a.x - i[o - 1].x, a.y - i[o - 1].y];
                if (0 < s) for (; 0 <= s; s--) {
                  if (!0 !== n[s - 1].close && !0 !== n[s - 1].begin) {
                    n[s - 1].deltas.push(l), n[s - 1].abs.push(a);
                    break;
                  }
                }
              }

              break;

            case "bct":
              l = [a.x1 - i[o - 1].x, a.y1 - i[o - 1].y, a.x2 - i[o - 1].x, a.y2 - i[o - 1].y, a.x - i[o - 1].x, a.y - i[o - 1].y];
              n[n.length - 1].deltas.push(l);
              break;

            case "qct":
              var h = i[o - 1].x + 2 / 3 * (a.x1 - i[o - 1].x),
                  u = i[o - 1].y + 2 / 3 * (a.y1 - i[o - 1].y),
                  c = a.x + 2 / 3 * (a.x1 - a.x),
                  f = a.y + 2 / 3 * (a.y1 - a.y),
                  p = a.x,
                  d = a.y;
              l = [h - i[o - 1].x, u - i[o - 1].y, c - i[o - 1].x, f - i[o - 1].y, p - i[o - 1].x, d - i[o - 1].y];
              n[n.length - 1].deltas.push(l);
              break;

            case "arc":
              n.push({
                deltas: [],
                abs: [],
                arc: !0
              }), Array.isArray(n[n.length - 1].abs) && n[n.length - 1].abs.push(a);
          }
        }

        r = e ? null : "stroke" === t ? "stroke" : "fill";

        for (o = 0; o < n.length; o++) {
          if (n[o].arc) for (var g = n[o].abs, m = 0; m < g.length; m++) {
            var y = g[m];

            if (void 0 !== y.startAngle) {
              var v = B(y.startAngle),
                  w = B(y.endAngle),
                  b = y.x,
                  x = y.y;
              A.call(this, b, x, y.radius, v, w, y.counterclockwise, r, e);
            } else I.call(this, y.x, y.y);
          }

          if (!n[o].arc && !0 !== n[o].close && !0 !== n[o].begin) {
            b = n[o].start.x, x = n[o].start.y;
            C.call(this, n[o].deltas, b, x, null, null);
          }
        }

        r && S.call(this, r), e && _.call(this);
      }
    },
        a = function a(t) {
      var e = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor,
          n = e * (this.pdf.internal.getLineHeightFactor() - 1);

      switch (this.ctx.textBaseline) {
        case "bottom":
          return t - n;

        case "top":
          return t + e - n;

        case "hanging":
          return t + e - 2 * n;

        case "middle":
          return t + e / 2 - n;

        case "ideographic":
          return t;

        case "alphabetic":
        default:
          return t;
      }
    };

    n.prototype.createLinearGradient = function () {
      var t = function t() {};

      return t.colorStops = [], t.addColorStop = function (t, e) {
        this.colorStops.push([t, e]);
      }, t.getColor = function () {
        return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
      }, t.isCanvasGradient = !0, t;
    }, n.prototype.createPattern = function () {
      return this.createLinearGradient();
    }, n.prototype.createRadialGradient = function () {
      return this.createLinearGradient();
    };

    var A = function A(t, e, n, r, i, o, a, s) {
      this.pdf.internal.scaleFactor;

      for (var l = y(r), h = y(i), u = g.call(this, n, l, h, o), c = 0; c < u.length; c++) {
        var f = u[c];
        0 === c && p.call(this, f.x1 + t, f.y1 + e), d.call(this, t, e, f.x2, f.y2, f.x3, f.y3, f.x4, f.y4);
      }

      s ? _.call(this) : S.call(this, a);
    },
        S = function S(t) {
      switch (t) {
        case "stroke":
          this.pdf.internal.out("S");
          break;

        case "fill":
          this.pdf.internal.out("f");
      }
    },
        _ = function _() {
      this.pdf.clip();
    },
        p = function p(t, e) {
      this.pdf.internal.out(i(t) + " " + o(e) + " m");
    },
        s = function s(t) {
      var e;

      switch (t.align) {
        case "right":
        case "end":
          e = "right";
          break;

        case "center":
          e = "center";
          break;

        case "left":
        case "start":
        default:
          e = "left";
      }

      var n = this.ctx.transform.applyToPoint(new j(t.x, t.y)),
          r = this.ctx.transform.decompose(),
          i = new M();
      i = (i = (i = i.multiply(r.translate)).multiply(r.skew)).multiply(r.scale);

      for (var o, a = this.pdf.getTextDimensions(t.text), s = this.ctx.transform.applyToRectangle(new E(t.x, t.y, a.w, a.h)), l = i.applyToRectangle(new E(t.x, t.y - a.h, a.w, a.h)), h = F.call(this, l), u = [], c = 0; c < h.length; c += 1) {
        -1 === u.indexOf(h[c]) && u.push(h[c]);
      }

      if (u.sort(), !0 === this.autoPaging) for (var f = u[0], p = u[u.length - 1], d = f; d < p + 1; d++) {
        if (this.pdf.setPage(d), 0 !== this.ctx.clip_path.length) {
          var g = this.path;
          o = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = P(o, this.posX, -1 * this.pdf.internal.pageSize.height * (d - 1) + this.posY), k.call(this, "fill", !0), this.path = g;
        }

        var m = JSON.parse(JSON.stringify(s));

        if (m = P([m], this.posX, -1 * this.pdf.internal.pageSize.height * (d - 1) + this.posY)[0], .01 <= t.scale) {
          var y = this.pdf.internal.getFontSize();
          this.pdf.setFontSize(y * t.scale);
        }

        this.pdf.text(t.text, m.x, m.y, {
          angle: t.angle,
          align: e,
          renderingMode: t.renderingMode,
          maxWidth: t.maxWidth
        }), .01 <= t.scale && this.pdf.setFontSize(y);
      } else {
        if (.01 <= t.scale) {
          y = this.pdf.internal.getFontSize();
          this.pdf.setFontSize(y * t.scale);
        }

        this.pdf.text(t.text, n.x + this.posX, n.y + this.posY, {
          angle: t.angle,
          align: e,
          renderingMode: t.renderingMode,
          maxWidth: t.maxWidth
        }), .01 <= t.scale && this.pdf.setFontSize(y);
      }
    },
        I = function I(t, e, n, r) {
      n = n || 0, r = r || 0, this.pdf.internal.out(i(t + n) + " " + o(e + r) + " l");
    },
        C = function C(t, e, n) {
      return this.pdf.lines(t, e, n, null, null);
    },
        d = function d(t, e, n, r, i, o, a, s) {
      this.pdf.internal.out([l(h(n + t)), l(u(r + e)), l(h(i + t)), l(u(o + e)), l(h(a + t)), l(u(s + e)), "c"].join(" "));
    },
        g = function g(t, e, n, r) {
      var i = 2 * Math.PI,
          o = e;
      (o < i || i < o) && (o %= i);
      var a = n;
      (a < i || i < a) && (a %= i);

      for (var s = [], l = Math.PI / 2, h = r ? -1 : 1, u = e, c = Math.min(i, Math.abs(a - o)); 1e-5 < c;) {
        var f = u + h * Math.min(c, l);
        s.push(m.call(this, t, u, f)), c -= Math.abs(f - u), u = f;
      }

      return s;
    },
        m = function m(t, e, n) {
      var r = (n - e) / 2,
          i = t * Math.cos(r),
          o = t * Math.sin(r),
          a = i,
          s = -o,
          l = a * a + s * s,
          h = l + a * i + s * o,
          u = 4 / 3 * (Math.sqrt(2 * l * h) - h) / (a * o - s * i),
          c = a - u * s,
          f = s + u * a,
          p = c,
          d = -f,
          g = r + e,
          m = Math.cos(g),
          y = Math.sin(g);
      return {
        x1: t * Math.cos(e),
        y1: t * Math.sin(e),
        x2: c * m - f * y,
        y2: c * y + f * m,
        x3: p * m - d * y,
        y3: p * y + d * m,
        x4: t * Math.cos(n),
        y4: t * Math.sin(n)
      };
    },
        B = function B(t) {
      return 180 * t / Math.PI;
    },
        y = function y(t) {
      return t * Math.PI / 180;
    },
        w = function w(t, e, n, r, i, o) {
      var a = t + .5 * (n - t),
          s = e + .5 * (r - e),
          l = i + .5 * (n - i),
          h = o + .5 * (r - o),
          u = Math.min(t, i, a, l),
          c = Math.max(t, i, a, l),
          f = Math.min(e, o, s, h),
          p = Math.max(e, o, s, h);
      return new E(u, f, c - u, p - f);
    },
        b = function b(t, e, n, r, i, o, a, s) {
      for (var l, h, u, c, f, p, d, g, m, y, v, w, b, x = n - t, N = r - e, L = i - n, A = o - r, S = a - i, _ = s - o, F = 0; F < 41; F++) {
        g = (p = (h = t + (l = F / 40) * x) + l * ((c = n + l * L) - h)) + l * (c + l * (i + l * S - c) - p), m = (d = (u = e + l * N) + l * ((f = r + l * A) - u)) + l * (f + l * (o + l * _ - f) - d), b = 0 == F ? (w = y = g, v = m) : (y = Math.min(y, g), v = Math.min(v, m), w = Math.max(w, g), Math.max(b, m));
      }

      return new E(Math.round(y), Math.round(v), Math.round(w - y), Math.round(b - v));
    },
        j = function j(t, e) {
      var n = t || 0;
      Object.defineProperty(this, "x", {
        enumerable: !0,
        get: function get() {
          return n;
        },
        set: function set(t) {
          isNaN(t) || (n = parseFloat(t));
        }
      });
      var r = e || 0;
      Object.defineProperty(this, "y", {
        enumerable: !0,
        get: function get() {
          return r;
        },
        set: function set(t) {
          isNaN(t) || (r = parseFloat(t));
        }
      });
      var i = "pt";
      return Object.defineProperty(this, "type", {
        enumerable: !0,
        get: function get() {
          return i;
        },
        set: function set(t) {
          i = t.toString();
        }
      }), this;
    },
        E = function E(t, e, n, r) {
      j.call(this, t, e), this.type = "rect";
      var i = n || 0;
      Object.defineProperty(this, "w", {
        enumerable: !0,
        get: function get() {
          return i;
        },
        set: function set(t) {
          isNaN(t) || (i = parseFloat(t));
        }
      });
      var o = r || 0;
      return Object.defineProperty(this, "h", {
        enumerable: !0,
        get: function get() {
          return o;
        },
        set: function set(t) {
          isNaN(t) || (o = parseFloat(t));
        }
      }), this;
    },
        M = function M(t, e, n, r, i, o) {
      var a = [];
      return Object.defineProperty(this, "sx", {
        get: function get() {
          return a[0];
        },
        set: function set(t) {
          a[0] = Math.round(1e5 * t) / 1e5;
        }
      }), Object.defineProperty(this, "shy", {
        get: function get() {
          return a[1];
        },
        set: function set(t) {
          a[1] = Math.round(1e5 * t) / 1e5;
        }
      }), Object.defineProperty(this, "shx", {
        get: function get() {
          return a[2];
        },
        set: function set(t) {
          a[2] = Math.round(1e5 * t) / 1e5;
        }
      }), Object.defineProperty(this, "sy", {
        get: function get() {
          return a[3];
        },
        set: function set(t) {
          a[3] = Math.round(1e5 * t) / 1e5;
        }
      }), Object.defineProperty(this, "tx", {
        get: function get() {
          return a[4];
        },
        set: function set(t) {
          a[4] = Math.round(1e5 * t) / 1e5;
        }
      }), Object.defineProperty(this, "ty", {
        get: function get() {
          return a[5];
        },
        set: function set(t) {
          a[5] = Math.round(1e5 * t) / 1e5;
        }
      }), Object.defineProperty(this, "rotation", {
        get: function get() {
          return Math.atan2(this.shx, this.sx);
        }
      }), Object.defineProperty(this, "scaleX", {
        get: function get() {
          return this.decompose().scale.sx;
        }
      }), Object.defineProperty(this, "scaleY", {
        get: function get() {
          return this.decompose().scale.sy;
        }
      }), Object.defineProperty(this, "isIdentity", {
        get: function get() {
          return 1 === this.sx && 0 === this.shy && 0 === this.shx && 1 === this.sy && 0 === this.tx && 0 === this.ty;
        }
      }), this.sx = isNaN(t) ? 1 : t, this.shy = isNaN(e) ? 0 : e, this.shx = isNaN(n) ? 0 : n, this.sy = isNaN(r) ? 1 : r, this.tx = isNaN(i) ? 0 : i, this.ty = isNaN(o) ? 0 : o, this;
    };

    M.prototype.multiply = function (t) {
      var e = t.sx * this.sx + t.shy * this.shx,
          n = t.sx * this.shy + t.shy * this.sy,
          r = t.shx * this.sx + t.sy * this.shx,
          i = t.shx * this.shy + t.sy * this.sy,
          o = t.tx * this.sx + t.ty * this.shx + this.tx,
          a = t.tx * this.shy + t.ty * this.sy + this.ty;
      return new M(e, n, r, i, o, a);
    }, M.prototype.decompose = function () {
      var t = this.sx,
          e = this.shy,
          n = this.shx,
          r = this.sy,
          i = this.tx,
          o = this.ty,
          a = Math.sqrt(t * t + e * e),
          s = (t /= a) * n + (e /= a) * r;
      n -= t * s, r -= e * s;
      var l = Math.sqrt(n * n + r * r);
      return s /= l, t * (r /= l) < e * (n /= l) && (t = -t, e = -e, s = -s, a = -a), {
        scale: new M(a, 0, 0, l, 0, 0),
        translate: new M(1, 0, 0, 1, i, o),
        rotate: new M(t, e, -e, t, 0, 0),
        skew: new M(1, 0, s, 1, 0, 0)
      };
    }, M.prototype.applyToPoint = function (t) {
      var e = t.x * this.sx + t.y * this.shx + this.tx,
          n = t.x * this.shy + t.y * this.sy + this.ty;
      return new j(e, n);
    }, M.prototype.applyToRectangle = function (t) {
      var e = this.applyToPoint(t),
          n = this.applyToPoint(new j(t.x + t.w, t.y + t.h));
      return new E(e.x, e.y, n.x - e.x, n.y - e.y);
    }, M.prototype.clone = function () {
      var t = this.sx,
          e = this.shy,
          n = this.shx,
          r = this.sy,
          i = this.tx,
          o = this.ty;
      return new M(t, e, n, r, i, o);
    };
  }(lt.API, "undefined" != typeof self && self || "undefined" != typeof window && window || "undefined" != typeof global && global || Function('return typeof this === "object" && this.content')() || Function("return this")()),
  /**
     * jsPDF filters PlugIn
     * Copyright (c) 2014 Aras Abbasi 
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  a = lt.API, o = function o(t) {
    var r, e, n, i, o, a, s, l, h, u;

    for (/[^\x00-\xFF]/.test(t), e = [], n = 0, i = (t += r = "\0\0\0\0".slice(t.length % 4 || 4)).length; n < i; n += 4) {
      0 !== (o = (t.charCodeAt(n) << 24) + (t.charCodeAt(n + 1) << 16) + (t.charCodeAt(n + 2) << 8) + t.charCodeAt(n + 3)) ? (a = (o = ((o = ((o = ((o = (o - (u = o % 85)) / 85) - (h = o % 85)) / 85) - (l = o % 85)) / 85) - (s = o % 85)) / 85) % 85, e.push(a + 33, s + 33, l + 33, h + 33, u + 33)) : e.push(122);
    }

    return function (t, e) {
      for (var n = r.length; 0 < n; n--) {
        t.pop();
      }
    }(e), String.fromCharCode.apply(String, e) + "~>";
  }, s = function s(t) {
    var r,
        e,
        n,
        i,
        o,
        a = String,
        s = "length",
        l = "charCodeAt",
        h = "slice",
        u = "replace";

    for (t[h](-2), t = t[h](0, -2)[u](/\s/g, "")[u]("z", "!!!!!"), n = [], i = 0, o = (t += r = "uuuuu"[h](t[s] % 5 || 5))[s]; i < o; i += 5) {
      e = 52200625 * (t[l](i) - 33) + 614125 * (t[l](i + 1) - 33) + 7225 * (t[l](i + 2) - 33) + 85 * (t[l](i + 3) - 33) + (t[l](i + 4) - 33), n.push(255 & e >> 24, 255 & e >> 16, 255 & e >> 8, 255 & e);
    }

    return function (t, e) {
      for (var n = r[s]; 0 < n; n--) {
        t.pop();
      }
    }(n), a.fromCharCode.apply(a, n);
  }, h = function h(t) {
    for (var e = "", n = 0; n < t.length; n += 1) {
      e += ("0" + t.charCodeAt(n).toString(16)).slice(-2);
    }

    return e += ">";
  }, u = function u(t) {
    var e = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t = t.replace(/\s/g, "")).indexOf(">") && (t = t.substr(0, t.indexOf(">"))), t.length % 2 && (t += "0"), !1 === e.test(t)) return "";

    for (var n = "", r = 0; r < t.length; r += 2) {
      n += String.fromCharCode("0x" + (t[r] + t[r + 1]));
    }

    return n;
  }, c = function c(t, e) {
    e = Object.assign({
      predictor: 1,
      colors: 1,
      bitsPerComponent: 8,
      columns: 1
    }, e);

    for (var n, r, i = [], o = t.length; o--;) {
      i[o] = t.charCodeAt(o);
    }

    return n = a.adler32cs.from(t), (r = new Deflater(6)).append(new Uint8Array(i)), t = r.flush(), (i = new Uint8Array(t.length + 6)).set(new Uint8Array([120, 156])), i.set(t, 2), i.set(new Uint8Array([255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255]), t.length + 2), t = String.fromCharCode.apply(null, i);
  }, a.processDataByFilters = function (t, e) {
    var n = 0,
        r = t || "",
        i = [];

    for ("string" == typeof (e = e || []) && (e = [e]), n = 0; n < e.length; n += 1) {
      switch (e[n]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          r = s(r), i.push("/ASCII85Encode");
          break;

        case "ASCII85Encode":
        case "/ASCII85Encode":
          r = o(r), i.push("/ASCII85Decode");
          break;

        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          r = u(r), i.push("/ASCIIHexEncode");
          break;

        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          r = h(r), i.push("/ASCIIHexDecode");
          break;

        case "FlateEncode":
        case "/FlateEncode":
          r = c(r), i.push("/FlateDecode");
          break;

        default:
          throw 'The filter: "' + e[n] + '" is not implemented';
      }
    }

    return {
      data: r,
      reverseChain: i.reverse().join(" ")
    };
  }, (
  /**
     * jsPDF fileloading PlugIn
     * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  r = lt.API).loadFile = function (t, e, n) {
    var r;
    e = e || !0, n = n || function () {};

    try {
      r = function (t, e, n) {
        var r = new XMLHttpRequest(),
            i = [],
            o = 0,
            a = function a(t) {
          var e = t.length,
              n = String.fromCharCode;

          for (o = 0; o < e; o += 1) {
            i.push(n(255 & t.charCodeAt(o)));
          }

          return i.join("");
        };

        if (r.open("GET", t, !e), r.overrideMimeType("text/plain; charset=x-user-defined"), !1 === e && (r.onload = function () {
          return a(this.responseText);
        }), r.send(null), 200 === r.status) return e ? a(r.responseText) : void 0;
        console.warn('Unable to load file "' + t + '"');
      }(t, e);
    } catch (t) {
      r = void 0;
    }

    return r;
  }, r.loadImageFile = r.loadFile,
  /**
     * Copyright (c) 2018 Erik Koopmans
     * Released under the MIT License.
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  i = lt.API, f = "undefined" != typeof window && window || "undefined" != typeof global && global, g = function g(t) {
    var e = se(t);
    return "undefined" === e ? "undefined" : "string" === e || t instanceof String ? "string" : "number" === e || t instanceof Number ? "number" : "function" === e || t instanceof Function ? "function" : t && t.constructor === Array ? "array" : t && 1 === t.nodeType ? "element" : "object" === e ? "object" : "unknown";
  }, m = function m(t, e) {
    var n = document.createElement(t);

    if (e.className && (n.className = e.className), e.innerHTML) {
      n.innerHTML = e.innerHTML;

      for (var r = n.getElementsByTagName("script"), i = r.length; 0 < i--; null) {
        r[i].parentNode.removeChild(r[i]);
      }
    }

    for (var o in e.style) {
      n.style[o] = e.style[o];
    }

    return n;
  }, (((y = function t(e) {
    var n = Object.assign(t.convert(Promise.resolve()), JSON.parse(JSON.stringify(t.template))),
        r = t.convert(Promise.resolve(), n);
    return r = (r = r.setProgress(1, t, 1, [t])).set(e);
  }).prototype = Object.create(Promise.prototype)).constructor = y).convert = function (t, e) {
    return t.__proto__ = e || y.prototype, t;
  }, y.template = {
    prop: {
      src: null,
      container: null,
      overlay: null,
      canvas: null,
      img: null,
      pdf: null,
      pageSize: null,
      callback: function callback() {}
    },
    progress: {
      val: 0,
      state: null,
      n: 0,
      stack: []
    },
    opt: {
      filename: "file.pdf",
      margin: [0, 0, 0, 0],
      enableLinks: !0,
      x: 0,
      y: 0,
      html2canvas: {},
      jsPDF: {}
    }
  }, y.prototype.from = function (t, e) {
    return this.then(function () {
      switch (e = e || function (t) {
        switch (g(t)) {
          case "string":
            return "string";

          case "element":
            return "canvas" === t.nodeName.toLowerCase ? "canvas" : "element";

          default:
            return "unknown";
        }
      }(t)) {
        case "string":
          return this.set({
            src: m("div", {
              innerHTML: t
            })
          });

        case "element":
          return this.set({
            src: t
          });

        case "canvas":
          return this.set({
            canvas: t
          });

        case "img":
          return this.set({
            img: t
          });

        default:
          return this.error("Unknown source type.");
      }
    });
  }, y.prototype.to = function (t) {
    switch (t) {
      case "container":
        return this.toContainer();

      case "canvas":
        return this.toCanvas();

      case "img":
        return this.toImg();

      case "pdf":
        return this.toPdf();

      default:
        return this.error("Invalid target.");
    }
  }, y.prototype.toContainer = function () {
    return this.thenList([function () {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function () {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function () {
      var t = {
        position: "relative",
        display: "inline-block",
        width: Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) + "px",
        left: 0,
        right: 0,
        top: 0,
        margin: "auto",
        backgroundColor: "white"
      },
          e = function t(e, n) {
        for (var r = 3 === e.nodeType ? document.createTextNode(e.nodeValue) : e.cloneNode(!1), i = e.firstChild; i; i = i.nextSibling) {
          !0 !== n && 1 === i.nodeType && "SCRIPT" === i.nodeName || r.appendChild(t(i, n));
        }

        return 1 === e.nodeType && ("CANVAS" === e.nodeName ? (r.width = e.width, r.height = e.height, r.getContext("2d").drawImage(e, 0, 0)) : "TEXTAREA" !== e.nodeName && "SELECT" !== e.nodeName || (r.value = e.value), r.addEventListener("load", function () {
          r.scrollTop = e.scrollTop, r.scrollLeft = e.scrollLeft;
        }, !0)), r;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);

      "BODY" === e.tagName && (t.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = m("div", {
        className: "html2pdf__overlay",
        style: {
          position: "fixed",
          overflow: "hidden",
          zIndex: 1e3,
          left: "-100000px",
          right: 0,
          bottom: 0,
          top: 0
        }
      }), this.prop.container = m("div", {
        className: "html2pdf__container",
        style: t
      }), this.prop.container.appendChild(e), this.prop.container.firstChild.appendChild(m("div", {
        style: {
          clear: "both",
          border: "0 none transparent",
          margin: 0,
          padding: 0,
          height: 0
        }
      })), this.prop.container.style["float"] = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, y.prototype.toCanvas = function () {
    var t = [function () {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t).then(function () {
      var t = Object.assign({}, this.opt.html2canvas);
      if (delete t.onrendered, this.isHtml2CanvasLoaded()) return html2canvas(this.prop.container, t);
    }).then(function (t) {
      (this.opt.html2canvas.onrendered || function () {})(t), this.prop.canvas = t, document.body.removeChild(this.prop.overlay);
    });
  }, y.prototype.toContext2d = function () {
    var t = [function () {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t).then(function () {
      var t = this.opt.jsPDF,
          e = Object.assign({
        async: !0,
        allowTaint: !0,
        backgroundColor: "#ffffff",
        imageTimeout: 15e3,
        logging: !0,
        proxy: null,
        removeContainer: !0,
        foreignObjectRendering: !1,
        useCORS: !1
      }, this.opt.html2canvas);
      if (delete e.onrendered, t.context2d.autoPaging = !0, t.context2d.posX = this.opt.x, t.context2d.posY = this.opt.y, e.windowHeight = e.windowHeight || 0, e.windowHeight = 0 == e.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : e.windowHeight, this.isHtml2CanvasLoaded()) return html2canvas(this.prop.container, e);
    }).then(function (t) {
      (this.opt.html2canvas.onrendered || function () {})(t), this.prop.canvas = t, document.body.removeChild(this.prop.overlay);
    });
  }, y.prototype.toImg = function () {
    return this.thenList([function () {
      return this.prop.canvas || this.toCanvas();
    }]).then(function () {
      var t = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t;
    });
  }, y.prototype.toPdf = function () {
    return this.thenList([function () {
      return this.toContext2d();
    }]).then(function () {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, y.prototype.output = function (t, e, n) {
    return "img" === (n = n || "pdf").toLowerCase() || "image" === n.toLowerCase() ? this.outputImg(t, e) : this.outputPdf(t, e);
  }, y.prototype.outputPdf = function (t, e) {
    return this.thenList([function () {
      return this.prop.pdf || this.toPdf();
    }]).then(function () {
      return this.prop.pdf.output(t, e);
    });
  }, y.prototype.outputImg = function (t, e) {
    return this.thenList([function () {
      return this.prop.img || this.toImg();
    }]).then(function () {
      switch (t) {
        case void 0:
        case "img":
          return this.prop.img;

        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;

        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;

        default:
          throw 'Image output type "' + t + '" is not supported.';
      }
    });
  }, y.prototype.isHtml2CanvasLoaded = function () {
    var t = void 0 !== f.html2canvas;
    return t || console.error("html2canvas not loaded."), t;
  }, y.prototype.save = function (t) {
    if (this.isHtml2CanvasLoaded()) return this.thenList([function () {
      return this.prop.pdf || this.toPdf();
    }]).set(t ? {
      filename: t
    } : null).then(function () {
      this.prop.pdf.save(this.opt.filename);
    });
  }, y.prototype.doCallback = function (t) {
    if (this.isHtml2CanvasLoaded()) return this.thenList([function () {
      return this.prop.pdf || this.toPdf();
    }]).then(function () {
      this.prop.callback(this.prop.pdf);
    });
  }, y.prototype.set = function (e) {
    if ("object" !== g(e)) return this;
    var t = Object.keys(e || {}).map(function (t) {
      if (t in y.template.prop) return function () {
        this.prop[t] = e[t];
      };

      switch (t) {
        case "margin":
          return this.setMargin.bind(this, e.margin);

        case "jsPDF":
          return function () {
            return this.opt.jsPDF = e.jsPDF, this.setPageSize();
          };

        case "pageSize":
          return this.setPageSize.bind(this, e.pageSize);

        default:
          return function () {
            this.opt[t] = e[t];
          };
      }
    }, this);
    return this.then(function () {
      return this.thenList(t);
    });
  }, y.prototype.get = function (e, n) {
    return this.then(function () {
      var t = e in y.template.prop ? this.prop[e] : this.opt[e];
      return n ? n(t) : t;
    });
  }, y.prototype.setMargin = function (t) {
    return this.then(function () {
      switch (g(t)) {
        case "number":
          t = [t, t, t, t];

        case "array":
          if (2 === t.length && (t = [t[0], t[1], t[0], t[1]]), 4 === t.length) break;

        default:
          return this.error("Invalid margin array.");
      }

      this.opt.margin = t;
    }).then(this.setPageSize);
  }, y.prototype.setPageSize = function (t) {
    function e(t, e) {
      return Math.floor(t * e / 72 * 96);
    }

    return this.then(function () {
      (t = t || lt.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t.inner = {
        width: t.width - this.opt.margin[1] - this.opt.margin[3],
        height: t.height - this.opt.margin[0] - this.opt.margin[2]
      }, t.inner.px = {
        width: e(t.inner.width, t.k),
        height: e(t.inner.height, t.k)
      }, t.inner.ratio = t.inner.height / t.inner.width), this.prop.pageSize = t;
    });
  }, y.prototype.setProgress = function (t, e, n, r) {
    return null != t && (this.progress.val = t), null != e && (this.progress.state = e), null != n && (this.progress.n = n), null != r && (this.progress.stack = r), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, y.prototype.updateProgress = function (t, e, n, r) {
    return this.setProgress(t ? this.progress.val + t : null, e || null, n ? this.progress.n + n : null, r ? this.progress.stack.concat(r) : null);
  }, y.prototype.then = function (t, e) {
    var n = this;
    return this.thenCore(t, e, function (e, t) {
      return n.updateProgress(null, null, 1, [e]), Promise.prototype.then.call(this, function (t) {
        return n.updateProgress(null, e), t;
      }).then(e, t).then(function (t) {
        return n.updateProgress(1), t;
      });
    });
  }, y.prototype.thenCore = function (t, e, n) {
    n = n || Promise.prototype.then;
    var r = this;
    t && (t = t.bind(r)), e && (e = e.bind(r));
    var i = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? r : y.convert(Object.assign({}, r), Promise.prototype),
        o = n.call(i, t, e);
    return y.convert(o, r.__proto__);
  }, y.prototype.thenExternal = function (t, e) {
    return Promise.prototype.then.call(this, t, e);
  }, y.prototype.thenList = function (t) {
    var e = this;
    return t.forEach(function (t) {
      e = e.thenCore(t);
    }), e;
  }, y.prototype["catch"] = function (t) {
    t && (t = t.bind(this));
    var e = Promise.prototype["catch"].call(this, t);
    return y.convert(e, this);
  }, y.prototype.catchExternal = function (t) {
    return Promise.prototype["catch"].call(this, t);
  }, y.prototype.error = function (t) {
    return this.then(function () {
      throw new Error(t);
    });
  }, y.prototype.using = y.prototype.set, y.prototype.saveAs = y.prototype.save, y.prototype["export"] = y.prototype.output, y.prototype.run = y.prototype.then, lt.getPageSize = function (t, e, n) {
    if ("object" === se(t)) {
      var r = t;
      t = r.orientation, e = r.unit || e, n = r.format || n;
    }

    e = e || "mm", n = n || "a4", t = ("" + (t || "P")).toLowerCase();
    var i = ("" + n).toLowerCase(),
        o = {
      a0: [2383.94, 3370.39],
      a1: [1683.78, 2383.94],
      a2: [1190.55, 1683.78],
      a3: [841.89, 1190.55],
      a4: [595.28, 841.89],
      a5: [419.53, 595.28],
      a6: [297.64, 419.53],
      a7: [209.76, 297.64],
      a8: [147.4, 209.76],
      a9: [104.88, 147.4],
      a10: [73.7, 104.88],
      b0: [2834.65, 4008.19],
      b1: [2004.09, 2834.65],
      b2: [1417.32, 2004.09],
      b3: [1000.63, 1417.32],
      b4: [708.66, 1000.63],
      b5: [498.9, 708.66],
      b6: [354.33, 498.9],
      b7: [249.45, 354.33],
      b8: [175.75, 249.45],
      b9: [124.72, 175.75],
      b10: [87.87, 124.72],
      c0: [2599.37, 3676.54],
      c1: [1836.85, 2599.37],
      c2: [1298.27, 1836.85],
      c3: [918.43, 1298.27],
      c4: [649.13, 918.43],
      c5: [459.21, 649.13],
      c6: [323.15, 459.21],
      c7: [229.61, 323.15],
      c8: [161.57, 229.61],
      c9: [113.39, 161.57],
      c10: [79.37, 113.39],
      dl: [311.81, 623.62],
      letter: [612, 792],
      "government-letter": [576, 756],
      legal: [612, 1008],
      "junior-legal": [576, 360],
      ledger: [1224, 792],
      tabloid: [792, 1224],
      "credit-card": [153, 243]
    };

    switch (e) {
      case "pt":
        var a = 1;
        break;

      case "mm":
        a = 72 / 25.4;
        break;

      case "cm":
        a = 72 / 2.54;
        break;

      case "in":
        a = 72;
        break;

      case "px":
        a = .75;
        break;

      case "pc":
      case "em":
        a = 12;
        break;

      case "ex":
        a = 6;
        break;

      default:
        throw "Invalid unit: " + e;
    }

    if (o.hasOwnProperty(i)) var s = o[i][1] / a,
        l = o[i][0] / a;else try {
      s = n[1], l = n[0];
    } catch (t) {
      throw new Error("Invalid format: " + n);
    }

    if ("p" === t || "portrait" === t) {
      if (t = "p", s < l) {
        var h = l;
        l = s, s = h;
      }
    } else {
      if ("l" !== t && "landscape" !== t) throw "Invalid orientation: " + t;
      t = "l", l < s && (h = l, l = s, s = h);
    }

    return {
      width: l,
      height: s,
      unit: e,
      k: a
    };
  }, i.html = function (t, e) {
    (e = e || {}).callback = e.callback || function () {}, e.html2canvas = e.html2canvas || {}, e.html2canvas.canvas = e.html2canvas.canvas || this.canvas, e.jsPDF = e.jsPDF || this, e.jsPDF;
    var n = new y(e);
    return e.worker ? n : n.from(t).doCallback();
  }, lt.API.addJS = function (t) {
    return b = t, this.internal.events.subscribe("postPutResources", function (t) {
      v = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (v + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), w = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + b + ")"), this.internal.out(">>"), this.internal.out("endobj");
    }), this.internal.events.subscribe("putCatalog", function () {
      void 0 !== v && void 0 !== w && this.internal.out("/Names <</JavaScript " + v + " 0 R>>");
    }), this;
  }, (
  /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  x = lt.API).events.push(["postPutResources", function () {
    var t = this,
        e = /^(\d+) 0 obj$/;
    if (0 < this.outline.root.children.length) for (var n = t.outline.render().split(/\r\n/), r = 0; r < n.length; r++) {
      var i = n[r],
          o = e.exec(i);

      if (null != o) {
        var a = o[1];
        t.internal.newObjectDeferredBegin(a, !1);
      }

      t.internal.write(i);
    }

    if (this.outline.createNamedDestinations) {
      var s = this.internal.pages.length,
          l = [];

      for (r = 0; r < s; r++) {
        var h = t.internal.newObject();
        l.push(h);
        var u = t.internal.getPageInfo(r + 1);
        t.internal.write("<< /D[" + u.objId + " 0 R /XYZ null null null]>> endobj");
      }

      var c = t.internal.newObject();

      for (t.internal.write("<< /Names [ "), r = 0; r < l.length; r++) {
        t.internal.write("(page_" + (r + 1) + ")" + l[r] + " 0 R");
      }

      t.internal.write(" ] >>", "endobj"), t.internal.newObject(), t.internal.write("<< /Dests " + c + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), x.events.push(["putCatalog", function () {
    0 < this.outline.root.children.length && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + namesOid + " 0 R"));
  }]), x.events.push(["initialized", function () {
    var a = this;
    a.outline = {
      createNamedDestinations: !1,
      root: {
        children: []
      }
    }, a.outline.add = function (t, e, n) {
      var r = {
        title: e,
        options: n,
        children: []
      };
      return null == t && (t = this.root), t.children.push(r), r;
    }, a.outline.render = function () {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = a, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, a.outline.genIds_r = function (t) {
      t.id = a.internal.newObjectDeferred();

      for (var e = 0; e < t.children.length; e++) {
        this.genIds_r(t.children[e]);
      }
    }, a.outline.renderRoot = function (t) {
      this.objStart(t), this.line("/Type /Outlines"), 0 < t.children.length && (this.line("/First " + this.makeRef(t.children[0])), this.line("/Last " + this.makeRef(t.children[t.children.length - 1]))), this.line("/Count " + this.count_r({
        count: 0
      }, t)), this.objEnd();
    }, a.outline.renderItems = function (t) {
      this.ctx.pdf.internal.getCoordinateString;

      for (var e = this.ctx.pdf.internal.getVerticalCoordinateString, n = 0; n < t.children.length; n++) {
        var r = t.children[n];
        this.objStart(r), this.line("/Title " + this.makeString(r.title)), this.line("/Parent " + this.makeRef(t)), 0 < n && this.line("/Prev " + this.makeRef(t.children[n - 1])), n < t.children.length - 1 && this.line("/Next " + this.makeRef(t.children[n + 1])), 0 < r.children.length && (this.line("/First " + this.makeRef(r.children[0])), this.line("/Last " + this.makeRef(r.children[r.children.length - 1])));
        var i = this.count = this.count_r({
          count: 0
        }, r);

        if (0 < i && this.line("/Count " + i), r.options && r.options.pageNumber) {
          var o = a.internal.getPageInfo(r.options.pageNumber);
          this.line("/Dest [" + o.objId + " 0 R /XYZ 0 " + e(0) + " 0]");
        }

        this.objEnd();
      }

      for (n = 0; n < t.children.length; n++) {
        r = t.children[n], this.renderItems(r);
      }
    }, a.outline.line = function (t) {
      this.ctx.val += t + "\r\n";
    }, a.outline.makeRef = function (t) {
      return t.id + " 0 R";
    }, a.outline.makeString = function (t) {
      return "(" + a.internal.pdfEscape(t) + ")";
    }, a.outline.objStart = function (t) {
      this.ctx.val += "\r\n" + t.id + " 0 obj\r\n<<\r\n";
    }, a.outline.objEnd = function (t) {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, a.outline.count_r = function (t, e) {
      for (var n = 0; n < e.children.length; n++) {
        t.count++, this.count_r(t, e.children[n]);
      }

      return t.count;
    };
  }]),
  /**
     * @license
     * 
     * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
     *
     * 
     * ====================================================================
     */
  I = lt.API, C = function C() {
    var t = "function" == typeof Deflater;
    if (!t) throw new Error("requires deflate.js for compression");
    return t;
  }, B = function B(t, e, n, r) {
    var i = 5,
        o = E;

    switch (r) {
      case I.image_compression.FAST:
        i = 3, o = j;
        break;

      case I.image_compression.MEDIUM:
        i = 6, o = M;
        break;

      case I.image_compression.SLOW:
        i = 9, o = O;
    }

    t = A(t, e, n, o);
    var a = new Uint8Array(N(i)),
        s = L(t),
        l = new Deflater(i),
        h = l.append(t),
        u = l.flush(),
        c = a.length + h.length + u.length,
        f = new Uint8Array(c + 4);
    return f.set(a), f.set(h, a.length), f.set(u, a.length + h.length), f[c++] = s >>> 24 & 255, f[c++] = s >>> 16 & 255, f[c++] = s >>> 8 & 255, f[c++] = 255 & s, I.arrayBufferToBinaryString(f);
  }, N = function N(t, e) {
    var n = Math.LOG2E * Math.log(32768) - 8 << 4 | 8,
        r = n << 8;
    return r |= Math.min(3, (e - 1 & 255) >> 1) << 6, r |= 0, [n, 255 & (r += 31 - r % 31)];
  }, L = function L(t, e) {
    for (var n, r = 1, i = 0, o = t.length, a = 0; 0 < o;) {
      for (o -= n = e < o ? e : o; i += r += t[a++], --n;) {
        ;
      }

      r %= 65521, i %= 65521;
    }

    return (i << 16 | r) >>> 0;
  }, A = function A(t, e, n, r) {
    for (var i, o, a, s = t.length / e, l = new Uint8Array(t.length + s), h = T(), u = 0; u < s; u++) {
      if (a = u * e, i = t.subarray(a, a + e), r) l.set(r(i, n, o), a + u);else {
        for (var c = 0, f = h.length, p = []; c < f; c++) {
          p[c] = h[c](i, n, o);
        }

        var d = R(p.concat());
        l.set(p[d], a + u);
      }
      o = i;
    }

    return l;
  }, S = function S(t, e, n) {
    var r = Array.apply([], t);
    return r.unshift(0), r;
  }, j = function j(t, e, n) {
    var r,
        i = [],
        o = 0,
        a = t.length;

    for (i[0] = 1; o < a; o++) {
      r = t[o - e] || 0, i[o + 1] = t[o] - r + 256 & 255;
    }

    return i;
  }, E = function E(t, e, n) {
    var r,
        i = [],
        o = 0,
        a = t.length;

    for (i[0] = 2; o < a; o++) {
      r = n && n[o] || 0, i[o + 1] = t[o] - r + 256 & 255;
    }

    return i;
  }, M = function M(t, e, n) {
    var r,
        i,
        o = [],
        a = 0,
        s = t.length;

    for (o[0] = 3; a < s; a++) {
      r = t[a - e] || 0, i = n && n[a] || 0, o[a + 1] = t[a] + 256 - (r + i >>> 1) & 255;
    }

    return o;
  }, O = function O(t, e, n) {
    var r,
        i,
        o,
        a,
        s = [],
        l = 0,
        h = t.length;

    for (s[0] = 4; l < h; l++) {
      r = t[l - e] || 0, i = n && n[l] || 0, o = n && n[l - e] || 0, a = q(r, i, o), s[l + 1] = t[l] - a + 256 & 255;
    }

    return s;
  }, q = function q(t, e, n) {
    var r = t + e - n,
        i = Math.abs(r - t),
        o = Math.abs(r - e),
        a = Math.abs(r - n);
    return i <= o && i <= a ? t : o <= a ? e : n;
  }, T = function T() {
    return [S, j, E, M, O];
  }, R = function R(t) {
    for (var e, n, r, i = 0, o = t.length; i < o;) {
      ((e = D(t[i].slice(1))) < n || !n) && (n = e, r = i), i++;
    }

    return r;
  }, D = function D(t) {
    for (var e = 0, n = t.length, r = 0; e < n;) {
      r += Math.abs(t[e++]);
    }

    return r;
  }, I.processPNG = function (t, e, n, r, i) {
    var o,
        a,
        s,
        l,
        h,
        u,
        c = this.color_spaces.DEVICE_RGB,
        f = this.decode.FLATE_DECODE,
        p = 8;

    if (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t)) {
      if ("function" != typeof PNG || "function" != typeof kt) throw new Error("PNG support requires png.js and zlib.js");

      if (t = (o = new PNG(t)).imgData, p = o.bits, c = o.colorSpace, l = o.colors, -1 !== [4, 6].indexOf(o.colorType)) {
        if (8 === o.bits) for (var d, g = (_ = 32 == o.pixelBitlength ? new Uint32Array(o.decodePixels().buffer) : 16 == o.pixelBitlength ? new Uint16Array(o.decodePixels().buffer) : new Uint8Array(o.decodePixels().buffer)).length, m = new Uint8Array(g * o.colors), y = new Uint8Array(g), v = o.pixelBitlength - o.bits, w = 0, b = 0; w < g; w++) {
          for (x = _[w], d = 0; d < v;) {
            m[b++] = x >>> d & 255, d += o.bits;
          }

          y[w] = x >>> d & 255;
        }

        if (16 === o.bits) {
          g = (_ = new Uint32Array(o.decodePixels().buffer)).length, m = new Uint8Array(g * (32 / o.pixelBitlength) * o.colors), y = new Uint8Array(g * (32 / o.pixelBitlength));

          for (var x, N = 1 < o.colors, L = b = w = 0; w < g;) {
            x = _[w++], m[b++] = x >>> 0 & 255, N && (m[b++] = x >>> 16 & 255, x = _[w++], m[b++] = x >>> 0 & 255), y[L++] = x >>> 16 & 255;
          }

          p = 8;
        }

        r !== I.image_compression.NONE && C() ? (t = B(m, o.width * o.colors, o.colors, r), u = B(y, o.width, 1, r)) : (t = m, u = y, f = null);
      }

      if (3 === o.colorType && (c = this.color_spaces.INDEXED, h = o.palette, o.transparency.indexed)) {
        var A = o.transparency.indexed,
            S = 0;

        for (w = 0, g = A.length; w < g; ++w) {
          S += A[w];
        }

        if ((S /= 255) == g - 1 && -1 !== A.indexOf(0)) s = [A.indexOf(0)];else if (S !== g) {
          var _ = o.decodePixels();

          for (y = new Uint8Array(_.length), w = 0, g = _.length; w < g; w++) {
            y[w] = A[_[w]];
          }

          u = B(y, o.width, 1);
        }
      }

      var F = function (t) {
        var e;

        switch (t) {
          case I.image_compression.FAST:
            e = 11;
            break;

          case I.image_compression.MEDIUM:
            e = 13;
            break;

          case I.image_compression.SLOW:
            e = 14;
            break;

          default:
            e = 12;
        }

        return e;
      }(r);

      return a = f === this.decode.FLATE_DECODE ? "/Predictor " + F + " /Colors " + l + " /BitsPerComponent " + p + " /Columns " + o.width : "/Colors " + l + " /BitsPerComponent " + p + " /Columns " + o.width, (this.isArrayBuffer(t) || this.isArrayBufferView(t)) && (t = this.arrayBufferToBinaryString(t)), (u && this.isArrayBuffer(u) || this.isArrayBufferView(u)) && (u = this.arrayBufferToBinaryString(u)), this.createImageInfo(t, o.width, o.height, c, p, f, e, n, a, s, h, u, F);
    }

    throw new Error("Unsupported PNG image data, try using JPEG instead.");
  }, (
  /**
     * @license
     * Copyright (c) 2017 Aras Abbasi 
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  U = lt.API).processGIF89A = function (t, e, n, r, i) {
    var o = new At(t),
        a = o.width,
        s = o.height,
        l = [];
    o.decodeAndBlitFrameRGBA(0, l);
    var h = {
      data: l,
      width: a,
      height: s
    },
        u = new _t(100).encode(h, 100);
    return U.processJPEG.call(this, u, e, n, r);
  }, U.processGIF87A = U.processGIF89A, (
  /**
     * Copyright (c) 2018 Aras Abbasi 
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  z = lt.API).processBMP = function (t, e, n, r, i) {
    var o = new Ft(t, !1),
        a = o.width,
        s = o.height,
        l = {
      data: o.getData(),
      width: a,
      height: s
    },
        h = new _t(100).encode(l, 100);
    return z.processJPEG.call(this, h, e, n, r);
  }, lt.API.setLanguage = function (t) {
    return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), void 0 !== {
      af: "Afrikaans",
      sq: "Albanian",
      ar: "Arabic (Standard)",
      "ar-DZ": "Arabic (Algeria)",
      "ar-BH": "Arabic (Bahrain)",
      "ar-EG": "Arabic (Egypt)",
      "ar-IQ": "Arabic (Iraq)",
      "ar-JO": "Arabic (Jordan)",
      "ar-KW": "Arabic (Kuwait)",
      "ar-LB": "Arabic (Lebanon)",
      "ar-LY": "Arabic (Libya)",
      "ar-MA": "Arabic (Morocco)",
      "ar-OM": "Arabic (Oman)",
      "ar-QA": "Arabic (Qatar)",
      "ar-SA": "Arabic (Saudi Arabia)",
      "ar-SY": "Arabic (Syria)",
      "ar-TN": "Arabic (Tunisia)",
      "ar-AE": "Arabic (U.A.E.)",
      "ar-YE": "Arabic (Yemen)",
      an: "Aragonese",
      hy: "Armenian",
      as: "Assamese",
      ast: "Asturian",
      az: "Azerbaijani",
      eu: "Basque",
      be: "Belarusian",
      bn: "Bengali",
      bs: "Bosnian",
      br: "Breton",
      bg: "Bulgarian",
      my: "Burmese",
      ca: "Catalan",
      ch: "Chamorro",
      ce: "Chechen",
      zh: "Chinese",
      "zh-HK": "Chinese (Hong Kong)",
      "zh-CN": "Chinese (PRC)",
      "zh-SG": "Chinese (Singapore)",
      "zh-TW": "Chinese (Taiwan)",
      cv: "Chuvash",
      co: "Corsican",
      cr: "Cree",
      hr: "Croatian",
      cs: "Czech",
      da: "Danish",
      nl: "Dutch (Standard)",
      "nl-BE": "Dutch (Belgian)",
      en: "English",
      "en-AU": "English (Australia)",
      "en-BZ": "English (Belize)",
      "en-CA": "English (Canada)",
      "en-IE": "English (Ireland)",
      "en-JM": "English (Jamaica)",
      "en-NZ": "English (New Zealand)",
      "en-PH": "English (Philippines)",
      "en-ZA": "English (South Africa)",
      "en-TT": "English (Trinidad & Tobago)",
      "en-GB": "English (United Kingdom)",
      "en-US": "English (United States)",
      "en-ZW": "English (Zimbabwe)",
      eo: "Esperanto",
      et: "Estonian",
      fo: "Faeroese",
      fj: "Fijian",
      fi: "Finnish",
      fr: "French (Standard)",
      "fr-BE": "French (Belgium)",
      "fr-CA": "French (Canada)",
      "fr-FR": "French (France)",
      "fr-LU": "French (Luxembourg)",
      "fr-MC": "French (Monaco)",
      "fr-CH": "French (Switzerland)",
      fy: "Frisian",
      fur: "Friulian",
      gd: "Gaelic (Scots)",
      "gd-IE": "Gaelic (Irish)",
      gl: "Galacian",
      ka: "Georgian",
      de: "German (Standard)",
      "de-AT": "German (Austria)",
      "de-DE": "German (Germany)",
      "de-LI": "German (Liechtenstein)",
      "de-LU": "German (Luxembourg)",
      "de-CH": "German (Switzerland)",
      el: "Greek",
      gu: "Gujurati",
      ht: "Haitian",
      he: "Hebrew",
      hi: "Hindi",
      hu: "Hungarian",
      is: "Icelandic",
      id: "Indonesian",
      iu: "Inuktitut",
      ga: "Irish",
      it: "Italian (Standard)",
      "it-CH": "Italian (Switzerland)",
      ja: "Japanese",
      kn: "Kannada",
      ks: "Kashmiri",
      kk: "Kazakh",
      km: "Khmer",
      ky: "Kirghiz",
      tlh: "Klingon",
      ko: "Korean",
      "ko-KP": "Korean (North Korea)",
      "ko-KR": "Korean (South Korea)",
      la: "Latin",
      lv: "Latvian",
      lt: "Lithuanian",
      lb: "Luxembourgish",
      mk: "FYRO Macedonian",
      ms: "Malay",
      ml: "Malayalam",
      mt: "Maltese",
      mi: "Maori",
      mr: "Marathi",
      mo: "Moldavian",
      nv: "Navajo",
      ng: "Ndonga",
      ne: "Nepali",
      no: "Norwegian",
      nb: "Norwegian (Bokmal)",
      nn: "Norwegian (Nynorsk)",
      oc: "Occitan",
      or: "Oriya",
      om: "Oromo",
      fa: "Persian",
      "fa-IR": "Persian/Iran",
      pl: "Polish",
      pt: "Portuguese",
      "pt-BR": "Portuguese (Brazil)",
      pa: "Punjabi",
      "pa-IN": "Punjabi (India)",
      "pa-PK": "Punjabi (Pakistan)",
      qu: "Quechua",
      rm: "Rhaeto-Romanic",
      ro: "Romanian",
      "ro-MO": "Romanian (Moldavia)",
      ru: "Russian",
      "ru-MO": "Russian (Moldavia)",
      sz: "Sami (Lappish)",
      sg: "Sango",
      sa: "Sanskrit",
      sc: "Sardinian",
      sd: "Sindhi",
      si: "Singhalese",
      sr: "Serbian",
      sk: "Slovak",
      sl: "Slovenian",
      so: "Somani",
      sb: "Sorbian",
      es: "Spanish",
      "es-AR": "Spanish (Argentina)",
      "es-BO": "Spanish (Bolivia)",
      "es-CL": "Spanish (Chile)",
      "es-CO": "Spanish (Colombia)",
      "es-CR": "Spanish (Costa Rica)",
      "es-DO": "Spanish (Dominican Republic)",
      "es-EC": "Spanish (Ecuador)",
      "es-SV": "Spanish (El Salvador)",
      "es-GT": "Spanish (Guatemala)",
      "es-HN": "Spanish (Honduras)",
      "es-MX": "Spanish (Mexico)",
      "es-NI": "Spanish (Nicaragua)",
      "es-PA": "Spanish (Panama)",
      "es-PY": "Spanish (Paraguay)",
      "es-PE": "Spanish (Peru)",
      "es-PR": "Spanish (Puerto Rico)",
      "es-ES": "Spanish (Spain)",
      "es-UY": "Spanish (Uruguay)",
      "es-VE": "Spanish (Venezuela)",
      sx: "Sutu",
      sw: "Swahili",
      sv: "Swedish",
      "sv-FI": "Swedish (Finland)",
      "sv-SV": "Swedish (Sweden)",
      ta: "Tamil",
      tt: "Tatar",
      te: "Teluga",
      th: "Thai",
      tig: "Tigre",
      ts: "Tsonga",
      tn: "Tswana",
      tr: "Turkish",
      tk: "Turkmen",
      uk: "Ukrainian",
      hsb: "Upper Sorbian",
      ur: "Urdu",
      ve: "Venda",
      vi: "Vietnamese",
      vo: "Volapuk",
      wa: "Walloon",
      cy: "Welsh",
      xh: "Xhosa",
      ji: "Yiddish",
      zu: "Zulu"
    }[t] && (this.internal.languageSettings.languageCode = t, !1 === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function () {
      this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
    }), this.internal.languageSettings.isSubscribed = !0)), this;
  },
  /** @license
     * MIT license.
     * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
     *               2014 Diego Casorran, https://github.com/diegocr
     *
     * 
     * ====================================================================
     */
  H = lt.API, W = H.getCharWidthsArray = function (t, e) {
    var n,
        r,
        i,
        o = (e = e || {}).font || this.internal.getFont(),
        a = e.fontSize || this.internal.getFontSize(),
        s = e.charSpace || this.internal.getCharSpace(),
        l = e.widths ? e.widths : o.metadata.Unicode.widths,
        h = l.fof ? l.fof : 1,
        u = e.kerning ? e.kerning : o.metadata.Unicode.kerning,
        c = u.fof ? u.fof : 1,
        f = 0,
        p = l[0] || h,
        d = [];

    for (n = 0, r = t.length; n < r; n++) {
      i = t.charCodeAt(n), "function" == typeof o.metadata.widthOfString ? d.push((o.metadata.widthOfGlyph(o.metadata.characterToGlyph(i)) + s * (1e3 / a) || 0) / 1e3) : d.push((l[i] || p) / h + (u[i] && u[i][f] || 0) / c), f = i;
    }

    return d;
  }, V = H.getArraySum = function (t) {
    for (var e = t.length, n = 0; e;) {
      n += t[--e];
    }

    return n;
  }, G = H.getStringUnitWidth = function (t, e) {
    var n = (e = e || {}).fontSize || this.internal.getFontSize(),
        r = e.font || this.internal.getFont(),
        i = e.charSpace || this.internal.getCharSpace();
    return "function" == typeof r.metadata.widthOfString ? r.metadata.widthOfString(t, n, i) / n : V(W.apply(this, arguments));
  }, Y = function Y(t, e, n, r) {
    for (var i = [], o = 0, a = t.length, s = 0; o !== a && s + e[o] < n;) {
      s += e[o], o++;
    }

    i.push(t.slice(0, o));
    var l = o;

    for (s = 0; o !== a;) {
      s + e[o] > r && (i.push(t.slice(l, o)), s = 0, l = o), s += e[o], o++;
    }

    return l !== o && i.push(t.slice(l, o)), i;
  }, J = function J(t, e, n) {
    n || (n = {});
    var r,
        i,
        o,
        a,
        s,
        l,
        h = [],
        u = [h],
        c = n.textIndent || 0,
        f = 0,
        p = 0,
        d = t.split(" "),
        g = W.apply(this, [" ", n])[0];

    if (l = -1 === n.lineIndent ? d[0].length + 2 : n.lineIndent || 0) {
      var m = Array(l).join(" "),
          y = [];
      d.map(function (t) {
        1 < (t = t.split(/\s*\n/)).length ? y = y.concat(t.map(function (t, e) {
          return (e && t.length ? "\n" : "") + t;
        })) : y.push(t[0]);
      }), d = y, l = G.apply(this, [m, n]);
    }

    for (o = 0, a = d.length; o < a; o++) {
      var v = 0;

      if (r = d[o], l && "\n" == r[0] && (r = r.substr(1), v = 1), i = W.apply(this, [r, n]), e < c + f + (p = V(i)) || v) {
        if (e < p) {
          for (s = Y.apply(this, [r, i, e - (c + f), e]), h.push(s.shift()), h = [s.pop()]; s.length;) {
            u.push([s.shift()]);
          }

          p = V(i.slice(r.length - (h[0] ? h[0].length : 0)));
        } else h = [r];

        u.push(h), c = p + l, f = g;
      } else h.push(r), c += f + p, f = g;
    }

    if (l) var w = function w(t, e) {
      return (e ? m : "") + t.join(" ");
    };else w = function w(t) {
      return t.join(" ");
    };
    return u.map(w);
  }, H.splitTextToSize = function (t, e, n) {
    var r,
        i = (n = n || {}).fontSize || this.internal.getFontSize(),
        o = function (t) {
      var e = {
        0: 1
      },
          n = {};
      if (t.widths && t.kerning) return {
        widths: t.widths,
        kerning: t.kerning
      };
      var r = this.internal.getFont(t.fontName, t.fontStyle),
          i = "Unicode";
      return r.metadata[i] ? {
        widths: r.metadata[i].widths || e,
        kerning: r.metadata[i].kerning || n
      } : {
        font: r.metadata,
        fontSize: this.internal.getFontSize(),
        charSpace: this.internal.getCharSpace()
      };
    }.call(this, n);

    r = Array.isArray(t) ? t : t.split(/\r?\n/);
    var a = 1 * this.internal.scaleFactor * e / i;
    o.textIndent = n.textIndent ? 1 * n.textIndent * this.internal.scaleFactor / i : 0, o.lineIndent = n.lineIndent;
    var s,
        l,
        h = [];

    for (s = 0, l = r.length; s < l; s++) {
      h = h.concat(J.apply(this, [r[s], a, o]));
    }

    return h;
  },
  /** @license
     jsPDF standard_fonts_metrics plugin
     * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
     * MIT license.
     * 
     * ====================================================================
     */
  X = lt.API, Z = {
    codePages: ["WinAnsiEncoding"],
    WinAnsiEncoding: (K = function K(t) {
      for (var e = "klmnopqrstuvwxyz", n = {}, r = 0; r < e.length; r++) {
        n[e[r]] = "0123456789abcdef"[r];
      }

      var i,
          o,
          a,
          s,
          l,
          h = {},
          u = 1,
          c = h,
          f = [],
          p = "",
          d = "",
          g = t.length - 1;

      for (r = 1; r != g;) {
        l = t[r], r += 1, "'" == l ? o = o ? (s = o.join(""), i) : [] : o ? o.push(l) : "{" == l ? (f.push([c, s]), c = {}, s = i) : "}" == l ? ((a = f.pop())[0][a[1]] = c, s = i, c = a[0]) : "-" == l ? u = -1 : s === i ? n.hasOwnProperty(l) ? (p += n[l], s = parseInt(p, 16) * u, u = 1, p = "") : p += l : n.hasOwnProperty(l) ? (d += n[l], c[s] = parseInt(d, 16) * u, u = 1, s = i, d = "") : d += l;
      }

      return h;
    })("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
  }, Q = {
    Unicode: {
      Courier: Z,
      "Courier-Bold": Z,
      "Courier-BoldOblique": Z,
      "Courier-Oblique": Z,
      Helvetica: Z,
      "Helvetica-Bold": Z,
      "Helvetica-BoldOblique": Z,
      "Helvetica-Oblique": Z,
      "Times-Roman": Z,
      "Times-Bold": Z,
      "Times-BoldItalic": Z,
      "Times-Italic": Z
    }
  }, $ = {
    Unicode: {
      "Courier-Oblique": K("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-BoldItalic": K("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
      "Helvetica-Bold": K("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
      Courier: K("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Courier-BoldOblique": K("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-Bold": K("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
      Symbol: K("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),
      Helvetica: K("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
      "Helvetica-BoldOblique": K("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
      ZapfDingbats: K("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),
      "Courier-Bold": K("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-Italic": K("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
      "Times-Roman": K("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
      "Helvetica-Oblique": K("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
    }
  }, X.events.push(["addFont", function (t) {
    var e,
        n,
        r,
        i = t.font,
        o = "Unicode";
    (e = $[o][i.postScriptName]) && ((n = i.metadata[o] ? i.metadata[o] : i.metadata[o] = {}).widths = e.widths, n.kerning = e.kerning), (r = Q[o][i.postScriptName]) && ((n = i.metadata[o] ? i.metadata[o] : i.metadata[o] = {}).encoding = r).codePages && r.codePages.length && (i.encoding = r.codePages[0]);
  }]),
  /**
     * @license
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
  tt = lt, "undefined" != typeof self && self || "undefined" != typeof global && global || "undefined" != typeof window && window || Function("return this")(), tt.API.events.push(["addFont", function (t) {
    var e = t.font,
        n = t.instance;

    if (void 0 !== n && n.existsFileInVFS(e.postScriptName)) {
      var r = n.getFileFromVFS(e.postScriptName);
      if ("string" != typeof r) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + e.postScriptName + "').");
      e.metadata = tt.API.TTFFont.open(e.postScriptName, e.fontName, r, e.encoding), e.metadata.Unicode = e.metadata.Unicode || {
        encoding: {},
        kerning: {},
        widths: []
      }, e.metadata.glyIdsUsed = [0];
    } else if (!1 === e.isStandardFont) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + e.postScriptName + "').");
  }]), (
  /** @license
     * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
     * 
     * 
     * ====================================================================
     */
  et = lt.API).addSvg = function (t, e, n, r, i) {
    if (void 0 === e || void 0 === n) throw new Error("addSVG needs values for 'x' and 'y'");

    function o(t) {
      for (var e = parseFloat(t[1]), n = parseFloat(t[2]), r = [], i = 3, o = t.length; i < o;) {
        "c" === t[i] ? (r.push([parseFloat(t[i + 1]), parseFloat(t[i + 2]), parseFloat(t[i + 3]), parseFloat(t[i + 4]), parseFloat(t[i + 5]), parseFloat(t[i + 6])]), i += 7) : "l" === t[i] ? (r.push([parseFloat(t[i + 1]), parseFloat(t[i + 2])]), i += 3) : i += 1;
      }

      return [e, n, r];
    }

    var a,
        s,
        l,
        h,
        u,
        c,
        f,
        p,
        d = (h = document, p = h.createElement("iframe"), u = ".jsPDF_sillysvg_iframe {display:none;position:absolute;}", (f = (c = h).createElement("style")).type = "text/css", f.styleSheet ? f.styleSheet.cssText = u : f.appendChild(c.createTextNode(u)), c.getElementsByTagName("head")[0].appendChild(f), p.name = "childframe", p.setAttribute("width", 0), p.setAttribute("height", 0), p.setAttribute("frameborder", "0"), p.setAttribute("scrolling", "no"), p.setAttribute("seamless", "seamless"), p.setAttribute("class", "jsPDF_sillysvg_iframe"), h.body.appendChild(p), p),
        g = (a = t, (l = ((s = d).contentWindow || s.contentDocument).document).write(a), l.close(), l.getElementsByTagName("svg")[0]),
        m = [1, 1],
        y = parseFloat(g.getAttribute("width")),
        v = parseFloat(g.getAttribute("height"));
    y && v && (r && i ? m = [r / y, i / v] : r ? m = [r / y, r / y] : i && (m = [i / v, i / v]));
    var w,
        b,
        x,
        N,
        L = g.childNodes;

    for (w = 0, b = L.length; w < b; w++) {
      (x = L[w]).tagName && "PATH" === x.tagName.toUpperCase() && ((N = o(x.getAttribute("d").split(" ")))[0] = N[0] * m[0] + e, N[1] = N[1] * m[1] + n, this.lines.call(this, N[2], N[0], N[1], m));
    }

    return this;
  }, et.addSVG = et.addSvg, et.addSvgAsImage = function (t, e, n, r, i, o, a, s) {
    if (isNaN(e) || isNaN(n)) throw console.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(r) || isNaN(i)) throw console.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var l = document.createElement("canvas");
    l.width = r, l.height = i;
    var h = l.getContext("2d");
    return h.fillStyle = "#fff", h.fillRect(0, 0, l.width, l.height), canvg(l, t, {
      ignoreMouse: !0,
      ignoreAnimation: !0,
      ignoreDimensions: !0,
      ignoreClear: !0
    }), this.addImage(l.toDataURL("image/jpeg", 1), e, n, r, i, a, s), this;
  }, lt.API.putTotalPages = function (t) {
    var e,
        n = 0;
    n = parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(t, "g"), this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(t, this.internal.getFont()), "g"), this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));

    for (var r = 1; r <= this.internal.getNumberOfPages(); r++) {
      for (var i = 0; i < this.internal.pages[r].length; i++) {
        this.internal.pages[r][i] = this.internal.pages[r][i].replace(e, n);
      }
    }

    return this;
  }, lt.API.viewerPreferences = function (t, e) {
    var n;
    t = t || {}, e = e || !1;
    var r,
        i,
        o = {
      HideToolbar: {
        defaultValue: !1,
        value: !1,
        type: "boolean",
        explicitSet: !1,
        valueSet: [!0, !1],
        pdfVersion: 1.3
      },
      HideMenubar: {
        defaultValue: !1,
        value: !1,
        type: "boolean",
        explicitSet: !1,
        valueSet: [!0, !1],
        pdfVersion: 1.3
      },
      HideWindowUI: {
        defaultValue: !1,
        value: !1,
        type: "boolean",
        explicitSet: !1,
        valueSet: [!0, !1],
        pdfVersion: 1.3
      },
      FitWindow: {
        defaultValue: !1,
        value: !1,
        type: "boolean",
        explicitSet: !1,
        valueSet: [!0, !1],
        pdfVersion: 1.3
      },
      CenterWindow: {
        defaultValue: !1,
        value: !1,
        type: "boolean",
        explicitSet: !1,
        valueSet: [!0, !1],
        pdfVersion: 1.3
      },
      DisplayDocTitle: {
        defaultValue: !1,
        value: !1,
        type: "boolean",
        explicitSet: !1,
        valueSet: [!0, !1],
        pdfVersion: 1.4
      },
      NonFullScreenPageMode: {
        defaultValue: "UseNone",
        value: "UseNone",
        type: "name",
        explicitSet: !1,
        valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"],
        pdfVersion: 1.3
      },
      Direction: {
        defaultValue: "L2R",
        value: "L2R",
        type: "name",
        explicitSet: !1,
        valueSet: ["L2R", "R2L"],
        pdfVersion: 1.3
      },
      ViewArea: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: !1,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      ViewClip: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: !1,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintArea: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: !1,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintClip: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: !1,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintScaling: {
        defaultValue: "AppDefault",
        value: "AppDefault",
        type: "name",
        explicitSet: !1,
        valueSet: ["AppDefault", "None"],
        pdfVersion: 1.6
      },
      Duplex: {
        defaultValue: "",
        value: "none",
        type: "name",
        explicitSet: !1,
        valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"],
        pdfVersion: 1.7
      },
      PickTrayByPDFSize: {
        defaultValue: !1,
        value: !1,
        type: "boolean",
        explicitSet: !1,
        valueSet: [!0, !1],
        pdfVersion: 1.7
      },
      PrintPageRange: {
        defaultValue: "",
        value: "",
        type: "array",
        explicitSet: !1,
        valueSet: null,
        pdfVersion: 1.7
      },
      NumCopies: {
        defaultValue: 1,
        value: 1,
        type: "integer",
        explicitSet: !1,
        valueSet: null,
        pdfVersion: 1.7
      }
    },
        a = Object.keys(o),
        s = [],
        l = 0,
        h = 0,
        u = 0,
        c = !0;

    function f(t, e) {
      var n,
          r = !1;

      for (n = 0; n < t.length; n += 1) {
        t[n] === e && (r = !0);
      }

      return r;
    }

    if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(o)), this.internal.viewerpreferences.isSubscribed = !1), n = this.internal.viewerpreferences.configuration, "reset" === t || !0 === e) {
      var p = a.length;

      for (u = 0; u < p; u += 1) {
        n[a[u]].value = n[a[u]].defaultValue, n[a[u]].explicitSet = !1;
      }
    }

    if ("object" === se(t)) for (r in t) {
      if (i = t[r], f(a, r) && void 0 !== i) {
        if ("boolean" === n[r].type && "boolean" == typeof i) n[r].value = i;else if ("name" === n[r].type && f(n[r].valueSet, i)) n[r].value = i;else if ("integer" === n[r].type && Number.isInteger(i)) n[r].value = i;else if ("array" === n[r].type) {
          for (l = 0; l < i.length; l += 1) {
            if (c = !0, 1 === i[l].length && "number" == typeof i[l][0]) s.push(String(i[l] - 1));else if (1 < i[l].length) {
              for (h = 0; h < i[l].length; h += 1) {
                "number" != typeof i[l][h] && (c = !1);
              }

              !0 === c && s.push([i[l][0] - 1, i[l][1] - 1].join(" "));
            }
          }

          n[r].value = "[" + s.join(" ") + "]";
        } else n[r].value = n[r].defaultValue;
        n[r].explicitSet = !0;
      }
    }
    return !1 === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function () {
      var t,
          e = [];

      for (t in n) {
        !0 === n[t].explicitSet && ("name" === n[t].type ? e.push("/" + t + " /" + n[t].value) : e.push("/" + t + " " + n[t].value));
      }

      0 !== e.length && this.internal.write("/ViewerPreferences\n<<\n" + e.join("\n") + "\n>>");
    }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = n, this;
  },
  /** ==================================================================== 
     * jsPDF XMP metadata plugin
     * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
     * 
     * 
     * ====================================================================
     */
  nt = lt.API, ot = it = rt = "", nt.addMetadata = function (t, e) {
    return it = e || "http://jspdf.default.namespaceuri/", rt = t, this.internal.events.subscribe("postPutResources", function () {
      if (rt) {
        var t = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + it + '"><jspdf:metadata>',
            e = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')),
            n = unescape(encodeURIComponent(t)),
            r = unescape(encodeURIComponent(rt)),
            i = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")),
            o = unescape(encodeURIComponent("</x:xmpmeta>")),
            a = n.length + r.length + i.length + e.length + o.length;
        ot = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + a + " >>"), this.internal.write("stream"), this.internal.write(e + n + r + i + o), this.internal.write("endstream"), this.internal.write("endobj");
      } else ot = "";
    }), this.internal.events.subscribe("putCatalog", function () {
      ot && this.internal.write("/Metadata " + ot + " 0 R");
    }), this;
  }, function (f, t) {
    var e = f.API;

    var m = e.pdfEscape16 = function (t, e) {
      for (var n, r = e.metadata.Unicode.widths, i = ["", "0", "00", "000", "0000"], o = [""], a = 0, s = t.length; a < s; ++a) {
        if (n = e.metadata.characterToGlyph(t.charCodeAt(a)), e.metadata.glyIdsUsed.push(n), e.metadata.toUnicode[n] = t.charCodeAt(a), -1 == r.indexOf(n) && (r.push(n), r.push([parseInt(e.metadata.widthOfGlyph(n), 10)])), "0" == n) return o.join("");
        n = n.toString(16), o.push(i[4 - n.length], n);
      }

      return o.join("");
    },
        p = function p(t) {
      var e, n, r, i, o, a, s;

      for (o = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", r = [], a = 0, s = (n = Object.keys(t).sort(function (t, e) {
        return t - e;
      })).length; a < s; a++) {
        e = n[a], 100 <= r.length && (o += "\n" + r.length + " beginbfchar\n" + r.join("\n") + "\nendbfchar", r = []), i = ("0000" + t[e].toString(16)).slice(-4), e = ("0000" + (+e).toString(16)).slice(-4), r.push("<" + e + "><" + i + ">");
      }

      return r.length && (o += "\n" + r.length + " beginbfchar\n" + r.join("\n") + "\nendbfchar\n"), o += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    };

    e.events.push(["putFont", function (t) {
      !function (t, e, n, r) {
        if (t.metadata instanceof f.API.TTFFont && "Identity-H" === t.encoding) {
          for (var i = t.metadata.Unicode.widths, o = t.metadata.subset.encode(t.metadata.glyIdsUsed, 1), a = "", s = 0; s < o.length; s++) {
            a += String.fromCharCode(o[s]);
          }

          var l = n();
          r({
            data: a,
            addLength1: !0
          }), e("endobj");
          var h = n();
          r({
            data: p(t.metadata.toUnicode),
            addLength1: !0
          }), e("endobj");
          var u = n();
          e("<<"), e("/Type /FontDescriptor"), e("/FontName /" + t.fontName), e("/FontFile2 " + l + " 0 R"), e("/FontBBox " + f.API.PDFObject.convert(t.metadata.bbox)), e("/Flags " + t.metadata.flags), e("/StemV " + t.metadata.stemV), e("/ItalicAngle " + t.metadata.italicAngle), e("/Ascent " + t.metadata.ascender), e("/Descent " + t.metadata.decender), e("/CapHeight " + t.metadata.capHeight), e(">>"), e("endobj");
          var c = n();
          e("<<"), e("/Type /Font"), e("/BaseFont /" + t.fontName), e("/FontDescriptor " + u + " 0 R"), e("/W " + f.API.PDFObject.convert(i)), e("/CIDToGIDMap /Identity"), e("/DW 1000"), e("/Subtype /CIDFontType2"), e("/CIDSystemInfo"), e("<<"), e("/Supplement 0"), e("/Registry (Adobe)"), e("/Ordering (" + t.encoding + ")"), e(">>"), e(">>"), e("endobj"), t.objectNumber = n(), e("<<"), e("/Type /Font"), e("/Subtype /Type0"), e("/ToUnicode " + h + " 0 R"), e("/BaseFont /" + t.fontName), e("/Encoding /" + t.encoding), e("/DescendantFonts [" + c + " 0 R]"), e(">>"), e("endobj"), t.isAlreadyPutted = !0;
        }
      }(t.font, t.out, t.newObject, t.putStream);
    }]);
    e.events.push(["putFont", function (t) {
      !function (t, e, n, r) {
        if (t.metadata instanceof f.API.TTFFont && "WinAnsiEncoding" === t.encoding) {
          t.metadata.Unicode.widths;

          for (var i = t.metadata.rawData, o = "", a = 0; a < i.length; a++) {
            o += String.fromCharCode(i[a]);
          }

          var s = n();
          r({
            data: o,
            addLength1: !0
          }), e("endobj");
          var l = n();
          r({
            data: p(t.metadata.toUnicode),
            addLength1: !0
          }), e("endobj");
          var h = n();

          for (e("<<"), e("/Descent " + t.metadata.decender), e("/CapHeight " + t.metadata.capHeight), e("/StemV " + t.metadata.stemV), e("/Type /FontDescriptor"), e("/FontFile2 " + s + " 0 R"), e("/Flags 96"), e("/FontBBox " + f.API.PDFObject.convert(t.metadata.bbox)), e("/FontName /" + t.fontName), e("/ItalicAngle " + t.metadata.italicAngle), e("/Ascent " + t.metadata.ascender), e(">>"), e("endobj"), t.objectNumber = n(), a = 0; a < t.metadata.hmtx.widths.length; a++) {
            t.metadata.hmtx.widths[a] = parseInt(t.metadata.hmtx.widths[a] * (1e3 / t.metadata.head.unitsPerEm));
          }

          e("<</Subtype/TrueType/Type/Font/ToUnicode " + l + " 0 R/BaseFont/" + t.fontName + "/FontDescriptor " + h + " 0 R/Encoding/" + t.encoding + " /FirstChar 29 /LastChar 255 /Widths " + f.API.PDFObject.convert(t.metadata.hmtx.widths) + ">>"), e("endobj"), t.isAlreadyPutted = !0;
        }
      }(t.font, t.out, t.newObject, t.putStream);
    }]);

    var h = function h(t) {
      var e,
          n,
          r = t.text || "",
          i = t.x,
          o = t.y,
          a = t.options || {},
          s = t.mutex || {},
          l = s.pdfEscape,
          h = s.activeFontKey,
          u = s.fonts,
          c = (s.activeFontSize, ""),
          f = 0,
          p = "",
          d = u[n = h].encoding;
      if ("Identity-H" !== u[n].encoding) return {
        text: r,
        x: i,
        y: o,
        options: a,
        mutex: s
      };

      for (p = r, n = h, "[object Array]" === Object.prototype.toString.call(r) && (p = r[0]), f = 0; f < p.length; f += 1) {
        u[n].metadata.hasOwnProperty("cmap") && (e = u[n].metadata.cmap.unicode.codeMap[p[f].charCodeAt(0)]), e ? c += p[f] : p[f].charCodeAt(0) < 256 && u[n].metadata.hasOwnProperty("Unicode") ? c += p[f] : c += "";
      }

      var g = "";
      return parseInt(n.slice(1)) < 14 || "WinAnsiEncoding" === d ? g = function (t) {
        for (var e = "", n = 0; n < t.length; n++) {
          e += "" + t.charCodeAt(n).toString(16);
        }

        return e;
      }(l(c, n)) : "Identity-H" === d && (g = m(c, u[n])), s.isHex = !0, {
        text: g,
        x: i,
        y: o,
        options: a,
        mutex: s
      };
    };

    e.events.push(["postProcessText", function (t) {
      var e = t.text || "",
          n = t.x,
          r = t.y,
          i = t.options,
          o = t.mutex,
          a = (i.lang, []),
          s = {
        text: e,
        x: n,
        y: r,
        options: i,
        mutex: o
      };

      if ("[object Array]" === Object.prototype.toString.call(e)) {
        var l = 0;

        for (l = 0; l < e.length; l += 1) {
          "[object Array]" === Object.prototype.toString.call(e[l]) && 3 === e[l].length ? a.push([h(Object.assign({}, s, {
            text: e[l][0]
          })).text, e[l][1], e[l][2]]) : a.push(h(Object.assign({}, s, {
            text: e[l]
          })).text);
        }

        t.text = a;
      } else t.text = h(Object.assign({}, s, {
        text: e
      })).text;
    }]);
  }(lt, "undefined" != typeof self && self || "undefined" != typeof global && global || "undefined" != typeof window && window || Function("return this")()), at = lt.API, st = function st(t) {
    return void 0 !== t && (void 0 === t.vFS && (t.vFS = {}), !0);
  }, at.existsFileInVFS = function (t) {
    return !!st(this.internal) && void 0 !== this.internal.vFS[t];
  }, at.addFileToVFS = function (t, e) {
    return st(this.internal), this.internal.vFS[t] = e, this;
  }, at.getFileFromVFS = function (t) {
    return st(this.internal), void 0 !== this.internal.vFS[t] ? this.internal.vFS[t] : null;
  }, lt.API.addHTML = function (t, d, g, s, m) {
    if ("undefined" == typeof html2canvas && "undefined" == typeof rasterizeHTML) throw new Error("You need either https://github.com/niklasvh/html2canvas or https://github.com/cburgmer/rasterizeHTML.js");
    "number" != typeof d && (s = d, m = g), "function" == typeof s && (m = s, s = null), "function" != typeof m && (m = function m() {});
    var e = this.internal,
        y = e.scaleFactor,
        v = e.pageSize.getWidth(),
        w = e.pageSize.getHeight();
    if ((s = s || {}).onrendered = function (l) {
      d = parseInt(d) || 0, g = parseInt(g) || 0;
      var t = s.dim || {},
          h = Object.assign({
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        useFor: "content"
      }, s.margin),
          e = t.h || Math.min(w, l.height / y),
          u = t.w || Math.min(v, l.width / y) - d,
          c = s.format || "JPEG",
          f = s.imageCompression || "SLOW";

      if (l.height > w - h.top - h.bottom && s.pagesplit) {
        var p = function p(t, e, n, r, i) {
          var o = document.createElement("canvas");
          o.height = i, o.width = r;
          var a = o.getContext("2d");
          return a.mozImageSmoothingEnabled = !1, a.webkitImageSmoothingEnabled = !1, a.msImageSmoothingEnabled = !1, a.imageSmoothingEnabled = !1, a.fillStyle = s.backgroundColor || "#ffffff", a.fillRect(0, 0, r, i), a.drawImage(t, e, n, r, i, 0, 0, r, i), o;
        },
            n = function () {
          for (var t, e, n = 0, r = 0, i = {}, o = !1;;) {
            var a;
            if (r = 0, i.top = 0 !== n ? h.top : g, i.left = 0 !== n ? h.left : d, o = (v - h.left - h.right) * y < l.width, "content" === h.useFor ? 0 === n ? (t = Math.min((v - h.left) * y, l.width), e = Math.min((w - h.top) * y, l.height - n)) : (t = Math.min(v * y, l.width), e = Math.min(w * y, l.height - n), i.top = 0) : (t = Math.min((v - h.left - h.right) * y, l.width), e = Math.min((w - h.bottom - h.top) * y, l.height - n)), o) for (;;) {
              "content" === h.useFor && (0 === r ? t = Math.min((v - h.left) * y, l.width) : (t = Math.min(v * y, l.width - r), i.left = 0));
              var s = [a = p(l, r, n, t, e), i.left, i.top, a.width / y, a.height / y, c, null, f];
              if (this.addImage.apply(this, s), (r += t) >= l.width) break;
              this.addPage();
            } else s = [a = p(l, 0, n, t, e), i.left, i.top, a.width / y, a.height / y, c, null, f], this.addImage.apply(this, s);
            if ((n += e) >= l.height) break;
            this.addPage();
          }

          m(u, n, null, s);
        }.bind(this);

        if ("CANVAS" === l.nodeName) {
          var r = new Image();
          r.onload = n, r.src = l.toDataURL("image/png"), l = r;
        } else n();
      } else {
        var i = Math.random().toString(35),
            o = [l, d, g, u, e, c, i, f];
        this.addImage.apply(this, o), m(u, e, i, o);
      }
    }.bind(this), "undefined" != typeof html2canvas && !s.rstz) return html2canvas(t, s);
    if ("undefined" == typeof rasterizeHTML) return null;
    var n = "drawDocument";
    return "string" == typeof t && (n = /^http/.test(t) ? "drawURL" : "drawHTML"), s.width = s.width || v * y, rasterizeHTML[n](t, void 0, s).then(function (t) {
      s.onrendered(t.image);
    }, function (t) {
      m(null, t);
    });
  },
  /**
     * jsPDF fromHTML plugin. BETA stage. API subject to change. Needs browser
     * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
     *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
     *               2014 Diego Casorran, https://github.com/diegocr
     *               2014 Daniel Husar, https://github.com/danielhusar
     *               2014 Wolfgang Gassler, https://github.com/woolfg
     *               2014 Steven Spungin, https://github.com/flamenco
     *
     * @license
     * 
     * ====================================================================
     */
  function (t) {
    var P, _k, i, a, s, l, h, u, I, w, f, c, p, n, C, B, d, g, m, j;

    P = function () {
      return function (t) {
        return e.prototype = t, new e();
      };

      function e() {}
    }(), w = function w(t) {
      var e, n, r, i, o, a, s;

      for (n = 0, r = t.length, e = void 0, a = i = !1; !i && n !== r;) {
        (e = t[n] = t[n].trimLeft()) && (i = !0), n++;
      }

      for (n = r - 1; r && !a && -1 !== n;) {
        (e = t[n] = t[n].trimRight()) && (a = !0), n--;
      }

      for (o = /\s+$/g, s = !0, n = 0; n !== r;) {
        "\u2028" != t[n] && (e = t[n].replace(/\s+/g, " "), s && (e = e.trimLeft()), e && (s = o.test(e)), t[n] = e), n++;
      }

      return t;
    }, c = function c(t) {
      var e, n, r;

      for (e = void 0, n = (r = t.split(",")).shift(); !e && n;) {
        e = i[n.trim().toLowerCase()], n = r.shift();
      }

      return e;
    }, p = function p(t) {
      var e;
      return -1 < (t = "auto" === t ? "0px" : t).indexOf("em") && !isNaN(Number(t.replace("em", ""))) && (t = 18.719 * Number(t.replace("em", "")) + "px"), -1 < t.indexOf("pt") && !isNaN(Number(t.replace("pt", ""))) && (t = 1.333 * Number(t.replace("pt", "")) + "px"), void 0, 16, (e = n[t]) ? e : void 0 !== (e = {
        "xx-small": 9,
        "x-small": 11,
        small: 13,
        medium: 16,
        large: 19,
        "x-large": 23,
        "xx-large": 28,
        auto: 0
      }[t]) ? n[t] = e / 16 : (e = parseFloat(t)) ? n[t] = e / 16 : (e = t.match(/([\d\.]+)(px)/), Array.isArray(e) && 3 === e.length ? n[t] = parseFloat(e[1]) / 16 : n[t] = 1);
    }, I = function I(t) {
      var e, n, r, i, o;
      return o = t, i = document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(o, null) : o.currentStyle ? o.currentStyle : o.style, n = void 0, (e = {})["font-family"] = c((r = function r(t) {
        return t = t.replace(/-\D/g, function (t) {
          return t.charAt(1).toUpperCase();
        }), i[t];
      })("font-family")) || "times", e["font-style"] = a[r("font-style")] || "normal", e["text-align"] = s[r("text-align")] || "left", "bold" === (n = l[r("font-weight")] || "normal") && ("normal" === e["font-style"] ? e["font-style"] = n : e["font-style"] = n + e["font-style"]), e["font-size"] = p(r("font-size")) || 1, e["line-height"] = p(r("line-height")) || 1, e.display = "inline" === r("display") ? "inline" : "block", n = "block" === e.display, e["margin-top"] = n && p(r("margin-top")) || 0, e["margin-bottom"] = n && p(r("margin-bottom")) || 0, e["padding-top"] = n && p(r("padding-top")) || 0, e["padding-bottom"] = n && p(r("padding-bottom")) || 0, e["margin-left"] = n && p(r("margin-left")) || 0, e["margin-right"] = n && p(r("margin-right")) || 0, e["padding-left"] = n && p(r("padding-left")) || 0, e["padding-right"] = n && p(r("padding-right")) || 0, e["page-break-before"] = r("page-break-before") || "auto", e["float"] = h[r("cssFloat")] || "none", e.clear = u[r("clear")] || "none", e.color = r("color"), e;
    }, C = function C(t, e, n) {
      var r, i, o, a, s;
      if (o = !1, a = i = void 0, r = n["#" + t.id]) if ("function" == typeof r) o = r(t, e);else for (i = 0, a = r.length; !o && i !== a;) {
        o = r[i](t, e), i++;
      }
      if (r = n[t.nodeName], !o && r) if ("function" == typeof r) o = r(t, e);else for (i = 0, a = r.length; !o && i !== a;) {
        o = r[i](t, e), i++;
      }

      for (s = "string" == typeof t.className ? t.className.split(" ") : [], i = 0; i < s.length; i++) {
        if (r = n["." + s[i]], !o && r) if ("function" == typeof r) o = r(t, e);else for (i = 0, a = r.length; !o && i !== a;) {
          o = r[i](t, e), i++;
        }
      }

      return o;
    }, j = function j(t, e) {
      var n, r, i, o, a, s, l, h, u;

      for (n = [], r = [], i = 0, u = t.rows[0].cells.length, l = t.clientWidth; i < u;) {
        h = t.rows[0].cells[i], r[i] = {
          name: h.textContent.toLowerCase().replace(/\s+/g, ""),
          prompt: h.textContent.replace(/\r?\n/g, ""),
          width: h.clientWidth / l * e.pdf.internal.pageSize.getWidth()
        }, i++;
      }

      for (i = 1; i < t.rows.length;) {
        for (s = t.rows[i], a = {}, o = 0; o < s.cells.length;) {
          a[r[o].name] = s.cells[o].textContent.replace(/\r?\n/g, ""), o++;
        }

        n.push(a), i++;
      }

      return {
        rows: n,
        headers: r
      };
    };
    var E = {
      SCRIPT: 1,
      STYLE: 1,
      NOSCRIPT: 1,
      OBJECT: 1,
      EMBED: 1,
      SELECT: 1
    },
        M = 1;
    _k = function k(t, i, e) {
      var n, r, o, a, s, l, h, u;

      for (r = t.childNodes, n = void 0, (s = "block" === (o = I(t)).display) && (i.setBlockBoundary(), i.setBlockStyle(o)), a = 0, l = r.length; a < l;) {
        if ("object" === se(n = r[a])) {
          if (i.executeWatchFunctions(n), 1 === n.nodeType && "HEADER" === n.nodeName) {
            var c = n,
                f = i.pdf.margins_doc.top;
            i.pdf.internal.events.subscribe("addPage", function (t) {
              i.y = f, _k(c, i, e), i.pdf.margins_doc.top = i.y + 10, i.y += 10;
            }, !1);
          }

          if (8 === n.nodeType && "#comment" === n.nodeName) ~n.textContent.indexOf("ADD_PAGE") && (i.pdf.addPage(), i.y = i.pdf.margins_doc.top);else if (1 !== n.nodeType || E[n.nodeName]) {
            if (3 === n.nodeType) {
              var p = n.nodeValue;
              if (n.nodeValue && "LI" === n.parentNode.nodeName) if ("OL" === n.parentNode.parentNode.nodeName) p = M++ + ". " + p;else {
                var d = o["font-size"],
                    g = (3 - .75 * d) * i.pdf.internal.scaleFactor,
                    m = .75 * d * i.pdf.internal.scaleFactor,
                    y = 1.74 * d / i.pdf.internal.scaleFactor;

                u = function u(t, e) {
                  this.pdf.circle(t + g, e + m, y, "FD");
                };
              }
              16 & n.ownerDocument.body.compareDocumentPosition(n) && i.addText(p, o);
            } else "string" == typeof n && i.addText(n, o);
          } else {
            var v;

            if ("IMG" === n.nodeName) {
              var w = n.getAttribute("src");
              v = B[i.pdf.sHashCode(w) || w];
            }

            if (v) {
              i.pdf.internal.pageSize.getHeight() - i.pdf.margins_doc.bottom < i.y + n.height && i.y > i.pdf.margins_doc.top && (i.pdf.addPage(), i.y = i.pdf.margins_doc.top, i.executeWatchFunctions(n));

              var b = I(n),
                  x = i.x,
                  N = 12 / i.pdf.internal.scaleFactor,
                  L = (b["margin-left"] + b["padding-left"]) * N,
                  A = (b["margin-right"] + b["padding-right"]) * N,
                  S = (b["margin-top"] + b["padding-top"]) * N,
                  _ = (b["margin-bottom"] + b["padding-bottom"]) * N;

              void 0 !== b["float"] && "right" === b["float"] ? x += i.settings.width - n.width - A : x += L, i.pdf.addImage(v, x, i.y + S, n.width, n.height), v = void 0, "right" === b["float"] || "left" === b["float"] ? (i.watchFunctions.push(function (t, e, n, r) {
                return i.y >= e ? (i.x += t, i.settings.width += n, !0) : !!(r && 1 === r.nodeType && !E[r.nodeName] && i.x + r.width > i.pdf.margins_doc.left + i.pdf.margins_doc.width) && (i.x += t, i.y = e, i.settings.width += n, !0);
              }.bind(this, "left" === b["float"] ? -n.width - L - A : 0, i.y + n.height + S + _, n.width)), i.watchFunctions.push(function (t, e, n) {
                return !(i.y < t && e === i.pdf.internal.getNumberOfPages()) || 1 === n.nodeType && "both" === I(n).clear && (i.y = t, !0);
              }.bind(this, i.y + n.height, i.pdf.internal.getNumberOfPages())), i.settings.width -= n.width + L + A, "left" === b["float"] && (i.x += n.width + L + A)) : i.y += n.height + S + _;
            } else if ("TABLE" === n.nodeName) h = j(n, i), i.y += 10, i.pdf.table(i.x, i.y, h.rows, h.headers, {
              autoSize: !1,
              printHeaders: e.printHeaders,
              margins: i.pdf.margins_doc,
              css: I(n)
            }), i.y = i.pdf.lastCellPos.y + i.pdf.lastCellPos.h + 20;else if ("OL" === n.nodeName || "UL" === n.nodeName) M = 1, C(n, i, e) || _k(n, i, e), i.y += 10;else if ("LI" === n.nodeName) {
              var F = i.x;
              i.x += 20 / i.pdf.internal.scaleFactor, i.y += 3, C(n, i, e) || _k(n, i, e), i.x = F;
            } else "BR" === n.nodeName ? (i.y += o["font-size"] * i.pdf.internal.scaleFactor, i.addText("\u2028", P(o))) : C(n, i, e) || _k(n, i, e);
          }
        }

        a++;
      }

      if (e.outY = i.y, s) return i.setBlockBoundary(u);
    }, B = {}, d = function d(t, o, e, n) {
      var a,
          r = t.getElementsByTagName("img"),
          i = r.length,
          s = 0;

      function l() {
        o.pdf.internal.events.publish("imagesLoaded"), n(a);
      }

      function h(e, n, r) {
        if (e) {
          var i = new Image();
          a = ++s, i.crossOrigin = "", i.onerror = i.onload = function () {
            if (i.complete && (0 === i.src.indexOf("data:image/") && (i.width = n || i.width || 0, i.height = r || i.height || 0), i.width + i.height)) {
              var t = o.pdf.sHashCode(e) || e;
              B[t] = B[t] || i;
            }

            --s || l();
          }, i.src = e;
        }
      }

      for (; i--;) {
        h(r[i].getAttribute("src"), r[i].width, r[i].height);
      }

      return s || l();
    }, g = function g(t, o, a) {
      var s = t.getElementsByTagName("footer");

      if (0 < s.length) {
        s = s[0];
        var e = o.pdf.internal.write,
            n = o.y;
        o.pdf.internal.write = function () {}, _k(s, o, a);
        var l = Math.ceil(o.y - n) + 5;
        o.y = n, o.pdf.internal.write = e, o.pdf.margins_doc.bottom += l;

        for (var r = function r(t) {
          var e = void 0 !== t ? t.pageNumber : 1,
              n = o.y;
          o.y = o.pdf.internal.pageSize.getHeight() - o.pdf.margins_doc.bottom, o.pdf.margins_doc.bottom -= l;

          for (var r = s.getElementsByTagName("span"), i = 0; i < r.length; ++i) {
            -1 < (" " + r[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" pageCounter ") && (r[i].innerHTML = e), -1 < (" " + r[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") && (r[i].innerHTML = "###jsPDFVarTotalPages###");
          }

          _k(s, o, a), o.pdf.margins_doc.bottom += l, o.y = n;
        }, i = s.getElementsByTagName("span"), h = 0; h < i.length; ++h) {
          -1 < (" " + i[h].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") && o.pdf.internal.events.subscribe("htmlRenderingFinished", o.pdf.putTotalPages.bind(o.pdf, "###jsPDFVarTotalPages###"), !0);
        }

        o.pdf.internal.events.subscribe("addPage", r, !1), r(), E.FOOTER = 1;
      }
    }, m = function m(t, e, n, r, i, o) {
      if (!e) return !1;
      var a, s, l, h;
      "string" == typeof e || e.parentNode || (e = "" + e.innerHTML), "string" == typeof e && (a = e.replace(/<\/?script[^>]*?>/gi, ""), h = "jsPDFhtmlText" + Date.now().toString() + (1e3 * Math.random()).toFixed(0), (l = document.createElement("div")).style.cssText = "position: absolute !important;clip: rect(1px 1px 1px 1px); /* IE6, IE7 */clip: rect(1px, 1px, 1px, 1px);padding:0 !important;border:0 !important;height: 1px !important;width: 1px !important; top:auto;left:-100px;overflow: hidden;", l.innerHTML = '<iframe style="height:1px;width:1px" name="' + h + '" />', document.body.appendChild(l), (s = window.frames[h]).document.open(), s.document.writeln(a), s.document.close(), e = s.document.body);
      var u,
          c = new f(t, n, r, i);
      return d.call(this, e, c, i.elementHandlers, function (t) {
        g(e, c, i.elementHandlers), _k(e, c, i.elementHandlers), c.pdf.internal.events.publish("htmlRenderingFinished"), u = c.dispose(), "function" == typeof o ? o(u) : t && console.error("jsPDF Warning: rendering issues? provide a callback to fromHTML!");
      }), u || {
        x: c.x,
        y: c.y
      };
    }, (f = function f(t, e, n, r) {
      return this.pdf = t, this.x = e, this.y = n, this.settings = r, this.watchFunctions = [], this.init(), this;
    }).prototype.init = function () {
      return this.paragraph = {
        text: [],
        style: []
      }, this.pdf.internal.write("q");
    }, f.prototype.dispose = function () {
      return this.pdf.internal.write("Q"), {
        x: this.x,
        y: this.y,
        ready: !0
      };
    }, f.prototype.executeWatchFunctions = function (t) {
      var e = !1,
          n = [];

      if (0 < this.watchFunctions.length) {
        for (var r = 0; r < this.watchFunctions.length; ++r) {
          !0 === this.watchFunctions[r](t) ? e = !0 : n.push(this.watchFunctions[r]);
        }

        this.watchFunctions = n;
      }

      return e;
    }, f.prototype.splitFragmentsIntoLines = function (t, e) {
      var n, r, i, o, a, s, l, h, u, c, f, p, d, g;

      for (12, c = this.pdf.internal.scaleFactor, o = {}, s = l = h = g = a = i = u = r = void 0, p = [f = []], n = 0, d = this.settings.width; t.length;) {
        if (a = t.shift(), g = e.shift(), a) if ((i = o[(r = g["font-family"]) + (u = g["font-style"])]) || (i = this.pdf.internal.getFont(r, u).metadata.Unicode, o[r + u] = i), h = {
          widths: i.widths,
          kerning: i.kerning,
          fontSize: 12 * g["font-size"],
          textIndent: n
        }, l = this.pdf.getStringUnitWidth(a, h) * h.fontSize / c, "\u2028" == a) f = [], p.push(f);else if (d < n + l) {
          for (s = this.pdf.splitTextToSize(a, d, h), f.push([s.shift(), g]); s.length;) {
            f = [[s.shift(), g]], p.push(f);
          }

          n = this.pdf.getStringUnitWidth(f[0][0], h) * h.fontSize / c;
        } else f.push([a, g]), n += l;
      }

      if (void 0 !== g["text-align"] && ("center" === g["text-align"] || "right" === g["text-align"] || "justify" === g["text-align"])) for (var m = 0; m < p.length; ++m) {
        var y = this.pdf.getStringUnitWidth(p[m][0][0], h) * h.fontSize / c;
        0 < m && (p[m][0][1] = P(p[m][0][1]));
        var v = d - y;
        if ("right" === g["text-align"]) p[m][0][1]["margin-left"] = v;else if ("center" === g["text-align"]) p[m][0][1]["margin-left"] = v / 2;else if ("justify" === g["text-align"]) {
          var w = p[m][0][0].split(" ").length - 1;
          p[m][0][1]["word-spacing"] = v / w, m === p.length - 1 && (p[m][0][1]["word-spacing"] = 0);
        }
      }
      return p;
    }, f.prototype.RenderTextFragment = function (t, e) {
      var n, r;
      r = 0, this.pdf.internal.pageSize.getHeight() - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize() && (this.pdf.internal.write("ET", "Q"), this.pdf.addPage(), this.y = this.pdf.margins_doc.top, this.pdf.internal.write("q", "BT", this.getPdfColor(e.color), this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td"), r = Math.max(r, e["line-height"], e["font-size"]), this.pdf.internal.write(0, (-12 * r).toFixed(2), "Td")), n = this.pdf.internal.getFont(e["font-family"], e["font-style"]);
      var i = this.getPdfColor(e.color);
      i !== this.lastTextColor && (this.pdf.internal.write(i), this.lastTextColor = i), void 0 !== e["word-spacing"] && 0 < e["word-spacing"] && this.pdf.internal.write(e["word-spacing"].toFixed(2), "Tw"), this.pdf.internal.write("/" + n.id, (12 * e["font-size"]).toFixed(2), "Tf", "(" + this.pdf.internal.pdfEscape(t) + ") Tj"), void 0 !== e["word-spacing"] && this.pdf.internal.write(0, "Tw");
    }, f.prototype.getPdfColor = function (t) {
      var e,
          n,
          r,
          i = /rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+\s*)\)/.exec(t);
      if (null != i) e = parseInt(i[1]), n = parseInt(i[2]), r = parseInt(i[3]);else {
        if ("string" == typeof t && "#" != t.charAt(0)) {
          var o = new RGBColor(t);
          t = o.ok ? o.toHex() : "#000000";
        }

        e = t.substring(1, 3), e = parseInt(e, 16), n = t.substring(3, 5), n = parseInt(n, 16), r = t.substring(5, 7), r = parseInt(r, 16);
      }

      if ("string" == typeof e && /^#[0-9A-Fa-f]{6}$/.test(e)) {
        var a = parseInt(e.substr(1), 16);
        e = a >> 16 & 255, n = a >> 8 & 255, r = 255 & a;
      }

      var s = this.f3;
      return 0 === e && 0 === n && 0 === r || void 0 === n ? s(e / 255) + " g" : [s(e / 255), s(n / 255), s(r / 255), "rg"].join(" ");
    }, f.prototype.f3 = function (t) {
      return t.toFixed(3);
    }, f.prototype.renderParagraph = function (t) {
      var e, n, r, i, o, a, s, l, h, u, c, f, p;

      if (r = w(this.paragraph.text), f = this.paragraph.style, e = this.paragraph.blockstyle, this.paragraph.priorblockstyle || {}, this.paragraph = {
        text: [],
        style: [],
        blockstyle: {},
        priorblockstyle: e
      }, r.join("").trim()) {
        s = this.splitFragmentsIntoLines(r, f), l = a = void 0, n = 12 / this.pdf.internal.scaleFactor, this.priorMarginBottom = this.priorMarginBottom || 0, c = (Math.max((e["margin-top"] || 0) - this.priorMarginBottom, 0) + (e["padding-top"] || 0)) * n, u = ((e["margin-bottom"] || 0) + (e["padding-bottom"] || 0)) * n, this.priorMarginBottom = e["margin-bottom"] || 0, "always" === e["page-break-before"] && (this.pdf.addPage(), this.y = 0, c = ((e["margin-top"] || 0) + (e["padding-top"] || 0)) * n), h = this.pdf.internal.write, o = i = void 0, this.y += c, h("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");

        for (var d = 0; s.length;) {
          for (i = l = 0, o = (a = s.shift()).length; i !== o;) {
            a[i][0].trim() && (l = Math.max(l, a[i][1]["line-height"], a[i][1]["font-size"]), p = 7 * a[i][1]["font-size"]), i++;
          }

          var g = 0,
              m = 0;

          for (void 0 !== a[0][1]["margin-left"] && 0 < a[0][1]["margin-left"] && (g = (m = this.pdf.internal.getCoordinateString(a[0][1]["margin-left"])) - d, d = m), h(g + Math.max(e["margin-left"] || 0, 0) * n, (-12 * l).toFixed(2), "Td"), i = 0, o = a.length; i !== o;) {
            a[i][0] && this.RenderTextFragment(a[i][0], a[i][1]), i++;
          }

          if (this.y += l * n, this.executeWatchFunctions(a[0][1]) && 0 < s.length) {
            var y = [],
                v = [];
            s.forEach(function (t) {
              for (var e = 0, n = t.length; e !== n;) {
                t[e][0] && (y.push(t[e][0] + " "), v.push(t[e][1])), ++e;
              }
            }), s = this.splitFragmentsIntoLines(w(y), v), h("ET", "Q"), h("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
          }
        }

        return t && "function" == typeof t && t.call(this, this.x - 9, this.y - p / 2), h("ET", "Q"), this.y += u;
      }
    }, f.prototype.setBlockBoundary = function (t) {
      return this.renderParagraph(t);
    }, f.prototype.setBlockStyle = function (t) {
      return this.paragraph.blockstyle = t;
    }, f.prototype.addText = function (t, e) {
      return this.paragraph.text.push(t), this.paragraph.style.push(e);
    }, i = {
      helvetica: "helvetica",
      "sans-serif": "helvetica",
      "times new roman": "times",
      serif: "times",
      times: "times",
      monospace: "courier",
      courier: "courier"
    }, l = {
      100: "normal",
      200: "normal",
      300: "normal",
      400: "normal",
      500: "bold",
      600: "bold",
      700: "bold",
      800: "bold",
      900: "bold",
      normal: "normal",
      bold: "bold",
      bolder: "bold",
      lighter: "normal"
    }, a = {
      normal: "normal",
      italic: "italic",
      oblique: "italic"
    }, s = {
      left: "left",
      right: "right",
      center: "center",
      justify: "justify"
    }, h = {
      none: "none",
      right: "right",
      left: "left"
    }, u = {
      none: "none",
      both: "both"
    }, n = {
      normal: 1
    }, t.fromHTML = function (t, e, n, r, i, o) {
      return this.margins_doc = o || {
        top: 0,
        bottom: 0
      }, r || (r = {}), r.elementHandlers || (r.elementHandlers = {}), m(this, t, isNaN(e) ? 4 : e, isNaN(n) ? 4 : n, r, i);
    };
  }(lt.API), lt.API, ("undefined" != typeof window && window || "undefined" != typeof global && global).html2pdf = function (t, a, e) {
    var n = a.canvas;

    if (n) {
      var r, i;

      if ((n.pdf = a).annotations = {
        _nameMap: [],
        createAnnotation: function createAnnotation(t, e) {
          var n,
              r = a.context2d._wrapX(e.left),
              i = a.context2d._wrapY(e.top),
              o = (a.context2d._page(e.top), t.indexOf("#"));

          n = 0 <= o ? {
            name: t.substring(o + 1)
          } : {
            url: t
          }, a.link(r, i, e.right - e.left, e.bottom - e.top, n);
        },
        setName: function setName(t, e) {
          var n = a.context2d._wrapX(e.left),
              r = a.context2d._wrapY(e.top),
              i = a.context2d._page(e.top);

          this._nameMap[t] = {
            page: i,
            x: n,
            y: r
          };
        }
      }, n.annotations = a.annotations, a.context2d._pageBreakAt = function (t) {
        this.pageBreaks.push(t);
      }, a.context2d._gotoPage = function (t) {
        for (; a.internal.getNumberOfPages() < t;) {
          a.addPage();
        }

        a.setPage(t);
      }, "string" == typeof t) {
        t = t.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "");
        var o,
            s,
            l = document.createElement("iframe");
        document.body.appendChild(l), null != (o = l.contentDocument) && null != o || (o = l.contentWindow.document), o.open(), o.write(t), o.close(), r = o.body, s = o.body || {}, t = o.documentElement || {}, i = Math.max(s.scrollHeight, s.offsetHeight, t.clientHeight, t.scrollHeight, t.offsetHeight);
      } else s = (r = t).body || {}, i = Math.max(s.scrollHeight, s.offsetHeight, t.clientHeight, t.scrollHeight, t.offsetHeight);

      var h = {
        async: !0,
        allowTaint: !0,
        backgroundColor: "#ffffff",
        canvas: n,
        imageTimeout: 15e3,
        logging: !0,
        proxy: null,
        removeContainer: !0,
        foreignObjectRendering: !1,
        useCORS: !1,
        windowHeight: i = a.internal.pageSize.getHeight(),
        scrollY: i
      };
      a.context2d.pageWrapYEnabled = !0, a.context2d.pageWrapY = a.internal.pageSize.getHeight(), html2canvas(r, h).then(function (t) {
        e && (l && l.parentElement.removeChild(l), e(a));
      });
    } else alert("jsPDF canvas plugin not installed");
  }, window.tmp = html2pdf, function (f) {
    var r = f.BlobBuilder || f.WebKitBlobBuilder || f.MSBlobBuilder || f.MozBlobBuilder;

    f.URL = f.URL || f.webkitURL || function (t, e) {
      return (e = document.createElement("a")).href = t, e;
    };

    var n = f.Blob,
        p = URL.createObjectURL,
        d = URL.revokeObjectURL,
        o = f.Symbol && f.Symbol.toStringTag,
        t = !1,
        e = !1,
        g = !!f.ArrayBuffer,
        i = r && r.prototype.append && r.prototype.getBlob;

    try {
      t = 2 === new Blob(["ä"]).size, e = 2 === new Blob([new Uint8Array([1, 2])]).size;
    } catch (t) {}

    function a(t) {
      return t.map(function (t) {
        if (t.buffer instanceof ArrayBuffer) {
          var e = t.buffer;

          if (t.byteLength !== e.byteLength) {
            var n = new Uint8Array(t.byteLength);
            n.set(new Uint8Array(e, t.byteOffset, t.byteLength)), e = n.buffer;
          }

          return e;
        }

        return t;
      });
    }

    function s(t, e) {
      e = e || {};
      var n = new r();
      return a(t).forEach(function (t) {
        n.append(t);
      }), e.type ? n.getBlob(e.type) : n.getBlob();
    }

    function l(t, e) {
      return new n(a(t), e || {});
    }

    if (f.Blob && (s.prototype = Blob.prototype, l.prototype = Blob.prototype), o) try {
      File.prototype[o] = "File", Blob.prototype[o] = "Blob", FileReader.prototype[o] = "FileReader";
    } catch (t) {}

    function h() {
      var t = !!f.ActiveXObject || "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style,
          e = f.XMLHttpRequest && f.XMLHttpRequest.prototype.send;
      t && e && (XMLHttpRequest.prototype.send = function (t) {
        t instanceof Blob && this.setRequestHeader("Content-Type", t.type), e.call(this, t);
      });

      try {
        new File([], "");
      } catch (t) {
        try {
          var n = new Function('class File extends Blob {constructor(chunks, name, opts) {opts = opts || {};super(chunks, opts || {});this.name = name;this.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date;this.lastModified = +this.lastModifiedDate;}};return new File([], ""), File')();
          f.File = n;
        } catch (t) {
          n = function n(t, e, _n) {
            var r = new Blob(t, _n),
                i = _n && void 0 !== _n.lastModified ? new Date(_n.lastModified) : new Date();
            return r.name = e, r.lastModifiedDate = i, r.lastModified = +i, r.toString = function () {
              return "[object File]";
            }, o && (r[o] = "File"), r;
          };

          f.File = n;
        }
      }
    }

    t ? (h(), f.Blob = e ? f.Blob : l) : i ? (h(), f.Blob = s) : function () {
      function a(t) {
        for (var e = [], n = 0; n < t.length; n++) {
          var r = t.charCodeAt(n);
          r < 128 ? e.push(r) : r < 2048 ? e.push(192 | r >> 6, 128 | 63 & r) : r < 55296 || 57344 <= r ? e.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | 63 & r) : (n++, r = 65536 + ((1023 & r) << 10 | 1023 & t.charCodeAt(n)), e.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | 63 & r));
        }

        return e;
      }

      function e(t) {
        var e, n, r, i, o, a;

        for (e = "", r = t.length, n = 0; n < r;) {
          switch ((i = t[n++]) >> 4) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
              e += String.fromCharCode(i);
              break;

            case 12:
            case 13:
              o = t[n++], e += String.fromCharCode((31 & i) << 6 | 63 & o);
              break;

            case 14:
              o = t[n++], a = t[n++], e += String.fromCharCode((15 & i) << 12 | (63 & o) << 6 | (63 & a) << 0);
          }
        }

        return e;
      }

      function s(t) {
        for (var e = new Array(t.byteLength), n = new Uint8Array(t), r = e.length; r--;) {
          e[r] = n[r];
        }

        return e;
      }

      function n(t) {
        for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = [], r = 0; r < t.length; r += 3) {
          var i = t[r],
              o = r + 1 < t.length,
              a = o ? t[r + 1] : 0,
              s = r + 2 < t.length,
              l = s ? t[r + 2] : 0,
              h = i >> 2,
              u = (3 & i) << 4 | a >> 4,
              c = (15 & a) << 2 | l >> 6,
              f = 63 & l;
          s || (f = 64, o || (c = 64)), n.push(e[h], e[u], e[c], e[f]);
        }

        return n.join("");
      }

      var t = Object.create || function (t) {
        function e() {}

        return e.prototype = t, new e();
      };

      if (g) var r = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
          l = ArrayBuffer.isView || function (t) {
        return t && -1 < r.indexOf(Object.prototype.toString.call(t));
      };

      function h(t, e) {
        for (var n = 0, r = (t = t || []).length; n < r; n++) {
          var i = t[n];
          i instanceof h ? t[n] = i._buffer : "string" == typeof i ? t[n] = a(i) : g && (ArrayBuffer.prototype.isPrototypeOf(i) || l(i)) ? t[n] = s(i) : g && (o = i) && DataView.prototype.isPrototypeOf(o) ? t[n] = s(i.buffer) : t[n] = a(String(i));
        }

        var o;
        this._buffer = [].concat.apply([], t), this.size = this._buffer.length, this.type = e && e.type || "";
      }

      function i(t, e, n) {
        var r = h.call(this, t, n = n || {}) || this;
        return r.name = e, r.lastModifiedDate = n.lastModified ? new Date(n.lastModified) : new Date(), r.lastModified = +r.lastModifiedDate, r;
      }

      if (h.prototype.slice = function (t, e, n) {
        return new h([this._buffer.slice(t || 0, e || this._buffer.length)], {
          type: n
        });
      }, h.prototype.toString = function () {
        return "[object Blob]";
      }, (i.prototype = t(h.prototype)).constructor = i, Object.setPrototypeOf) Object.setPrototypeOf(i, h);else try {
        i.__proto__ = h;
      } catch (t) {}

      function o() {
        if (!(this instanceof o)) throw new TypeError("Failed to construct 'FileReader': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
        var n = document.createDocumentFragment();
        this.addEventListener = n.addEventListener, this.dispatchEvent = function (t) {
          var e = this["on" + t.type];
          "function" == typeof e && e(t), n.dispatchEvent(t);
        }, this.removeEventListener = n.removeEventListener;
      }

      function u(t, e, n) {
        if (!(e instanceof h)) throw new TypeError("Failed to execute '" + n + "' on 'FileReader': parameter 1 is not of type 'Blob'.");
        t.result = "", setTimeout(function () {
          this.readyState = o.LOADING, t.dispatchEvent(new Event("load")), t.dispatchEvent(new Event("loadend"));
        });
      }

      i.prototype.toString = function () {
        return "[object File]";
      }, o.EMPTY = 0, o.LOADING = 1, o.DONE = 2, o.prototype.error = null, o.prototype.onabort = null, o.prototype.onerror = null, o.prototype.onload = null, o.prototype.onloadend = null, o.prototype.onloadstart = null, o.prototype.onprogress = null, o.prototype.readAsDataURL = function (t) {
        u(this, t, "readAsDataURL"), this.result = "data:" + t.type + ";base64," + n(t._buffer);
      }, o.prototype.readAsText = function (t) {
        u(this, t, "readAsText"), this.result = e(t._buffer);
      }, o.prototype.readAsArrayBuffer = function (t) {
        u(this, t, "readAsText"), this.result = t._buffer.slice();
      }, o.prototype.abort = function () {}, URL.createObjectURL = function (t) {
        return t instanceof h ? "data:" + t.type + ";base64," + n(t._buffer) : p.call(URL, t);
      }, URL.revokeObjectURL = function (t) {
        d && d.call(URL, t);
      };
      var c = f.XMLHttpRequest && f.XMLHttpRequest.prototype.send;
      c && (XMLHttpRequest.prototype.send = function (t) {
        t instanceof h ? (this.setRequestHeader("Content-Type", t.type), c.call(this, e(t._buffer))) : c.call(this, t);
      }), f.FileReader = o, f.File = i, f.Blob = h;
    }();
  }("undefined" != typeof self && self || "undefined" != typeof window && window || "undefined" != typeof global && global || Function('return typeof this === "object" && this.content')() || Function("return this")());

  var ht,
      ut,
      ct,
      _ft,
      pt,
      dt,
      gt,
      mt,
      yt,
      vt,
      wt,
      bt,
      xt,
      Nt,
      Lt,
      le = le || function (s) {
    if (!(void 0 === s || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) {
      var t = s.document,
          l = function l() {
        return s.URL || s.webkitURL || s;
      },
          h = t.createElementNS("http://www.w3.org/1999/xhtml", "a"),
          u = "download" in h,
          c = /constructor/i.test(s.HTMLElement) || s.safari,
          f = /CriOS\/[\d]+/.test(navigator.userAgent),
          p = s.setImmediate || s.setTimeout,
          d = function d(t) {
        p(function () {
          throw t;
        }, 0);
      },
          g = function g(t) {
        setTimeout(function () {
          "string" == typeof t ? l().revokeObjectURL(t) : t.remove();
        }, 4e4);
      },
          m = function m(t) {
        return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], {
          type: t.type
        }) : t;
      },
          r = function r(t, n, e) {
        e || (t = m(t));

        var r,
            i = this,
            o = "application/octet-stream" === t.type,
            a = function a() {
          !function (t, e, n) {
            for (var r = (e = [].concat(e)).length; r--;) {
              var i = t["on" + e[r]];
              if ("function" == typeof i) try {
                i.call(t, n || t);
              } catch (t) {
                d(t);
              }
            }
          }(i, "writestart progress write writeend".split(" "));
        };

        if (i.readyState = i.INIT, u) return r = l().createObjectURL(t), void p(function () {
          var t, e;
          h.href = r, h.download = n, t = h, e = new MouseEvent("click"), t.dispatchEvent(e), a(), g(r), i.readyState = i.DONE;
        }, 0);
        !function () {
          if ((f || o && c) && s.FileReader) {
            var e = new FileReader();
            return e.onloadend = function () {
              var t = f ? e.result : e.result.replace(/^data:[^;]*;/, "data:attachment/file;");
              s.open(t, "_blank") || (s.location.href = t), t = void 0, i.readyState = i.DONE, a();
            }, e.readAsDataURL(t), i.readyState = i.INIT;
          }

          r || (r = l().createObjectURL(t)), o ? s.location.href = r : s.open(r, "_blank") || (s.location.href = r);
          i.readyState = i.DONE, a(), g(r);
        }();
      },
          e = r.prototype;

      return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function (t, e, n) {
        return e = e || t.name || "download", n || (t = m(t)), navigator.msSaveOrOpenBlob(t, e);
      } : (e.abort = function () {}, e.readyState = e.INIT = 0, e.WRITING = 1, e.DONE = 2, e.error = e.onwritestart = e.onprogress = e.onwrite = e.onabort = e.onerror = e.onwriteend = null, function (t, e, n) {
        return new r(t, e || t.name || "download", n);
      });
    }
  }("undefined" != typeof self && self || "undefined" != typeof window && window || void 0);

  function At(x) {
    var t = 0;
    if (71 !== x[t++] || 73 !== x[t++] || 70 !== x[t++] || 56 !== x[t++] || 56 != (x[t++] + 1 & 253) || 97 !== x[t++]) throw "Invalid GIF 87a/89a header.";
    var N = x[t++] | x[t++] << 8,
        e = x[t++] | x[t++] << 8,
        n = x[t++],
        r = n >> 7,
        i = 1 << (7 & n) + 1;
    x[t++];
    x[t++];
    var o = null;
    r && (o = t, t += 3 * i);
    var a = !0,
        s = [],
        l = 0,
        h = null,
        u = 0,
        c = null;

    for (this.width = N, this.height = e; a && t < x.length;) {
      switch (x[t++]) {
        case 33:
          switch (x[t++]) {
            case 255:
              if (11 !== x[t] || 78 == x[t + 1] && 69 == x[t + 2] && 84 == x[t + 3] && 83 == x[t + 4] && 67 == x[t + 5] && 65 == x[t + 6] && 80 == x[t + 7] && 69 == x[t + 8] && 50 == x[t + 9] && 46 == x[t + 10] && 48 == x[t + 11] && 3 == x[t + 12] && 1 == x[t + 13] && 0 == x[t + 16]) t += 14, c = x[t++] | x[t++] << 8, t++;else for (t += 12;;) {
                if (0 === (A = x[t++])) break;
                t += A;
              }
              break;

            case 249:
              if (4 !== x[t++] || 0 !== x[t + 4]) throw "Invalid graphics extension block.";
              var f = x[t++];
              l = x[t++] | x[t++] << 8, h = x[t++], 0 == (1 & f) && (h = null), u = f >> 2 & 7, t++;
              break;

            case 254:
              for (;;) {
                if (0 === (A = x[t++])) break;
                t += A;
              }

              break;

            default:
              throw "Unknown graphic control label: 0x" + x[t - 1].toString(16);
          }

          break;

        case 44:
          var p = x[t++] | x[t++] << 8,
              d = x[t++] | x[t++] << 8,
              g = x[t++] | x[t++] << 8,
              m = x[t++] | x[t++] << 8,
              y = x[t++],
              v = y >> 6 & 1,
              w = o,
              b = !1;

          if (y >> 7) {
            b = !0;
            w = t, t += 3 * (1 << (7 & y) + 1);
          }

          var L = t;

          for (t++;;) {
            var A;
            if (0 === (A = x[t++])) break;
            t += A;
          }

          s.push({
            x: p,
            y: d,
            width: g,
            height: m,
            has_local_palette: b,
            palette_offset: w,
            data_offset: L,
            data_length: t - L,
            transparent_index: h,
            interlaced: !!v,
            delay: l,
            disposal: u
          });
          break;

        case 59:
          a = !1;
          break;

        default:
          throw "Unknown gif block: 0x" + x[t - 1].toString(16);
      }
    }

    this.numFrames = function () {
      return s.length;
    }, this.loopCount = function () {
      return c;
    }, this.frameInfo = function (t) {
      if (t < 0 || t >= s.length) throw "Frame index out of range.";
      return s[t];
    }, this.decodeAndBlitFrameBGRA = function (t, e) {
      var n = this.frameInfo(t),
          r = n.width * n.height,
          i = new Uint8Array(r);
      St(x, n.data_offset, i, r);
      var o = n.palette_offset,
          a = n.transparent_index;
      null === a && (a = 256);
      var s = n.width,
          l = N - s,
          h = s,
          u = 4 * (n.y * N + n.x),
          c = 4 * ((n.y + n.height) * N + n.x),
          f = u,
          p = 4 * l;
      !0 === n.interlaced && (p += 4 * (s + l) * 7);

      for (var d = 8, g = 0, m = i.length; g < m; ++g) {
        var y = i[g];
        if (0 === h && (h = s, c <= (f += p) && (p = l + 4 * (s + l) * (d - 1), f = u + (s + l) * (d << 1), d >>= 1)), y === a) f += 4;else {
          var v = x[o + 3 * y],
              w = x[o + 3 * y + 1],
              b = x[o + 3 * y + 2];
          e[f++] = b, e[f++] = w, e[f++] = v, e[f++] = 255;
        }
        --h;
      }
    }, this.decodeAndBlitFrameRGBA = function (t, e) {
      var n = this.frameInfo(t),
          r = n.width * n.height,
          i = new Uint8Array(r);
      St(x, n.data_offset, i, r);
      var o = n.palette_offset,
          a = n.transparent_index;
      null === a && (a = 256);
      var s = n.width,
          l = N - s,
          h = s,
          u = 4 * (n.y * N + n.x),
          c = 4 * ((n.y + n.height) * N + n.x),
          f = u,
          p = 4 * l;
      !0 === n.interlaced && (p += 4 * (s + l) * 7);

      for (var d = 8, g = 0, m = i.length; g < m; ++g) {
        var y = i[g];
        if (0 === h && (h = s, c <= (f += p) && (p = l + 4 * (s + l) * (d - 1), f = u + (s + l) * (d << 1), d >>= 1)), y === a) f += 4;else {
          var v = x[o + 3 * y],
              w = x[o + 3 * y + 1],
              b = x[o + 3 * y + 2];
          e[f++] = v, e[f++] = w, e[f++] = b, e[f++] = 255;
        }
        --h;
      }
    };
  }

  function St(t, e, n, r) {
    for (var i = t[e++], o = 1 << i, a = o + 1, s = a + 1, l = i + 1, h = (1 << l) - 1, u = 0, c = 0, f = 0, p = t[e++], d = new Int32Array(4096), g = null;;) {
      for (; u < 16 && 0 !== p;) {
        c |= t[e++] << u, u += 8, 1 === p ? p = t[e++] : --p;
      }

      if (u < l) break;
      var m = c & h;

      if (c >>= l, u -= l, m !== o) {
        if (m === a) break;

        for (var y = m < s ? m : g, v = 0, w = y; o < w;) {
          w = d[w] >> 8, ++v;
        }

        var b = w;
        if (r < f + v + (y !== m ? 1 : 0)) return void console.log("Warning, gif stream longer than expected.");
        n[f++] = b;
        var x = f += v;

        for (y !== m && (n[f++] = b), w = y; v--;) {
          w = d[w], n[--x] = 255 & w, w >>= 8;
        }

        null !== g && s < 4096 && (d[s++] = g << 8 | b, h + 1 <= s && l < 12 && (++l, h = h << 1 | 1)), g = m;
      } else s = a + 1, h = (1 << (l = i + 1)) - 1, g = null;
    }

    return f !== r && console.log("Warning, gif stream shorter than expected."), n;
  }

  try {
    exports.GifWriter = function (y, t, e, n) {
      var v = 0,
          r = void 0 === (n = void 0 === n ? {} : n).loop ? null : n.loop,
          w = void 0 === n.palette ? null : n.palette;
      if (t <= 0 || e <= 0 || 65535 < t || 65535 < e) throw "Width/Height invalid.";

      function b(t) {
        var e = t.length;
        if (e < 2 || 256 < e || e & e - 1) throw "Invalid code/color length, must be power of 2 and 2 .. 256.";
        return e;
      }

      y[v++] = 71, y[v++] = 73, y[v++] = 70, y[v++] = 56, y[v++] = 57, y[v++] = 97;
      var i = 0,
          o = 0;

      if (null !== w) {
        for (var a = b(w); a >>= 1;) {
          ++i;
        }

        if (a = 1 << i, --i, void 0 !== n.background) {
          if (a <= (o = n.background)) throw "Background index out of range.";
          if (0 === o) throw "Background index explicitly passed as 0.";
        }
      }

      if (y[v++] = 255 & t, y[v++] = t >> 8 & 255, y[v++] = 255 & e, y[v++] = e >> 8 & 255, y[v++] = (null !== w ? 128 : 0) | i, y[v++] = o, y[v++] = 0, null !== w) for (var s = 0, l = w.length; s < l; ++s) {
        var h = w[s];
        y[v++] = h >> 16 & 255, y[v++] = h >> 8 & 255, y[v++] = 255 & h;
      }

      if (null !== r) {
        if (r < 0 || 65535 < r) throw "Loop count invalid.";
        y[v++] = 33, y[v++] = 255, y[v++] = 11, y[v++] = 78, y[v++] = 69, y[v++] = 84, y[v++] = 83, y[v++] = 67, y[v++] = 65, y[v++] = 80, y[v++] = 69, y[v++] = 50, y[v++] = 46, y[v++] = 48, y[v++] = 3, y[v++] = 1, y[v++] = 255 & r, y[v++] = r >> 8 & 255, y[v++] = 0;
      }

      var x = !1;
      this.addFrame = function (t, e, n, r, i, o) {
        if (!0 === x && (--v, x = !1), o = void 0 === o ? {} : o, t < 0 || e < 0 || 65535 < t || 65535 < e) throw "x/y invalid.";
        if (n <= 0 || r <= 0 || 65535 < n || 65535 < r) throw "Width/Height invalid.";
        if (i.length < n * r) throw "Not enough pixels for the frame size.";
        var a = !0,
            s = o.palette;
        if (null == s && (a = !1, s = w), null == s) throw "Must supply either a local or global palette.";

        for (var l = b(s), h = 0; l >>= 1;) {
          ++h;
        }

        l = 1 << h;
        var u = void 0 === o.delay ? 0 : o.delay,
            c = void 0 === o.disposal ? 0 : o.disposal;
        if (c < 0 || 3 < c) throw "Disposal out of range.";
        var f = !1,
            p = 0;
        if (void 0 !== o.transparent && null !== o.transparent && (f = !0, (p = o.transparent) < 0 || l <= p)) throw "Transparent color index.";
        if ((0 !== c || f || 0 !== u) && (y[v++] = 33, y[v++] = 249, y[v++] = 4, y[v++] = c << 2 | (!0 === f ? 1 : 0), y[v++] = 255 & u, y[v++] = u >> 8 & 255, y[v++] = p, y[v++] = 0), y[v++] = 44, y[v++] = 255 & t, y[v++] = t >> 8 & 255, y[v++] = 255 & e, y[v++] = e >> 8 & 255, y[v++] = 255 & n, y[v++] = n >> 8 & 255, y[v++] = 255 & r, y[v++] = r >> 8 & 255, y[v++] = !0 === a ? 128 | h - 1 : 0, !0 === a) for (var d = 0, g = s.length; d < g; ++d) {
          var m = s[d];
          y[v++] = m >> 16 & 255, y[v++] = m >> 8 & 255, y[v++] = 255 & m;
        }

        v = function (e, n, t, r) {
          e[n++] = t;
          var i = n++,
              o = 1 << t,
              a = o - 1,
              s = o + 1,
              l = s + 1,
              h = t + 1,
              u = 0,
              c = 0;

          function f(t) {
            for (; t <= u;) {
              e[n++] = 255 & c, c >>= 8, u -= 8, n === i + 256 && (e[i] = 255, i = n++);
            }
          }

          function p(t) {
            c |= t << u, u += h, f(8);
          }

          var d = r[0] & a,
              g = {};
          p(o);

          for (var m = 1, y = r.length; m < y; ++m) {
            var v = r[m] & a,
                w = d << 8 | v,
                b = g[w];

            if (void 0 === b) {
              for (c |= d << u, u += h; 8 <= u;) {
                e[n++] = 255 & c, c >>= 8, u -= 8, n === i + 256 && (e[i] = 255, i = n++);
              }

              4096 === l ? (p(o), l = s + 1, h = t + 1, g = {}) : (1 << h <= l && ++h, g[w] = l++), d = v;
            } else d = b;
          }

          return p(d), p(s), f(1), i + 1 === n ? e[i] = 0 : (e[i] = n - i - 1, e[n++] = 0), n;
        }(y, v, h < 2 ? 2 : h, i);
      }, this.end = function () {
        return !1 === x && (y[v++] = 59, x = !0), v;
      };
    }, exports.GifReader = At;
  } catch (t) {}
  /*
      Copyright (c) 2008, Adobe Systems Incorporated
      All rights reserved.
  
      Redistribution and use in source and binary forms, with or without 
      modification, are permitted provided that the following conditions are
      met:
  
      * Redistributions of source code must retain the above copyright notice, 
        this list of conditions and the following disclaimer.
      
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the 
        documentation and/or other materials provided with the distribution.
      
      * Neither the name of Adobe Systems Incorporated nor the names of its 
        contributors may be used to endorse or promote products derived from 
        this software without specific prior written permission.
  
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
      IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
      THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
      CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
      EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
      PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
      PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
      LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */


  function _t(t) {
    var N,
        L,
        A,
        S,
        e,
        c = Math.floor,
        _ = new Array(64),
        F = new Array(64),
        P = new Array(64),
        k = new Array(64),
        y = new Array(65535),
        v = new Array(65535),
        Z = new Array(64),
        w = new Array(64),
        I = [],
        C = 0,
        B = 7,
        j = new Array(64),
        E = new Array(64),
        M = new Array(64),
        n = new Array(256),
        O = new Array(2048),
        b = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63],
        q = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        T = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
        R = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125],
        D = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250],
        U = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
        z = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
        H = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119],
        W = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];

    function r(t, e) {
      for (var n = 0, r = 0, i = new Array(), o = 1; o <= 16; o++) {
        for (var a = 1; a <= t[o]; a++) {
          i[e[r]] = [], i[e[r]][0] = n, i[e[r]][1] = o, r++, n++;
        }

        n *= 2;
      }

      return i;
    }

    function V(t) {
      for (var e = t[0], n = t[1] - 1; 0 <= n;) {
        e & 1 << n && (C |= 1 << B), n--, --B < 0 && (255 == C ? (G(255), G(0)) : G(C), B = 7, C = 0);
      }
    }

    function G(t) {
      I.push(t);
    }

    function Y(t) {
      G(t >> 8 & 255), G(255 & t);
    }

    function J(t, e, n, r, i) {
      for (var o, a = i[0], s = i[240], l = function (t, e) {
        var n,
            r,
            i,
            o,
            a,
            s,
            l,
            h,
            u,
            c,
            f = 0;

        for (u = 0; u < 8; ++u) {
          n = t[f], r = t[f + 1], i = t[f + 2], o = t[f + 3], a = t[f + 4], s = t[f + 5], l = t[f + 6];
          var p = n + (h = t[f + 7]),
              d = n - h,
              g = r + l,
              m = r - l,
              y = i + s,
              v = i - s,
              w = o + a,
              b = o - a,
              x = p + w,
              N = p - w,
              L = g + y,
              A = g - y;
          t[f] = x + L, t[f + 4] = x - L;
          var S = .707106781 * (A + N);
          t[f + 2] = N + S, t[f + 6] = N - S;

          var _ = .382683433 * ((x = b + v) - (A = m + d)),
              F = .5411961 * x + _,
              P = 1.306562965 * A + _,
              k = .707106781 * (L = v + m),
              I = d + k,
              C = d - k;

          t[f + 5] = C + F, t[f + 3] = C - F, t[f + 1] = I + P, t[f + 7] = I - P, f += 8;
        }

        for (u = f = 0; u < 8; ++u) {
          n = t[f], r = t[f + 8], i = t[f + 16], o = t[f + 24], a = t[f + 32], s = t[f + 40], l = t[f + 48];
          var B = n + (h = t[f + 56]),
              j = n - h,
              E = r + l,
              M = r - l,
              O = i + s,
              q = i - s,
              T = o + a,
              R = o - a,
              D = B + T,
              U = B - T,
              z = E + O,
              H = E - O;
          t[f] = D + z, t[f + 32] = D - z;
          var W = .707106781 * (H + U);
          t[f + 16] = U + W, t[f + 48] = U - W;
          var V = .382683433 * ((D = R + q) - (H = M + j)),
              G = .5411961 * D + V,
              Y = 1.306562965 * H + V,
              J = .707106781 * (z = q + M),
              X = j + J,
              K = j - J;
          t[f + 40] = K + G, t[f + 24] = K - G, t[f + 8] = X + Y, t[f + 56] = X - Y, f++;
        }

        for (u = 0; u < 64; ++u) {
          c = t[u] * e[u], Z[u] = 0 < c ? c + .5 | 0 : c - .5 | 0;
        }

        return Z;
      }(t, e), h = 0; h < 64; ++h) {
        w[b[h]] = l[h];
      }

      var u = w[0] - n;
      n = w[0], 0 == u ? V(r[0]) : (V(r[v[o = 32767 + u]]), V(y[o]));

      for (var c = 63; 0 < c && 0 == w[c]; c--) {
        ;
      }

      if (0 == c) return V(a), n;

      for (var f, p = 1; p <= c;) {
        for (var d = p; 0 == w[p] && p <= c; ++p) {
          ;
        }

        var g = p - d;

        if (16 <= g) {
          f = g >> 4;

          for (var m = 1; m <= f; ++m) {
            V(s);
          }

          g &= 15;
        }

        o = 32767 + w[p], V(i[(g << 4) + v[o]]), V(y[o]), p++;
      }

      return 63 != c && V(a), n;
    }

    function X(t) {
      if (t <= 0 && (t = 1), 100 < t && (t = 100), e != t) {
        (function (t) {
          for (var e = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], n = 0; n < 64; n++) {
            var r = c((e[n] * t + 50) / 100);
            r < 1 ? r = 1 : 255 < r && (r = 255), _[b[n]] = r;
          }

          for (var i = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], o = 0; o < 64; o++) {
            var a = c((i[o] * t + 50) / 100);
            a < 1 ? a = 1 : 255 < a && (a = 255), F[b[o]] = a;
          }

          for (var s = [1, 1.387039845, 1.306562965, 1.175875602, 1, .785694958, .5411961, .275899379], l = 0, h = 0; h < 8; h++) {
            for (var u = 0; u < 8; u++) {
              P[l] = 1 / (_[b[l]] * s[h] * s[u] * 8), k[l] = 1 / (F[b[l]] * s[h] * s[u] * 8), l++;
            }
          }
        })(t < 50 ? Math.floor(5e3 / t) : Math.floor(200 - 2 * t)), e = t;
      }
    }

    this.encode = function (t, e) {
      var n, r;
      new Date().getTime();
      e && X(e), I = new Array(), C = 0, B = 7, Y(65496), Y(65504), Y(16), G(74), G(70), G(73), G(70), G(0), G(1), G(1), G(0), Y(1), Y(1), G(0), G(0), function () {
        Y(65499), Y(132), G(0);

        for (var t = 0; t < 64; t++) {
          G(_[t]);
        }

        G(1);

        for (var e = 0; e < 64; e++) {
          G(F[e]);
        }
      }(), n = t.width, r = t.height, Y(65472), Y(17), G(8), Y(r), Y(n), G(3), G(1), G(17), G(0), G(2), G(17), G(1), G(3), G(17), G(1), function () {
        Y(65476), Y(418), G(0);

        for (var t = 0; t < 16; t++) {
          G(q[t + 1]);
        }

        for (var e = 0; e <= 11; e++) {
          G(T[e]);
        }

        G(16);

        for (var n = 0; n < 16; n++) {
          G(R[n + 1]);
        }

        for (var r = 0; r <= 161; r++) {
          G(D[r]);
        }

        G(1);

        for (var i = 0; i < 16; i++) {
          G(U[i + 1]);
        }

        for (var o = 0; o <= 11; o++) {
          G(z[o]);
        }

        G(17);

        for (var a = 0; a < 16; a++) {
          G(H[a + 1]);
        }

        for (var s = 0; s <= 161; s++) {
          G(W[s]);
        }
      }(), Y(65498), Y(12), G(3), G(1), G(0), G(2), G(17), G(3), G(17), G(0), G(63), G(0);
      var i = 0,
          o = 0,
          a = 0;
      C = 0, B = 7, this.encode.displayName = "_encode_";

      for (var s, l, h, u, c, f, p, d, g, m = t.data, y = t.width, v = t.height, w = 4 * y, b = 0; b < v;) {
        for (s = 0; s < w;) {
          for (f = c = w * b + s, p = -1, g = d = 0; g < 64; g++) {
            f = c + (d = g >> 3) * w + (p = 4 * (7 & g)), v <= b + d && (f -= w * (b + 1 + d - v)), w <= s + p && (f -= s + p - w + 4), l = m[f++], h = m[f++], u = m[f++], j[g] = (O[l] + O[h + 256 >> 0] + O[u + 512 >> 0] >> 16) - 128, E[g] = (O[l + 768 >> 0] + O[h + 1024 >> 0] + O[u + 1280 >> 0] >> 16) - 128, M[g] = (O[l + 1280 >> 0] + O[h + 1536 >> 0] + O[u + 1792 >> 0] >> 16) - 128;
          }

          i = J(j, P, i, N, A), o = J(E, k, o, L, S), a = J(M, k, a, L, S), s += 32;
        }

        b += 8;
      }

      if (0 <= B) {
        var x = [];
        x[1] = B + 1, x[0] = (1 << B + 1) - 1, V(x);
      }

      return Y(65497), new Uint8Array(I);
    }, function () {
      new Date().getTime();
      t || (t = 50), function () {
        for (var t = String.fromCharCode, e = 0; e < 256; e++) {
          n[e] = t(e);
        }
      }(), N = r(q, T), L = r(U, z), A = r(R, D), S = r(H, W), function () {
        for (var t = 1, e = 2, n = 1; n <= 15; n++) {
          for (var r = t; r < e; r++) {
            v[32767 + r] = n, y[32767 + r] = [], y[32767 + r][1] = n, y[32767 + r][0] = r;
          }

          for (var i = -(e - 1); i <= -t; i++) {
            v[32767 + i] = n, y[32767 + i] = [], y[32767 + i][1] = n, y[32767 + i][0] = e - 1 + i;
          }

          t <<= 1, e <<= 1;
        }
      }(), function () {
        for (var t = 0; t < 256; t++) {
          O[t] = 19595 * t, O[t + 256 >> 0] = 38470 * t, O[t + 512 >> 0] = 7471 * t + 32768, O[t + 768 >> 0] = -11059 * t, O[t + 1024 >> 0] = -21709 * t, O[t + 1280 >> 0] = 32768 * t + 8421375, O[t + 1536 >> 0] = -27439 * t, O[t + 1792 >> 0] = -5329 * t;
        }
      }(), X(t), new Date().getTime();
    }();
  }

  function Ft(t, e) {
    if (this.pos = 0, this.buffer = t, this.datav = new DataView(t.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
    this.parseHeader(), this.parseBGR();
  }

  window.tmp = At, lt.API.adler32cs = (dt = "function" == typeof ArrayBuffer && "function" == typeof Uint8Array, gt = null, mt = function () {
    if (!dt) return function () {
      return !1;
    };

    try {
      var t = {};
      "function" == typeof t.Buffer && (gt = t.Buffer);
    } catch (t) {}

    return function (t) {
      return t instanceof ArrayBuffer || null !== gt && t instanceof gt;
    };
  }(), yt = null !== gt ? function (t) {
    return new gt(t, "utf8").toString("binary");
  } : function (t) {
    return unescape(encodeURIComponent(t));
  }, vt = function vt(t, e) {
    for (var n = 65535 & t, r = t >>> 16, i = 0, o = e.length; i < o; i++) {
      n = (n + (255 & e.charCodeAt(i))) % 65521, r = (r + n) % 65521;
    }

    return (r << 16 | n) >>> 0;
  }, wt = function wt(t, e) {
    for (var n = 65535 & t, r = t >>> 16, i = 0, o = e.length; i < o; i++) {
      n = (n + e[i]) % 65521, r = (r + n) % 65521;
    }

    return (r << 16 | n) >>> 0;
  }, xt = (bt = {}).Adler32 = (((pt = (_ft = function ft(t) {
    if (!(this instanceof _ft)) throw new TypeError("Constructor cannot called be as a function.");
    if (!isFinite(t = null == t ? 1 : +t)) throw new Error("First arguments needs to be a finite number.");
    this.checksum = t >>> 0;
  }).prototype = {}).constructor = _ft).from = ((ht = function ht(t) {
    if (!(this instanceof _ft)) throw new TypeError("Constructor cannot called be as a function.");
    if (null == t) throw new Error("First argument needs to be a string.");
    this.checksum = vt(1, t.toString());
  }).prototype = pt, ht), _ft.fromUtf8 = ((ut = function ut(t) {
    if (!(this instanceof _ft)) throw new TypeError("Constructor cannot called be as a function.");
    if (null == t) throw new Error("First argument needs to be a string.");
    var e = yt(t.toString());
    this.checksum = vt(1, e);
  }).prototype = pt, ut), dt && (_ft.fromBuffer = ((ct = function ct(t) {
    if (!(this instanceof _ft)) throw new TypeError("Constructor cannot called be as a function.");
    if (!mt(t)) throw new Error("First argument needs to be ArrayBuffer.");
    var e = new Uint8Array(t);
    return this.checksum = wt(1, e);
  }).prototype = pt, ct)), pt.update = function (t) {
    if (null == t) throw new Error("First argument needs to be a string.");
    return t = t.toString(), this.checksum = vt(this.checksum, t);
  }, pt.updateUtf8 = function (t) {
    if (null == t) throw new Error("First argument needs to be a string.");
    var e = yt(t.toString());
    return this.checksum = vt(this.checksum, e);
  }, dt && (pt.updateBuffer = function (t) {
    if (!mt(t)) throw new Error("First argument needs to be ArrayBuffer.");
    var e = new Uint8Array(t);
    return this.checksum = wt(this.checksum, e);
  }), pt.clone = function () {
    return new xt(this.checksum);
  }, _ft), bt.from = function (t) {
    if (null == t) throw new Error("First argument needs to be a string.");
    return vt(1, t.toString());
  }, bt.fromUtf8 = function (t) {
    if (null == t) throw new Error("First argument needs to be a string.");
    var e = yt(t.toString());
    return vt(1, e);
  }, dt && (bt.fromBuffer = function (t) {
    if (!mt(t)) throw new Error("First argument need to be ArrayBuffer.");
    var e = new Uint8Array(t);
    return wt(1, e);
  }), bt), function (t) {
    t.__bidiEngine__ = t.prototype.__bidiEngine__ = function (t) {
      var d,
          g,
          c,
          f,
          i,
          o,
          a,
          s = e,
          m = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]],
          y = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]],
          v = {
        L: 0,
        R: 1,
        EN: 2,
        AN: 3,
        N: 4,
        B: 5,
        S: 6
      },
          l = {
        0: 0,
        5: 1,
        6: 2,
        7: 3,
        32: 4,
        251: 5,
        254: 6,
        255: 7
      },
          h = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"],
          u = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/),
          w = !1,
          b = 0;
      this.__bidiEngine__ = {};

      var x = function x(t) {
        var e = t.charCodeAt(),
            n = e >> 8,
            r = l[n];
        return void 0 !== r ? s[256 * r + (255 & e)] : 252 === n || 253 === n ? "AL" : u.test(n) ? "L" : 8 === n ? "R" : "N";
      },
          p = function p(t) {
        for (var e, n = 0; n < t.length; n++) {
          if ("L" === (e = x(t.charAt(n)))) return !1;
          if ("R" === e) return !0;
        }

        return !1;
      },
          N = function N(t, e, n, r) {
        var i,
            o,
            a,
            s,
            l = e[r];

        switch (l) {
          case "L":
          case "R":
            w = !1;
            break;

          case "N":
          case "AN":
            break;

          case "EN":
            w && (l = "AN");
            break;

          case "AL":
            w = !0, l = "R";
            break;

          case "WS":
            l = "N";
            break;

          case "CS":
            r < 1 || r + 1 >= e.length || "EN" !== (i = n[r - 1]) && "AN" !== i || "EN" !== (o = e[r + 1]) && "AN" !== o ? l = "N" : w && (o = "AN"), l = o === i ? o : "N";
            break;

          case "ES":
            l = "EN" === (i = 0 < r ? n[r - 1] : "B") && r + 1 < e.length && "EN" === e[r + 1] ? "EN" : "N";
            break;

          case "ET":
            if (0 < r && "EN" === n[r - 1]) {
              l = "EN";
              break;
            }

            if (w) {
              l = "N";
              break;
            }

            for (a = r + 1, s = e.length; a < s && "ET" === e[a];) {
              a++;
            }

            l = a < s && "EN" === e[a] ? "EN" : "N";
            break;

          case "NSM":
            if (c && !f) {
              for (s = e.length, a = r + 1; a < s && "NSM" === e[a];) {
                a++;
              }

              if (a < s) {
                var h = t[r],
                    u = 1425 <= h && h <= 2303 || 64286 === h;

                if (i = e[a], u && ("R" === i || "AL" === i)) {
                  l = "R";
                  break;
                }
              }
            }

            l = r < 1 || "B" === (i = e[r - 1]) ? "N" : n[r - 1];
            break;

          case "B":
            d = !(w = !1), l = b;
            break;

          case "S":
            g = !0, l = "N";
            break;

          case "LRE":
          case "RLE":
          case "LRO":
          case "RLO":
          case "PDF":
            w = !1;
            break;

          case "BN":
            l = "N";
        }

        return l;
      },
          L = function L(t, e, n) {
        var r = t.split("");
        return n && A(r, n, {
          hiLevel: b
        }), r.reverse(), e && e.reverse(), r.join("");
      },
          A = function A(t, e, n) {
        var r,
            i,
            o,
            a,
            s,
            l = -1,
            h = t.length,
            u = 0,
            c = [],
            f = b ? y : m,
            p = [];

        for (g = d = w = !1, i = 0; i < h; i++) {
          p[i] = x(t[i]);
        }

        for (o = 0; o < h; o++) {
          if (s = u, c[o] = N(t, p, c, o), r = 240 & (u = f[s][v[c[o]]]), u &= 15, e[o] = a = f[u][5], 0 < r) if (16 === r) {
            for (i = l; i < o; i++) {
              e[i] = 1;
            }

            l = -1;
          } else l = -1;
          if (f[u][6]) -1 === l && (l = o);else if (-1 < l) {
            for (i = l; i < o; i++) {
              e[i] = a;
            }

            l = -1;
          }
          "B" === p[o] && (e[o] = 0), n.hiLevel |= a;
        }

        g && function (t, e, n) {
          for (var r = 0; r < n; r++) {
            if ("S" === t[r]) {
              e[r] = b;

              for (var i = r - 1; 0 <= i && "WS" === t[i]; i--) {
                e[i] = b;
              }
            }
          }
        }(p, e, h);
      },
          S = function S(t, e, n, r, i) {
        if (!(i.hiLevel < t)) {
          if (1 === t && 1 === b && !d) return e.reverse(), void (n && n.reverse());

          for (var o, a, s, l, h = e.length, u = 0; u < h;) {
            if (r[u] >= t) {
              for (s = u + 1; s < h && r[s] >= t;) {
                s++;
              }

              for (l = u, a = s - 1; l < a; l++, a--) {
                o = e[l], e[l] = e[a], e[a] = o, n && (o = n[l], n[l] = n[a], n[a] = o);
              }

              u = s;
            }

            u++;
          }
        }
      },
          _ = function _(t, e, n) {
        var r = t.split(""),
            i = {
          hiLevel: b
        };
        return n || (n = []), A(r, n, i), function (t, e, n) {
          if (0 !== n.hiLevel && a) for (var r, i = 0; i < t.length; i++) {
            1 === e[i] && 0 <= (r = h.indexOf(t[i])) && (t[i] = h[r + 1]);
          }
        }(r, n, i), S(2, r, e, n, i), S(1, r, e, n, i), r.join("");
      };

      return this.__bidiEngine__.doBidiReorder = function (t, e, n) {
        if (function (t, e) {
          if (e) for (var n = 0; n < t.length; n++) {
            e[n] = n;
          }
          void 0 === f && (f = p(t)), void 0 === o && (o = p(t));
        }(t, e), c || !i || o) {
          if (c && i && f ^ o) b = f ? 1 : 0, t = L(t, e, n);else if (!c && i && o) b = f ? 1 : 0, t = _(t, e, n), t = L(t, e);else if (!c || f || i || o) {
            if (c && !i && f ^ o) t = L(t, e), t = f ? (b = 0, _(t, e, n)) : (b = 1, t = _(t, e, n), L(t, e));else if (c && f && !i && o) b = 1, t = _(t, e, n), t = L(t, e);else if (!c && !i && f ^ o) {
              var r = a;
              f ? (b = 1, t = _(t, e, n), b = 0, a = !1, t = _(t, e, n), a = r) : (b = 0, t = _(t, e, n), t = L(t, e), a = !(b = 1), t = _(t, e, n), a = r, t = L(t, e));
            }
          } else b = 0, t = _(t, e, n);
        } else b = f ? 1 : 0, t = _(t, e, n);
        return t;
      }, this.__bidiEngine__.setOptions = function (t) {
        t && (c = t.isInputVisual, i = t.isOutputVisual, f = t.isInputRtl, o = t.isOutputRtl, a = t.isSymmetricSwapping);
      }, this.__bidiEngine__.setOptions(t), this.__bidiEngine__;
    };

    var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"],
        o = new t.__bidiEngine__({
      isInputVisual: !0
    });
    t.API.events.push(["postProcessText", function (t) {
      var e = t.text,
          n = (t.x, t.y, t.options || {}),
          r = (t.mutex, n.lang, []);

      if ("[object Array]" === Object.prototype.toString.call(e)) {
        var i = 0;

        for (r = [], i = 0; i < e.length; i += 1) {
          "[object Array]" === Object.prototype.toString.call(e[i]) ? r.push([o.doBidiReorder(e[i][0]), e[i][1], e[i][2]]) : r.push([o.doBidiReorder(e[i])]);
        }

        t.text = r;
      } else t.text = o.doBidiReorder(e);
    }]);
  }(lt), window.tmp = _t, Ft.prototype.parseHeader = function () {
    if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
      var t = 0 === this.colors ? 1 << this.bitPP : this.colors;
      this.palette = new Array(t);

      for (var e = 0; e < t; e++) {
        var n = this.datav.getUint8(this.pos++, !0),
            r = this.datav.getUint8(this.pos++, !0),
            i = this.datav.getUint8(this.pos++, !0),
            o = this.datav.getUint8(this.pos++, !0);
        this.palette[e] = {
          red: i,
          green: r,
          blue: n,
          quad: o
        };
      }
    }

    this.height < 0 && (this.height *= -1, this.bottom_up = !1);
  }, Ft.prototype.parseBGR = function () {
    this.pos = this.offset;

    try {
      var t = "bit" + this.bitPP,
          e = this.width * this.height * 4;
      this.data = new Uint8Array(e), this[t]();
    } catch (t) {
      console.log("bit decode error:" + t);
    }
  }, Ft.prototype.bit1 = function () {
    var t = Math.ceil(this.width / 8),
        e = t % 4,
        n = 0 <= this.height ? this.height - 1 : -this.height;

    for (n = this.height - 1; 0 <= n; n--) {
      for (var r = this.bottom_up ? n : this.height - 1 - n, i = 0; i < t; i++) {
        for (var o = this.datav.getUint8(this.pos++, !0), a = r * this.width * 4 + 8 * i * 4, s = 0; s < 8 && 8 * i + s < this.width; s++) {
          var l = this.palette[o >> 7 - s & 1];
          this.data[a + 4 * s] = l.blue, this.data[a + 4 * s + 1] = l.green, this.data[a + 4 * s + 2] = l.red, this.data[a + 4 * s + 3] = 255;
        }
      }

      0 != e && (this.pos += 4 - e);
    }
  }, Ft.prototype.bit4 = function () {
    for (var t = Math.ceil(this.width / 2), e = t % 4, n = this.height - 1; 0 <= n; n--) {
      for (var r = this.bottom_up ? n : this.height - 1 - n, i = 0; i < t; i++) {
        var o = this.datav.getUint8(this.pos++, !0),
            a = r * this.width * 4 + 2 * i * 4,
            s = o >> 4,
            l = 15 & o,
            h = this.palette[s];
        if (this.data[a] = h.blue, this.data[a + 1] = h.green, this.data[a + 2] = h.red, this.data[a + 3] = 255, 2 * i + 1 >= this.width) break;
        h = this.palette[l], this.data[a + 4] = h.blue, this.data[a + 4 + 1] = h.green, this.data[a + 4 + 2] = h.red, this.data[a + 4 + 3] = 255;
      }

      0 != e && (this.pos += 4 - e);
    }
  }, Ft.prototype.bit8 = function () {
    for (var t = this.width % 4, e = this.height - 1; 0 <= e; e--) {
      for (var n = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
        var i = this.datav.getUint8(this.pos++, !0),
            o = n * this.width * 4 + 4 * r;

        if (i < this.palette.length) {
          var a = this.palette[i];
          this.data[o] = a.red, this.data[o + 1] = a.green, this.data[o + 2] = a.blue, this.data[o + 3] = 255;
        } else this.data[o] = 255, this.data[o + 1] = 255, this.data[o + 2] = 255, this.data[o + 3] = 255;
      }

      0 != t && (this.pos += 4 - t);
    }
  }, Ft.prototype.bit15 = function () {
    for (var t = this.width % 3, e = parseInt("11111", 2), n = this.height - 1; 0 <= n; n--) {
      for (var r = this.bottom_up ? n : this.height - 1 - n, i = 0; i < this.width; i++) {
        var o = this.datav.getUint16(this.pos, !0);
        this.pos += 2;
        var a = (o & e) / e * 255 | 0,
            s = (o >> 5 & e) / e * 255 | 0,
            l = (o >> 10 & e) / e * 255 | 0,
            h = o >> 15 ? 255 : 0,
            u = r * this.width * 4 + 4 * i;
        this.data[u] = l, this.data[u + 1] = s, this.data[u + 2] = a, this.data[u + 3] = h;
      }

      this.pos += t;
    }
  }, Ft.prototype.bit16 = function () {
    for (var t = this.width % 3, e = parseInt("11111", 2), n = parseInt("111111", 2), r = this.height - 1; 0 <= r; r--) {
      for (var i = this.bottom_up ? r : this.height - 1 - r, o = 0; o < this.width; o++) {
        var a = this.datav.getUint16(this.pos, !0);
        this.pos += 2;
        var s = (a & e) / e * 255 | 0,
            l = (a >> 5 & n) / n * 255 | 0,
            h = (a >> 11) / e * 255 | 0,
            u = i * this.width * 4 + 4 * o;
        this.data[u] = h, this.data[u + 1] = l, this.data[u + 2] = s, this.data[u + 3] = 255;
      }

      this.pos += t;
    }
  }, Ft.prototype.bit24 = function () {
    for (var t = this.height - 1; 0 <= t; t--) {
      for (var e = this.bottom_up ? t : this.height - 1 - t, n = 0; n < this.width; n++) {
        var r = this.datav.getUint8(this.pos++, !0),
            i = this.datav.getUint8(this.pos++, !0),
            o = this.datav.getUint8(this.pos++, !0),
            a = e * this.width * 4 + 4 * n;
        this.data[a] = o, this.data[a + 1] = i, this.data[a + 2] = r, this.data[a + 3] = 255;
      }

      this.pos += this.width % 4;
    }
  }, Ft.prototype.bit32 = function () {
    for (var t = this.height - 1; 0 <= t; t--) {
      for (var e = this.bottom_up ? t : this.height - 1 - t, n = 0; n < this.width; n++) {
        var r = this.datav.getUint8(this.pos++, !0),
            i = this.datav.getUint8(this.pos++, !0),
            o = this.datav.getUint8(this.pos++, !0),
            a = this.datav.getUint8(this.pos++, !0),
            s = e * this.width * 4 + 4 * n;
        this.data[s] = o, this.data[s + 1] = i, this.data[s + 2] = r, this.data[s + 3] = a;
      }
    }
  }, Ft.prototype.getData = function () {
    return this.data;
  }, window.tmp = Ft,
  /*
     Copyright (c) 2013 Gildas Lormeau. All rights reserved.
  
     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions are met:
  
     1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.
  
     2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.
  
     3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.
  
     THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
     INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
     INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
  function (t) {
    var d = 15,
        g = 573,
        e = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];

    function ct() {
      var p = this;

      function l(t, e) {
        for (var n = 0; n |= 1 & t, t >>>= 1, n <<= 1, 0 < --e;) {
          ;
        }

        return n >>> 1;
      }

      p.build_tree = function (t) {
        var e,
            n,
            r,
            i = p.dyn_tree,
            o = p.stat_desc.static_tree,
            a = p.stat_desc.elems,
            s = -1;

        for (t.heap_len = 0, t.heap_max = g, e = 0; e < a; e++) {
          0 !== i[2 * e] ? (t.heap[++t.heap_len] = s = e, t.depth[e] = 0) : i[2 * e + 1] = 0;
        }

        for (; t.heap_len < 2;) {
          i[2 * (r = t.heap[++t.heap_len] = s < 2 ? ++s : 0)] = 1, t.depth[r] = 0, t.opt_len--, o && (t.static_len -= o[2 * r + 1]);
        }

        for (p.max_code = s, e = Math.floor(t.heap_len / 2); 1 <= e; e--) {
          t.pqdownheap(i, e);
        }

        for (r = a; e = t.heap[1], t.heap[1] = t.heap[t.heap_len--], t.pqdownheap(i, 1), n = t.heap[1], t.heap[--t.heap_max] = e, t.heap[--t.heap_max] = n, i[2 * r] = i[2 * e] + i[2 * n], t.depth[r] = Math.max(t.depth[e], t.depth[n]) + 1, i[2 * e + 1] = i[2 * n + 1] = r, t.heap[1] = r++, t.pqdownheap(i, 1), 2 <= t.heap_len;) {
          ;
        }

        t.heap[--t.heap_max] = t.heap[1], function (t) {
          var e,
              n,
              r,
              i,
              o,
              a,
              s = p.dyn_tree,
              l = p.stat_desc.static_tree,
              h = p.stat_desc.extra_bits,
              u = p.stat_desc.extra_base,
              c = p.stat_desc.max_length,
              f = 0;

          for (i = 0; i <= d; i++) {
            t.bl_count[i] = 0;
          }

          for (s[2 * t.heap[t.heap_max] + 1] = 0, e = t.heap_max + 1; e < g; e++) {
            c < (i = s[2 * s[2 * (n = t.heap[e]) + 1] + 1] + 1) && (i = c, f++), s[2 * n + 1] = i, n > p.max_code || (t.bl_count[i]++, o = 0, u <= n && (o = h[n - u]), a = s[2 * n], t.opt_len += a * (i + o), l && (t.static_len += a * (l[2 * n + 1] + o)));
          }

          if (0 !== f) {
            do {
              for (i = c - 1; 0 === t.bl_count[i];) {
                i--;
              }

              t.bl_count[i]--, t.bl_count[i + 1] += 2, t.bl_count[c]--, f -= 2;
            } while (0 < f);

            for (i = c; 0 !== i; i--) {
              for (n = t.bl_count[i]; 0 !== n;) {
                (r = t.heap[--e]) > p.max_code || (s[2 * r + 1] != i && (t.opt_len += (i - s[2 * r + 1]) * s[2 * r], s[2 * r + 1] = i), n--);
              }
            }
          }
        }(t), function (t, e, n) {
          var r,
              i,
              o,
              a = [],
              s = 0;

          for (r = 1; r <= d; r++) {
            a[r] = s = s + n[r - 1] << 1;
          }

          for (i = 0; i <= e; i++) {
            0 !== (o = t[2 * i + 1]) && (t[2 * i] = l(a[o]++, o));
          }
        }(i, p.max_code, t.bl_count);
      };
    }

    function ft(t, e, n, r, i) {
      this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = i;
    }

    ct._length_code = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28], ct.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0], ct.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576], ct.d_code = function (t) {
      return t < 256 ? e[t] : e[256 + (t >>> 7)];
    }, ct.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], ct.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], ct.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ct.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], ft.static_ltree = [12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8, 130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8], ft.static_dtree = [0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5], ft.static_l_desc = new ft(ft.static_ltree, ct.extra_lbits, 257, 286, d), ft.static_d_desc = new ft(ft.static_dtree, ct.extra_dbits, 0, 30, d), ft.static_bl_desc = new ft(null, ct.extra_blbits, 0, 19, 7);

    function n(t, e, n, r, i) {
      this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = i;
    }

    var pt = [new n(0, 0, 0, 0, 0), new n(4, 4, 8, 4, 1), new n(4, 5, 16, 8, 1), new n(4, 6, 32, 32, 1), new n(4, 4, 16, 16, 2), new n(8, 16, 32, 32, 2), new n(8, 16, 128, 128, 2), new n(8, 32, 128, 256, 2), new n(32, 128, 258, 1024, 2), new n(32, 258, 258, 4096, 2)],
        dt = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""];

    function gt(t, e, n, r) {
      var i = t[2 * e],
          o = t[2 * n];
      return i < o || i == o && r[e] <= r[n];
    }

    function r() {
      var l,
          h,
          u,
          c,
          f,
          p,
          d,
          g,
          i,
          m,
          y,
          v,
          w,
          a,
          b,
          x,
          N,
          L,
          A,
          S,
          _,
          F,
          P,
          k,
          I,
          C,
          B,
          j,
          E,
          M,
          s,
          O,
          q,
          T,
          R,
          D,
          U,
          o,
          z,
          H,
          W,
          V = this,
          G = new ct(),
          Y = new ct(),
          J = new ct();

      function X() {
        var t;

        for (t = 0; t < 286; t++) {
          s[2 * t] = 0;
        }

        for (t = 0; t < 30; t++) {
          O[2 * t] = 0;
        }

        for (t = 0; t < 19; t++) {
          q[2 * t] = 0;
        }

        s[512] = 1, V.opt_len = V.static_len = 0, D = o = 0;
      }

      function K(t, e) {
        var n,
            r,
            i = -1,
            o = t[1],
            a = 0,
            s = 7,
            l = 4;

        for (0 === o && (s = 138, l = 3), t[2 * (e + 1) + 1] = 65535, n = 0; n <= e; n++) {
          r = o, o = t[2 * (n + 1) + 1], ++a < s && r == o || (a < l ? q[2 * r] += a : 0 !== r ? (r != i && q[2 * r]++, q[32]++) : a <= 10 ? q[34]++ : q[36]++, i = r, l = (a = 0) === o ? (s = 138, 3) : r == o ? (s = 6, 3) : (s = 7, 4));
        }
      }

      function Z(t) {
        V.pending_buf[V.pending++] = t;
      }

      function Q(t) {
        Z(255 & t), Z(t >>> 8 & 255);
      }

      function $(t, e) {
        var n,
            r = e;
        16 - r < W ? (Q(H |= (n = t) << W & 65535), H = n >>> 16 - W, W += r - 16) : (H |= t << W & 65535, W += r);
      }

      function tt(t, e) {
        var n = 2 * t;
        $(65535 & e[n], 65535 & e[n + 1]);
      }

      function et(t, e) {
        var n,
            r,
            i = -1,
            o = t[1],
            a = 0,
            s = 7,
            l = 4;

        for (0 === o && (s = 138, l = 3), n = 0; n <= e; n++) {
          if (r = o, o = t[2 * (n + 1) + 1], !(++a < s && r == o)) {
            if (a < l) for (; tt(r, q), 0 != --a;) {
              ;
            } else 0 !== r ? (r != i && (tt(r, q), a--), tt(16, q), $(a - 3, 2)) : a <= 10 ? (tt(17, q), $(a - 3, 3)) : (tt(18, q), $(a - 11, 7));
            i = r, l = (a = 0) === o ? (s = 138, 3) : r == o ? (s = 6, 3) : (s = 7, 4);
          }
        }
      }

      function nt() {
        16 == W ? (Q(H), W = H = 0) : 8 <= W && (Z(255 & H), H >>>= 8, W -= 8);
      }

      function rt(t, e) {
        var n, r, i;

        if (V.pending_buf[U + 2 * D] = t >>> 8 & 255, V.pending_buf[U + 2 * D + 1] = 255 & t, V.pending_buf[T + D] = 255 & e, D++, 0 === t ? s[2 * e]++ : (o++, t--, s[2 * (ct._length_code[e] + 256 + 1)]++, O[2 * ct.d_code(t)]++), 0 == (8191 & D) && 2 < B) {
          for (n = 8 * D, r = _ - N, i = 0; i < 30; i++) {
            n += O[2 * i] * (5 + ct.extra_dbits[i]);
          }

          if (n >>>= 3, o < Math.floor(D / 2) && n < Math.floor(r / 2)) return !0;
        }

        return D == R - 1;
      }

      function it(t, e) {
        var n,
            r,
            i,
            o,
            a = 0;
        if (0 !== D) for (; n = V.pending_buf[U + 2 * a] << 8 & 65280 | 255 & V.pending_buf[U + 2 * a + 1], r = 255 & V.pending_buf[T + a], a++, 0 === n ? tt(r, t) : (tt((i = ct._length_code[r]) + 256 + 1, t), 0 !== (o = ct.extra_lbits[i]) && $(r -= ct.base_length[i], o), tt(i = ct.d_code(--n), e), 0 !== (o = ct.extra_dbits[i]) && $(n -= ct.base_dist[i], o)), a < D;) {
          ;
        }
        tt(256, t), z = t[513];
      }

      function ot() {
        8 < W ? Q(H) : 0 < W && Z(255 & H), W = H = 0;
      }

      function at(t, e, n) {
        var r, i, o;
        $(0 + (n ? 1 : 0), 3), r = t, i = e, o = !0, ot(), z = 8, o && (Q(i), Q(~i)), V.pending_buf.set(g.subarray(r, r + i), V.pending), V.pending += i;
      }

      function e(t, e, n) {
        var r,
            i,
            o = 0;
        0 < B ? (G.build_tree(V), Y.build_tree(V), o = function () {
          var t;

          for (K(s, G.max_code), K(O, Y.max_code), J.build_tree(V), t = 18; 3 <= t && 0 === q[2 * ct.bl_order[t] + 1]; t--) {
            ;
          }

          return V.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
        }(), r = V.opt_len + 3 + 7 >>> 3, (i = V.static_len + 3 + 7 >>> 3) <= r && (r = i)) : r = i = e + 5, e + 4 <= r && -1 != t ? at(t, e, n) : i == r ? ($(2 + (n ? 1 : 0), 3), it(ft.static_ltree, ft.static_dtree)) : ($(4 + (n ? 1 : 0), 3), function (t, e, n) {
          var r;

          for ($(t - 257, 5), $(e - 1, 5), $(n - 4, 4), r = 0; r < n; r++) {
            $(q[2 * ct.bl_order[r] + 1], 3);
          }

          et(s, t - 1), et(O, e - 1);
        }(G.max_code + 1, Y.max_code + 1, o + 1), it(s, O)), X(), n && ot();
      }

      function st(t) {
        e(0 <= N ? N : -1, _ - N, t), N = _, l.flush_pending();
      }

      function lt() {
        var t, e, n, r;

        do {
          if (0 === (r = i - P - _) && 0 === _ && 0 === P) r = f;else if (-1 == r) r--;else if (f + f - 262 <= _) {
            for (g.set(g.subarray(f, f + f), 0), F -= f, _ -= f, N -= f, n = t = w; e = 65535 & y[--n], y[n] = f <= e ? e - f : 0, 0 != --t;) {
              ;
            }

            for (n = t = f; e = 65535 & m[--n], m[n] = f <= e ? e - f : 0, 0 != --t;) {
              ;
            }

            r += f;
          }
          if (0 === l.avail_in) return;
          t = l.read_buf(g, _ + P, r), 3 <= (P += t) && (v = ((v = 255 & g[_]) << x ^ 255 & g[_ + 1]) & b);
        } while (P < 262 && 0 !== l.avail_in);
      }

      function ht(t) {
        var e,
            n,
            r = I,
            i = _,
            o = k,
            a = f - 262 < _ ? _ - (f - 262) : 0,
            s = M,
            l = d,
            h = _ + 258,
            u = g[i + o - 1],
            c = g[i + o];
        E <= k && (r >>= 2), P < s && (s = P);

        do {
          if (g[(e = t) + o] == c && g[e + o - 1] == u && g[e] == g[i] && g[++e] == g[i + 1]) {
            i += 2, e++;

            do {} while (g[++i] == g[++e] && g[++i] == g[++e] && g[++i] == g[++e] && g[++i] == g[++e] && g[++i] == g[++e] && g[++i] == g[++e] && g[++i] == g[++e] && g[++i] == g[++e] && i < h);

            if (n = 258 - (h - i), i = h - 258, o < n) {
              if (F = t, s <= (o = n)) break;
              u = g[i + o - 1], c = g[i + o];
            }
          }
        } while ((t = 65535 & m[t & l]) > a && 0 != --r);

        return o <= P ? o : P;
      }

      function ut(t) {
        return t.total_in = t.total_out = 0, t.msg = null, V.pending = 0, V.pending_out = 0, h = 113, c = 0, G.dyn_tree = s, G.stat_desc = ft.static_l_desc, Y.dyn_tree = O, Y.stat_desc = ft.static_d_desc, J.dyn_tree = q, J.stat_desc = ft.static_bl_desc, W = H = 0, z = 8, X(), function () {
          var t;

          for (i = 2 * f, t = y[w - 1] = 0; t < w - 1; t++) {
            y[t] = 0;
          }

          C = pt[B].max_lazy, E = pt[B].good_length, M = pt[B].nice_length, I = pt[B].max_chain, L = k = 2, v = S = P = N = _ = 0;
        }(), 0;
      }

      V.depth = [], V.bl_count = [], V.heap = [], s = [], O = [], q = [], V.pqdownheap = function (t, e) {
        for (var n = V.heap, r = n[e], i = e << 1; i <= V.heap_len && (i < V.heap_len && gt(t, n[i + 1], n[i], V.depth) && i++, !gt(t, r, n[i], V.depth));) {
          n[e] = n[i], e = i, i <<= 1;
        }

        n[e] = r;
      }, V.deflateInit = function (t, e, n, r, i, o) {
        return r || (r = 8), i || (i = 8), o || (o = 0), t.msg = null, -1 == e && (e = 6), i < 1 || 9 < i || 8 != r || n < 9 || 15 < n || e < 0 || 9 < e || o < 0 || 2 < o ? -2 : (t.dstate = V, d = (f = 1 << (p = n)) - 1, b = (w = 1 << (a = i + 7)) - 1, x = Math.floor((a + 3 - 1) / 3), g = new Uint8Array(2 * f), m = [], y = [], R = 1 << i + 6, V.pending_buf = new Uint8Array(4 * R), u = 4 * R, U = Math.floor(R / 2), T = 3 * R, B = e, j = o, ut(t));
      }, V.deflateEnd = function () {
        return 42 != h && 113 != h && 666 != h ? -2 : (V.pending_buf = null, g = m = y = null, V.dstate = null, 113 == h ? -3 : 0);
      }, V.deflateParams = function (t, e, n) {
        var r = 0;
        return -1 == e && (e = 6), e < 0 || 9 < e || n < 0 || 2 < n ? -2 : (pt[B].func != pt[e].func && 0 !== t.total_in && (r = t.deflate(1)), B != e && (C = pt[B = e].max_lazy, E = pt[B].good_length, M = pt[B].nice_length, I = pt[B].max_chain), j = n, r);
      }, V.deflateSetDictionary = function (t, e, n) {
        var r,
            i = n,
            o = 0;
        if (!e || 42 != h) return -2;
        if (i < 3) return 0;

        for (f - 262 < i && (o = n - (i = f - 262)), g.set(e.subarray(o, o + i), 0), N = _ = i, v = ((v = 255 & g[0]) << x ^ 255 & g[1]) & b, r = 0; r <= i - 3; r++) {
          v = (v << x ^ 255 & g[r + 2]) & b, m[r & d] = y[v], y[v] = r;
        }

        return 0;
      }, V.deflate = function (t, e) {
        var n, r, i, o, a, s;
        if (4 < e || e < 0) return -2;
        if (!t.next_out || !t.next_in && 0 !== t.avail_in || 666 == h && 4 != e) return t.msg = dt[4], -2;
        if (0 === t.avail_out) return t.msg = dt[7], -5;

        if (l = t, o = c, c = e, 42 == h && (r = 8 + (p - 8 << 4) << 8, 3 < (i = (B - 1 & 255) >> 1) && (i = 3), r |= i << 6, 0 !== _ && (r |= 32), h = 113, Z((s = r += 31 - r % 31) >> 8 & 255), Z(255 & s)), 0 !== V.pending) {
          if (l.flush_pending(), 0 === l.avail_out) return c = -1, 0;
        } else if (0 === l.avail_in && e <= o && 4 != e) return l.msg = dt[7], -5;

        if (666 == h && 0 !== l.avail_in) return t.msg = dt[7], -5;

        if (0 !== l.avail_in || 0 !== P || 0 != e && 666 != h) {
          switch (a = -1, pt[B].func) {
            case 0:
              a = function (t) {
                var e,
                    n = 65535;

                for (u - 5 < n && (n = u - 5);;) {
                  if (P <= 1) {
                    if (lt(), 0 === P && 0 == t) return 0;
                    if (0 === P) break;
                  }

                  if (_ += P, e = N + n, ((P = 0) === _ || e <= _) && (P = _ - e, _ = e, st(!1), 0 === l.avail_out)) return 0;
                  if (f - 262 <= _ - N && (st(!1), 0 === l.avail_out)) return 0;
                }

                return st(4 == t), 0 === l.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1;
              }(e);

              break;

            case 1:
              a = function (t) {
                for (var e, n = 0;;) {
                  if (P < 262) {
                    if (lt(), P < 262 && 0 == t) return 0;
                    if (0 === P) break;
                  }

                  if (3 <= P && (v = (v << x ^ 255 & g[_ + 2]) & b, n = 65535 & y[v], m[_ & d] = y[v], y[v] = _), 0 !== n && (_ - n & 65535) <= f - 262 && 2 != j && (L = ht(n)), 3 <= L) {
                    if (e = rt(_ - F, L - 3), P -= L, L <= C && 3 <= P) {
                      for (L--; v = (v << x ^ 255 & g[++_ + 2]) & b, n = 65535 & y[v], m[_ & d] = y[v], y[v] = _, 0 != --L;) {
                        ;
                      }

                      _++;
                    } else _ += L, L = 0, v = ((v = 255 & g[_]) << x ^ 255 & g[_ + 1]) & b;
                  } else e = rt(0, 255 & g[_]), P--, _++;
                  if (e && (st(!1), 0 === l.avail_out)) return 0;
                }

                return st(4 == t), 0 === l.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1;
              }(e);

              break;

            case 2:
              a = function (t) {
                for (var e, n, r = 0;;) {
                  if (P < 262) {
                    if (lt(), P < 262 && 0 == t) return 0;
                    if (0 === P) break;
                  }

                  if (3 <= P && (v = (v << x ^ 255 & g[_ + 2]) & b, r = 65535 & y[v], m[_ & d] = y[v], y[v] = _), k = L, A = F, L = 2, 0 !== r && k < C && (_ - r & 65535) <= f - 262 && (2 != j && (L = ht(r)), L <= 5 && (1 == j || 3 == L && 4096 < _ - F) && (L = 2)), 3 <= k && L <= k) {
                    for (n = _ + P - 3, e = rt(_ - 1 - A, k - 3), P -= k - 1, k -= 2; ++_ <= n && (v = (v << x ^ 255 & g[_ + 2]) & b, r = 65535 & y[v], m[_ & d] = y[v], y[v] = _), 0 != --k;) {
                      ;
                    }

                    if (S = 0, L = 2, _++, e && (st(!1), 0 === l.avail_out)) return 0;
                  } else if (0 !== S) {
                    if ((e = rt(0, 255 & g[_ - 1])) && st(!1), _++, P--, 0 === l.avail_out) return 0;
                  } else S = 1, _++, P--;
                }

                return 0 !== S && (e = rt(0, 255 & g[_ - 1]), S = 0), st(4 == t), 0 === l.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1;
              }(e);

          }

          if (2 != a && 3 != a || (h = 666), 0 == a || 2 == a) return 0 === l.avail_out && (c = -1), 0;

          if (1 == a) {
            if (1 == e) $(2, 3), tt(256, ft.static_ltree), nt(), 1 + z + 10 - W < 9 && ($(2, 3), tt(256, ft.static_ltree), nt()), z = 7;else if (at(0, 0, !1), 3 == e) for (n = 0; n < w; n++) {
              y[n] = 0;
            }
            if (l.flush_pending(), 0 === l.avail_out) return c = -1, 0;
          }
        }

        return 4 != e ? 0 : 1;
      };
    }

    function i() {
      this.next_in_index = 0, this.next_out_index = 0, this.avail_in = 0, this.total_in = 0, this.avail_out = 0, this.total_out = 0;
    }

    i.prototype = {
      deflateInit: function deflateInit(t, e) {
        return this.dstate = new r(), e || (e = d), this.dstate.deflateInit(this, t, e);
      },
      deflate: function deflate(t) {
        return this.dstate ? this.dstate.deflate(this, t) : -2;
      },
      deflateEnd: function deflateEnd() {
        if (!this.dstate) return -2;
        var t = this.dstate.deflateEnd();
        return this.dstate = null, t;
      },
      deflateParams: function deflateParams(t, e) {
        return this.dstate ? this.dstate.deflateParams(this, t, e) : -2;
      },
      deflateSetDictionary: function deflateSetDictionary(t, e) {
        return this.dstate ? this.dstate.deflateSetDictionary(this, t, e) : -2;
      },
      read_buf: function read_buf(t, e, n) {
        var r = this.avail_in;
        return n < r && (r = n), 0 === r ? 0 : (this.avail_in -= r, t.set(this.next_in.subarray(this.next_in_index, this.next_in_index + r), e), this.next_in_index += r, this.total_in += r, r);
      },
      flush_pending: function flush_pending() {
        var t = this,
            e = t.dstate.pending;
        e > t.avail_out && (e = t.avail_out), 0 !== e && (t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out, t.dstate.pending_out + e), t.next_out_index), t.next_out_index += e, t.dstate.pending_out += e, t.total_out += e, t.avail_out -= e, t.dstate.pending -= e, 0 === t.dstate.pending && (t.dstate.pending_out = 0));
      }
    };
    var o = t.zip || t;

    o.Deflater = o._jzlib_Deflater = function (t) {
      var s = new i(),
          l = new Uint8Array(512),
          e = t ? t.level : -1;
      void 0 === e && (e = -1), s.deflateInit(e), s.next_out = l, this.append = function (t, e) {
        var n,
            r = [],
            i = 0,
            o = 0,
            a = 0;

        if (t.length) {
          s.next_in_index = 0, s.next_in = t, s.avail_in = t.length;

          do {
            if (s.next_out_index = 0, s.avail_out = 512, 0 != s.deflate(0)) throw new Error("deflating: " + s.msg);
            s.next_out_index && (512 == s.next_out_index ? r.push(new Uint8Array(l)) : r.push(new Uint8Array(l.subarray(0, s.next_out_index)))), a += s.next_out_index, e && 0 < s.next_in_index && s.next_in_index != i && (e(s.next_in_index), i = s.next_in_index);
          } while (0 < s.avail_in || 0 === s.avail_out);

          return n = new Uint8Array(a), r.forEach(function (t) {
            n.set(t, o), o += t.length;
          }), n;
        }
      }, this.flush = function () {
        var t,
            e,
            n = [],
            r = 0,
            i = 0;

        do {
          if (s.next_out_index = 0, s.avail_out = 512, 1 != (t = s.deflate(4)) && 0 != t) throw new Error("deflating: " + s.msg);
          0 < 512 - s.avail_out && n.push(new Uint8Array(l.subarray(0, s.next_out_index))), i += s.next_out_index;
        } while (0 < s.avail_in || 0 === s.avail_out);

        return s.deflateEnd(), e = new Uint8Array(i), n.forEach(function (t) {
          e.set(t, r), r += t.length;
        }), e;
      };
    };
  }("undefined" != typeof self && self || "undefined" != typeof window && window || "undefined" != typeof global && global || Function('return typeof this === "object" && this.content')() || Function("return this")()), ("undefined" != typeof self && self || "undefined" != typeof window && window || "undefined" != typeof global && global || Function('return typeof this === "object" && this.content')() || Function("return this")()).RGBColor = function (t) {
    var e;
    t = t || "", this.ok = !1, "#" == t.charAt(0) && (t = t.substr(1, 6)), t = (t = t.replace(/ /g, "")).toLowerCase();
    var n = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dodgerblue: "1e90ff",
      feldspar: "d19275",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgrey: "d3d3d3",
      lightgreen: "90ee90",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslateblue: "8470ff",
      lightslategray: "778899",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "00ff00",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "ff00ff",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370d8",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "d87093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      red: "ff0000",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      violetred: "d02090",
      wheat: "f5deb3",
      white: "ffffff",
      whitesmoke: "f5f5f5",
      yellow: "ffff00",
      yellowgreen: "9acd32"
    };

    for (var r in n) {
      t == r && (t = n[r]);
    }

    for (var i = [{
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function process(t) {
        return [parseInt(t[1]), parseInt(t[2]), parseInt(t[3])];
      }
    }, {
      re: /^(\w{2})(\w{2})(\w{2})$/,
      example: ["#00ff00", "336699"],
      process: function process(t) {
        return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)];
      }
    }, {
      re: /^(\w{1})(\w{1})(\w{1})$/,
      example: ["#fb0", "f0f"],
      process: function process(t) {
        return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)];
      }
    }], o = 0; o < i.length; o++) {
      var a = i[o].re,
          s = i[o].process,
          l = a.exec(t);
      l && (e = s(l), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
    }

    this.r = this.r < 0 || isNaN(this.r) ? 0 : 255 < this.r ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : 255 < this.g ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : 255 < this.b ? 255 : this.b, this.toRGB = function () {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    }, this.toHex = function () {
      var t = this.r.toString(16),
          e = this.g.toString(16),
          n = this.b.toString(16);
      return 1 == t.length && (t = "0" + t), 1 == e.length && (e = "0" + e), 1 == n.length && (n = "0" + n), "#" + t + e + n;
    };
  }, function (t) {
    var n = "+".charCodeAt(0),
        r = "/".charCodeAt(0),
        i = "0".charCodeAt(0),
        o = "a".charCodeAt(0),
        a = "A".charCodeAt(0),
        s = "-".charCodeAt(0),
        l = "_".charCodeAt(0),
        u = function u(t) {
      var e = t.charCodeAt(0);
      return e === n || e === s ? 62 : e === r || e === l ? 63 : e < i ? -1 : e < i + 10 ? e - i + 26 + 26 : e < a + 26 ? e - a : e < o + 26 ? e - o + 26 : void 0;
    };

    t.API.TTFFont = function () {
      function i(t, e, n) {
        var r;

        if (this.rawData = t, r = this.contents = new J(t), this.contents.pos = 4, "ttcf" === r.readString(4)) {
          if (!e) throw new Error("Must specify a font name for TTC files.");
          throw new Error("Font " + e + " not found in TTC file.");
        }

        r.pos = 0, this.parse(), this.subset = new P(this), this.registerTTF();
      }

      return i.open = function (t, e, n, r) {
        if ("string" != typeof n) throw new Error("Invalid argument supplied in TTFFont.open");
        return new i(function (t) {
          var e, n, r, i, o, a;
          if (0 < t.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
          var s = t.length;
          o = "=" === t.charAt(s - 2) ? 2 : "=" === t.charAt(s - 1) ? 1 : 0, a = new Uint8Array(3 * t.length / 4 - o), r = 0 < o ? t.length - 4 : t.length;
          var l = 0;

          function h(t) {
            a[l++] = t;
          }

          for (n = e = 0; e < r; e += 4, n += 3) {
            h((16711680 & (i = u(t.charAt(e)) << 18 | u(t.charAt(e + 1)) << 12 | u(t.charAt(e + 2)) << 6 | u(t.charAt(e + 3)))) >> 16), h((65280 & i) >> 8), h(255 & i);
          }

          return 2 === o ? h(255 & (i = u(t.charAt(e)) << 2 | u(t.charAt(e + 1)) >> 4)) : 1 === o && (h((i = u(t.charAt(e)) << 10 | u(t.charAt(e + 1)) << 4 | u(t.charAt(e + 2)) >> 2) >> 8 & 255), h(255 & i)), a;
        }(n), e, r);
      }, i.prototype.parse = function () {
        return this.directory = new e(this.contents), this.head = new p(this), this.name = new b(this), this.cmap = new y(this), this.toUnicode = new Map(), this.hhea = new g(this), this.maxp = new x(this), this.hmtx = new N(this), this.post = new v(this), this.os2 = new m(this), this.loca = new F(this), this.glyf = new A(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
      }, i.prototype.registerTTF = function () {
        var i, t, e, n, r;
        if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function () {
          var t, e, n, r;

          for (r = [], t = 0, e = (n = this.bbox).length; t < e; t++) {
            i = n[t], r.push(Math.round(i * this.scaleFactor));
          }

          return r;
        }.call(this), this.stemV = 0, this.post.exists ? (e = 255 & (n = this.post.italic_angle), !0 & (t = n >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + e)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (r = this.familyClass) || 2 === r || 3 === r || 4 === r || 5 === r || 7 === r, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
      }, i.prototype.characterToGlyph = function (t) {
        var e;
        return (null != (e = this.cmap.unicode) ? e.codeMap[t] : void 0) || 0;
      }, i.prototype.widthOfGlyph = function (t) {
        var e;
        return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * e;
      }, i.prototype.widthOfString = function (t, e, n) {
        var r, i, o, a, s;

        for (i = a = o = 0, s = (t = "" + t).length; 0 <= s ? a < s : s < a; i = 0 <= s ? ++a : --a) {
          r = t.charCodeAt(i), o += this.widthOfGlyph(this.characterToGlyph(r)) + n * (1e3 / e) || 0;
        }

        return o * (e / 1e3);
      }, i.prototype.lineHeight = function (t, e) {
        var n;
        return null == e && (e = !1), n = e ? this.lineGap : 0, (this.ascender + n - this.decender) / 1e3 * t;
      }, i;
    }();

    var h,
        J = function () {
      function t(t) {
        this.data = null != t ? t : [], this.pos = 0, this.length = this.data.length;
      }

      return t.prototype.readByte = function () {
        return this.data[this.pos++];
      }, t.prototype.writeByte = function (t) {
        return this.data[this.pos++] = t;
      }, t.prototype.readUInt32 = function () {
        return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
      }, t.prototype.writeUInt32 = function (t) {
        return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
      }, t.prototype.readInt32 = function () {
        var t;
        return 2147483648 <= (t = this.readUInt32()) ? t - 4294967296 : t;
      }, t.prototype.writeInt32 = function (t) {
        return t < 0 && (t += 4294967296), this.writeUInt32(t);
      }, t.prototype.readUInt16 = function () {
        return this.readByte() << 8 | this.readByte();
      }, t.prototype.writeUInt16 = function (t) {
        return this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
      }, t.prototype.readInt16 = function () {
        var t;
        return 32768 <= (t = this.readUInt16()) ? t - 65536 : t;
      }, t.prototype.writeInt16 = function (t) {
        return t < 0 && (t += 65536), this.writeUInt16(t);
      }, t.prototype.readString = function (t) {
        var e, n, r;

        for (n = [], e = r = 0; 0 <= t ? r < t : t < r; e = 0 <= t ? ++r : --r) {
          n[e] = String.fromCharCode(this.readByte());
        }

        return n.join("");
      }, t.prototype.writeString = function (t) {
        var e, n, r, i;

        for (i = [], e = n = 0, r = t.length; 0 <= r ? n < r : r < n; e = 0 <= r ? ++n : --n) {
          i.push(this.writeByte(t.charCodeAt(e)));
        }

        return i;
      }, t.prototype.readShort = function () {
        return this.readInt16();
      }, t.prototype.writeShort = function (t) {
        return this.writeInt16(t);
      }, t.prototype.readLongLong = function () {
        var t, e, n, r, i, o, a, s;
        return t = this.readByte(), e = this.readByte(), n = this.readByte(), r = this.readByte(), i = this.readByte(), o = this.readByte(), a = this.readByte(), s = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ n) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ i) + 65536 * (255 ^ o) + 256 * (255 ^ a) + (255 ^ s) + 1) : 72057594037927940 * t + 281474976710656 * e + 1099511627776 * n + 4294967296 * r + 16777216 * i + 65536 * o + 256 * a + s;
      }, t.prototype.writeLongLong = function (t) {
        var e, n;
        return e = Math.floor(t / 4294967296), n = 4294967295 & t, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(n >> 24 & 255), this.writeByte(n >> 16 & 255), this.writeByte(n >> 8 & 255), this.writeByte(255 & n);
      }, t.prototype.readInt = function () {
        return this.readInt32();
      }, t.prototype.writeInt = function (t) {
        return this.writeInt32(t);
      }, t.prototype.read = function (t) {
        var e, n;

        for (e = [], n = 0; 0 <= t ? n < t : t < n; 0 <= t ? ++n : --n) {
          e.push(this.readByte());
        }

        return e;
      }, t.prototype.write = function (t) {
        var e, n, r, i;

        for (i = [], n = 0, r = t.length; n < r; n++) {
          e = t[n], i.push(this.writeByte(e));
        }

        return i;
      }, t;
    }(),
        e = function () {
      var d;

      function t(t) {
        var e, n, r;

        for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, n = 0, r = this.tableCount; 0 <= r ? n < r : r < n; 0 <= r ? ++n : --n) {
          e = {
            tag: t.readString(4),
            checksum: t.readInt(),
            offset: t.readInt(),
            length: t.readInt()
          }, this.tables[e.tag] = e;
        }
      }

      return t.prototype.encode = function (t) {
        var e, n, r, i, o, a, s, l, h, u, c, f, p;

        for (p in c = Object.keys(t).length, a = Math.log(2), h = 16 * Math.floor(Math.log(c) / a), i = Math.floor(h / a), l = 16 * c - h, (n = new J()).writeInt(this.scalarType), n.writeShort(c), n.writeShort(h), n.writeShort(i), n.writeShort(l), r = 16 * c, s = n.pos + r, o = null, f = [], t) {
          for (u = t[p], n.writeString(p), n.writeInt(d(u)), n.writeInt(s), n.writeInt(u.length), f = f.concat(u), "head" === p && (o = s), s += u.length; s % 4;) {
            f.push(0), s++;
          }
        }

        return n.write(f), e = 2981146554 - d(n.data), n.pos = o + 8, n.writeUInt32(e), n.data;
      }, d = function d(t) {
        var e, n, r, i;

        for (t = L.call(t); t.length % 4;) {
          t.push(0);
        }

        for (n = new J(t), r = e = 0, i = t.length; r < i; r += 4) {
          e += n.readUInt32();
        }

        return 4294967295 & e;
      }, t;
    }(),
        c = {}.hasOwnProperty,
        f = function f(t, e) {
      for (var n in e) {
        c.call(e, n) && (t[n] = e[n]);
      }

      function r() {
        this.constructor = t;
      }

      return r.prototype = e.prototype, t.prototype = new r(), t.__super__ = e.prototype, t;
    };

    h = function () {
      function t(t) {
        var e;
        this.file = t, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
      }

      return t.prototype.parse = function () {}, t.prototype.encode = function () {}, t.prototype.raw = function () {
        return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
      }, t;
    }();

    var p = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "head", e.prototype.parse = function (t) {
        return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
      }, e.prototype.encode = function (t) {
        var e;
        return (e = new J()).writeInt(this.version), e.writeInt(this.revision), e.writeInt(this.checkSumAdjustment), e.writeInt(this.magicNumber), e.writeShort(this.flags), e.writeShort(this.unitsPerEm), e.writeLongLong(this.created), e.writeLongLong(this.modified), e.writeShort(this.xMin), e.writeShort(this.yMin), e.writeShort(this.xMax), e.writeShort(this.yMax), e.writeShort(this.macStyle), e.writeShort(this.lowestRecPPEM), e.writeShort(this.fontDirectionHint), e.writeShort(t), e.writeShort(this.glyphDataFormat), e.data;
      }, e;
    }(),
        d = function () {
      function t(n, t) {
        var e, r, i, o, a, s, l, h, u, c, f, p, d, g, m, y, v, w;

        switch (this.platformID = n.readUInt16(), this.encodingID = n.readShort(), this.offset = t + n.readInt(), u = n.pos, n.pos = this.offset, this.format = n.readUInt16(), this.length = n.readUInt16(), this.language = n.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
          case 0:
            for (s = m = 0; m < 256; s = ++m) {
              this.codeMap[s] = n.readByte();
            }

            break;

          case 4:
            for (f = n.readUInt16(), c = f / 2, n.pos += 6, i = function () {
              var t, e;

              for (e = [], s = t = 0; 0 <= c ? t < c : c < t; s = 0 <= c ? ++t : --t) {
                e.push(n.readUInt16());
              }

              return e;
            }(), n.pos += 2, d = function () {
              var t, e;

              for (e = [], s = t = 0; 0 <= c ? t < c : c < t; s = 0 <= c ? ++t : --t) {
                e.push(n.readUInt16());
              }

              return e;
            }(), l = function () {
              var t, e;

              for (e = [], s = t = 0; 0 <= c ? t < c : c < t; s = 0 <= c ? ++t : --t) {
                e.push(n.readUInt16());
              }

              return e;
            }(), h = function () {
              var t, e;

              for (e = [], s = t = 0; 0 <= c ? t < c : c < t; s = 0 <= c ? ++t : --t) {
                e.push(n.readUInt16());
              }

              return e;
            }(), r = (this.length - n.pos + this.offset) / 2, a = function () {
              var t, e;

              for (e = [], s = t = 0; 0 <= r ? t < r : r < t; s = 0 <= r ? ++t : --t) {
                e.push(n.readUInt16());
              }

              return e;
            }(), s = y = 0, w = i.length; y < w; s = ++y) {
              for (g = i[s], e = v = p = d[s]; p <= g ? v <= g : g <= v; e = p <= g ? ++v : --v) {
                0 === h[s] ? o = e + l[s] : 0 !== (o = a[h[s] / 2 + (e - p) - (c - s)] || 0) && (o += l[s]), this.codeMap[e] = 65535 & o;
              }
            }

        }

        n.pos = u;
      }

      return t.encode = function (t, e) {
        var n, r, i, o, a, s, l, h, u, c, f, p, d, g, m, y, v, w, b, x, N, L, A, S, _, F, P, k, I, C, B, j, E, M, O, q, T, R, D, U, z, H, W, V, G, Y;

        switch (k = new J(), o = Object.keys(t).sort(function (t, e) {
          return t - e;
        }), e) {
          case "macroman":
            for (d = 0, g = function () {
              var t, e;

              for (e = [], p = t = 0; t < 256; p = ++t) {
                e.push(0);
              }

              return e;
            }(), y = {
              0: 0
            }, i = {}, I = 0, E = o.length; I < E; I++) {
              null == y[W = t[r = o[I]]] && (y[W] = ++d), i[r] = {
                old: t[r],
                "new": y[t[r]]
              }, g[r] = y[t[r]];
            }

            return k.writeUInt16(1), k.writeUInt16(0), k.writeUInt32(12), k.writeUInt16(0), k.writeUInt16(262), k.writeUInt16(0), k.write(g), {
              charMap: i,
              subtable: k.data,
              maxGlyphID: d + 1
            };

          case "unicode":
            for (F = [], u = [], y = {}, n = {}, m = l = null, C = v = 0, M = o.length; C < M; C++) {
              null == y[b = t[r = o[C]]] && (y[b] = ++v), n[r] = {
                old: b,
                "new": y[b]
              }, a = y[b] - r, null != m && a === l || (m && u.push(m), F.push(r), l = a), m = r;
            }

            for (m && u.push(m), u.push(65535), F.push(65535), S = 2 * (A = F.length), L = 2 * Math.pow(Math.log(A) / Math.LN2, 2), c = Math.log(L / 2) / Math.LN2, N = 2 * A - L, s = [], x = [], f = [], p = B = 0, O = F.length; B < O; p = ++B) {
              if (_ = F[p], h = u[p], 65535 === _) {
                s.push(0), x.push(0);
                break;
              }

              if (32768 <= _ - (P = n[_]["new"])) for (s.push(0), x.push(2 * (f.length + A - p)), r = j = _; _ <= h ? j <= h : h <= j; r = _ <= h ? ++j : --j) {
                f.push(n[r]["new"]);
              } else s.push(P - _), x.push(0);
            }

            for (k.writeUInt16(3), k.writeUInt16(1), k.writeUInt32(12), k.writeUInt16(4), k.writeUInt16(16 + 8 * A + 2 * f.length), k.writeUInt16(0), k.writeUInt16(S), k.writeUInt16(L), k.writeUInt16(c), k.writeUInt16(N), z = 0, q = u.length; z < q; z++) {
              r = u[z], k.writeUInt16(r);
            }

            for (k.writeUInt16(0), H = 0, T = F.length; H < T; H++) {
              r = F[H], k.writeUInt16(r);
            }

            for (V = 0, R = s.length; V < R; V++) {
              a = s[V], k.writeUInt16(a);
            }

            for (G = 0, D = x.length; G < D; G++) {
              w = x[G], k.writeUInt16(w);
            }

            for (Y = 0, U = f.length; Y < U; Y++) {
              d = f[Y], k.writeUInt16(d);
            }

            return {
              charMap: n,
              subtable: k.data,
              maxGlyphID: v + 1
            };
        }
      }, t;
    }(),
        y = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "cmap", e.prototype.parse = function (t) {
        var e, n, r;

        for (t.pos = this.offset, this.version = t.readUInt16(), n = t.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= n ? r < n : n < r; 0 <= n ? ++r : --r) {
          e = new d(t, this.offset), this.tables.push(e), e.isUnicode && null == this.unicode && (this.unicode = e);
        }

        return !0;
      }, e.encode = function (t, e) {
        var n, r;
        return null == e && (e = "macroman"), n = d.encode(t, e), (r = new J()).writeUInt16(0), r.writeUInt16(1), n.table = r.data.concat(n.subtable), n;
      }, e;
    }(),
        g = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "hhea", e.prototype.parse = function (t) {
        return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
      }, e;
    }(),
        m = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "OS/2", e.prototype.parse = function (n) {
        if (n.pos = this.offset, this.version = n.readUInt16(), this.averageCharWidth = n.readShort(), this.weightClass = n.readUInt16(), this.widthClass = n.readUInt16(), this.type = n.readShort(), this.ySubscriptXSize = n.readShort(), this.ySubscriptYSize = n.readShort(), this.ySubscriptXOffset = n.readShort(), this.ySubscriptYOffset = n.readShort(), this.ySuperscriptXSize = n.readShort(), this.ySuperscriptYSize = n.readShort(), this.ySuperscriptXOffset = n.readShort(), this.ySuperscriptYOffset = n.readShort(), this.yStrikeoutSize = n.readShort(), this.yStrikeoutPosition = n.readShort(), this.familyClass = n.readShort(), this.panose = function () {
          var t, e;

          for (e = [], t = 0; t < 10; ++t) {
            e.push(n.readByte());
          }

          return e;
        }(), this.charRange = function () {
          var t, e;

          for (e = [], t = 0; t < 4; ++t) {
            e.push(n.readInt());
          }

          return e;
        }(), this.vendorID = n.readString(4), this.selection = n.readShort(), this.firstCharIndex = n.readShort(), this.lastCharIndex = n.readShort(), 0 < this.version && (this.ascent = n.readShort(), this.descent = n.readShort(), this.lineGap = n.readShort(), this.winAscent = n.readShort(), this.winDescent = n.readShort(), this.codePageRange = function () {
          var t, e;

          for (e = [], t = 0; t < 2; ++t) {
            e.push(n.readInt());
          }

          return e;
        }(), 1 < this.version)) return this.xHeight = n.readShort(), this.capHeight = n.readShort(), this.defaultChar = n.readShort(), this.breakChar = n.readShort(), this.maxContext = n.readShort();
      }, e;
    }(),
        v = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "post", e.prototype.parse = function (r) {
        var t, e, n, i;

        switch (r.pos = this.offset, this.format = r.readInt(), this.italicAngle = r.readInt(), this.underlinePosition = r.readShort(), this.underlineThickness = r.readShort(), this.isFixedPitch = r.readInt(), this.minMemType42 = r.readInt(), this.maxMemType42 = r.readInt(), this.minMemType1 = r.readInt(), this.maxMemType1 = r.readInt(), this.format) {
          case 65536:
            break;

          case 131072:
            for (e = r.readUInt16(), this.glyphNameIndex = [], n = 0; 0 <= e ? n < e : e < n; 0 <= e ? ++n : --n) {
              this.glyphNameIndex.push(r.readUInt16());
            }

            for (this.names = [], i = []; r.pos < this.offset + this.length;) {
              t = r.readByte(), i.push(this.names.push(r.readString(t)));
            }

            return i;

          case 151552:
            return e = r.readUInt16(), this.offsets = r.read(e);

          case 196608:
            break;

          case 262144:
            return this.map = function () {
              var t, e, n;

              for (n = [], t = 0, e = this.file.maxp.numGlyphs; 0 <= e ? t < e : e < t; 0 <= e ? ++t : --t) {
                n.push(r.readUInt32());
              }

              return n;
            }.call(this);
        }
      }, e;
    }(),
        w = function w(t, e) {
      this.raw = t, this.length = t.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
    },
        b = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "name", e.prototype.parse = function (t) {
        var e, n, r, i, o, a, s, l, h, u, c, f;

        for (t.pos = this.offset, t.readShort(), e = t.readShort(), a = t.readShort(), n = [], i = h = 0; 0 <= e ? h < e : e < h; i = 0 <= e ? ++h : --h) {
          n.push({
            platformID: t.readShort(),
            encodingID: t.readShort(),
            languageID: t.readShort(),
            nameID: t.readShort(),
            length: t.readShort(),
            offset: this.offset + a + t.readShort()
          });
        }

        for (s = {}, i = u = 0, c = n.length; u < c; i = ++u) {
          r = n[i], t.pos = r.offset, l = t.readString(r.length), o = new w(l, r), null == s[f = r.nameID] && (s[f] = []), s[r.nameID].push(o);
        }

        this.strings = s, this.copyright = s[0], this.fontFamily = s[1], this.fontSubfamily = s[2], this.uniqueSubfamily = s[3], this.fontName = s[4], this.version = s[5];

        try {
          this.postscriptName = s[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        } catch (t) {
          this.postscriptName = s[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        }

        return this.trademark = s[7], this.manufacturer = s[8], this.designer = s[9], this.description = s[10], this.vendorUrl = s[11], this.designerUrl = s[12], this.license = s[13], this.licenseUrl = s[14], this.preferredFamily = s[15], this.preferredSubfamily = s[17], this.compatibleFull = s[18], this.sampleText = s[19];
      }, e;
    }(),
        x = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "maxp", e.prototype.parse = function (t) {
        return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
      }, e;
    }(),
        N = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "hmtx", e.prototype.parse = function (n) {
        var t, r, i, e, o, a, s;

        for (n.pos = this.offset, this.metrics = [], e = 0, a = this.file.hhea.numberOfMetrics; 0 <= a ? e < a : a < e; 0 <= a ? ++e : --e) {
          this.metrics.push({
            advance: n.readUInt16(),
            lsb: n.readInt16()
          });
        }

        for (r = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function () {
          var t, e;

          for (e = [], t = 0; 0 <= r ? t < r : r < t; 0 <= r ? ++t : --t) {
            e.push(n.readInt16());
          }

          return e;
        }(), this.widths = function () {
          var t, e, n, r;

          for (r = [], t = 0, e = (n = this.metrics).length; t < e; t++) {
            i = n[t], r.push(i.advance);
          }

          return r;
        }.call(this), t = this.widths[this.widths.length - 1], s = [], o = 0; 0 <= r ? o < r : r < o; 0 <= r ? ++o : --o) {
          s.push(this.widths.push(t));
        }

        return s;
      }, e.prototype.forGlyph = function (t) {
        return t in this.metrics ? this.metrics[t] : {
          advance: this.metrics[this.metrics.length - 1].advance,
          lsb: this.leftSideBearings[t - this.metrics.length]
        };
      }, e;
    }(),
        L = [].slice,
        A = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "glyf", e.prototype.parse = function (t) {
        return this.cache = {};
      }, e.prototype.glyphFor = function (t) {
        var e, n, r, i, o, a, s, l, h, u;
        return (t = t) in this.cache ? this.cache[t] : (i = this.file.loca, e = this.file.contents, n = i.indexOf(t), 0 === (r = i.lengthOf(t)) ? this.cache[t] = null : (e.pos = this.offset + n, o = (a = new J(e.read(r))).readShort(), l = a.readShort(), u = a.readShort(), s = a.readShort(), h = a.readShort(), this.cache[t] = -1 === o ? new _(a, l, u, s, h) : new S(a, o, l, u, s, h), this.cache[t]));
      }, e.prototype.encode = function (t, e, n) {
        var r, i, o, a, s;

        for (o = [], i = [], a = 0, s = e.length; a < s; a++) {
          r = t[e[a]], i.push(o.length), r && (o = o.concat(r.encode(n)));
        }

        return i.push(o.length), {
          table: o,
          offsets: i
        };
      }, e;
    }(),
        S = function () {
      function t(t, e, n, r, i, o) {
        this.raw = t, this.numberOfContours = e, this.xMin = n, this.yMin = r, this.xMax = i, this.yMax = o, this.compound = !1;
      }

      return t.prototype.encode = function () {
        return this.raw.data;
      }, t;
    }(),
        _ = function () {
      function t(t, e, n, r, i) {
        var o, a;

        for (this.raw = t, this.xMin = e, this.yMin = n, this.xMax = r, this.yMax = i, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], o = this.raw; a = o.readShort(), this.glyphOffsets.push(o.pos), this.glyphIDs.push(o.readShort()), 32 & a;) {
          o.pos += 1 & a ? 4 : 2, 128 & a ? o.pos += 8 : 64 & a ? o.pos += 4 : 8 & a && (o.pos += 2);
        }
      }

      return 1, 8, 32, 64, 128, t.prototype.encode = function (t) {
        var e, n, r, i, o;

        for (n = new J(L.call(this.raw.data)), e = r = 0, i = (o = this.glyphIDs).length; r < i; e = ++r) {
          o[e], n.pos = this.glyphOffsets[e];
        }

        return n.data;
      }, t;
    }(),
        F = function (t) {
      function e() {
        return e.__super__.constructor.apply(this, arguments);
      }

      return f(e, h), e.prototype.tag = "loca", e.prototype.parse = function (r) {
        var t;
        return r.pos = this.offset, t = this.file.head.indexToLocFormat, this.offsets = 0 === t ? function () {
          var t, e, n;

          for (n = [], t = 0, e = this.length; t < e; t += 2) {
            n.push(2 * r.readUInt16());
          }

          return n;
        }.call(this) : function () {
          var t, e, n;

          for (n = [], t = 0, e = this.length; t < e; t += 4) {
            n.push(r.readUInt32());
          }

          return n;
        }.call(this);
      }, e.prototype.indexOf = function (t) {
        return this.offsets[t];
      }, e.prototype.lengthOf = function (t) {
        return this.offsets[t + 1] - this.offsets[t];
      }, e.prototype.encode = function (t, e) {
        for (var n = new Uint32Array(this.offsets.length), r = 0, i = 0, o = 0; o < n.length; ++o) {
          if (n[o] = r, i < e.length && e[i] == o) {
            ++i, n[o] = r;
            var a = this.offsets[o],
                s = this.offsets[o + 1] - a;
            0 < s && (r += s);
          }
        }

        for (var l = new Array(4 * n.length), h = 0; h < n.length; ++h) {
          l[4 * h + 3] = 255 & n[h], l[4 * h + 2] = (65280 & n[h]) >> 8, l[4 * h + 1] = (16711680 & n[h]) >> 16, l[4 * h] = (4278190080 & n[h]) >> 24;
        }

        return l;
      }, e;
    }(),
        P = function () {
      function t(t) {
        this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33;
      }

      return t.prototype.generateCmap = function () {
        var t, e, n, r, i;

        for (e in r = this.font.cmap.tables[0].codeMap, t = {}, i = this.subset) {
          n = i[e], t[e] = r[n];
        }

        return t;
      }, t.prototype.glyphsFor = function (t) {
        var e, n, r, i, o, a, s;

        for (r = {}, o = 0, a = t.length; o < a; o++) {
          r[i = t[o]] = this.font.glyf.glyphFor(i);
        }

        for (i in e = [], r) {
          (null != (n = r[i]) ? n.compound : void 0) && e.push.apply(e, n.glyphIDs);
        }

        if (0 < e.length) for (i in s = this.glyphsFor(e)) {
          n = s[i], r[i] = n;
        }
        return r;
      }, t.prototype.encode = function (t, e) {
        var n, r, i, o, a, s, l, h, u, c, f, p, d, g, m;

        for (r in n = y.encode(this.generateCmap(), "unicode"), o = this.glyphsFor(t), f = {
          0: 0
        }, m = n.charMap) {
          f[(s = m[r]).old] = s["new"];
        }

        for (p in c = n.maxGlyphID, o) {
          p in f || (f[p] = c++);
        }

        return h = function (t) {
          var e, n;

          for (e in n = {}, t) {
            n[t[e]] = e;
          }

          return n;
        }(f), u = Object.keys(h).sort(function (t, e) {
          return t - e;
        }), d = function () {
          var t, e, n;

          for (n = [], t = 0, e = u.length; t < e; t++) {
            a = u[t], n.push(h[a]);
          }

          return n;
        }(), i = this.font.glyf.encode(o, d, f), l = this.font.loca.encode(i.offsets, d), g = {
          cmap: this.font.cmap.raw(),
          glyf: i.table,
          loca: l,
          hmtx: this.font.hmtx.raw(),
          hhea: this.font.hhea.raw(),
          maxp: this.font.maxp.raw(),
          post: this.font.post.raw(),
          name: this.font.name.raw(),
          head: this.font.head.encode(e)
        }, this.font.os2.exists && (g["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g);
      }, t;
    }();

    t.API.PDFObject = function () {
      var o;

      function a() {}

      return o = function o(t, e) {
        return (Array(e + 1).join("0") + t).slice(-e);
      }, a.convert = function (r) {
        var i, t, e, n;
        if (Array.isArray(r)) return "[" + function () {
          var t, e, n;

          for (n = [], t = 0, e = r.length; t < e; t++) {
            i = r[t], n.push(a.convert(i));
          }

          return n;
        }().join(" ") + "]";
        if ("string" == typeof r) return "/" + r;
        if (null != r ? r.isString : void 0) return "(" + r + ")";
        if (r instanceof Date) return "(D:" + o(r.getUTCFullYear(), 4) + o(r.getUTCMonth(), 2) + o(r.getUTCDate(), 2) + o(r.getUTCHours(), 2) + o(r.getUTCMinutes(), 2) + o(r.getUTCSeconds(), 2) + "Z)";
        if ("[object Object]" !== {}.toString.call(r)) return "" + r;

        for (t in e = ["<<"], r) {
          n = r[t], e.push("/" + t + " " + a.convert(n));
        }

        return e.push(">>"), e.join("\n");
      }, a;
    }();
  }(lt),
  /*
    # PNG.js
    # Copyright (c) 2011 Devon Govett
    # MIT LICENSE
    # 
    # 
    */
  Nt = "undefined" != typeof self && self || "undefined" != typeof window && window || "undefined" != typeof global && global || Function('return typeof this === "object" && this.content')() || Function("return this")(), Lt = function () {
    var h, n, r;

    function i(t) {
      var e, n, r, i, o, a, s, l, h, u, c, f, p, d;

      for (this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, a = null;;) {
        switch (e = this.readUInt32(), h = function () {
          var t, e;

          for (e = [], t = 0; t < 4; ++t) {
            e.push(String.fromCharCode(this.data[this.pos++]));
          }

          return e;
        }.call(this).join("")) {
          case "IHDR":
            this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
            break;

          case "acTL":
            this.animation = {
              numFrames: this.readUInt32(),
              numPlays: this.readUInt32() || 1 / 0,
              frames: []
            };
            break;

          case "PLTE":
            this.palette = this.read(e);
            break;

          case "fcTL":
            a && this.animation.frames.push(a), this.pos += 4, a = {
              width: this.readUInt32(),
              height: this.readUInt32(),
              xOffset: this.readUInt32(),
              yOffset: this.readUInt32()
            }, o = this.readUInt16(), i = this.readUInt16() || 100, a.delay = 1e3 * o / i, a.disposeOp = this.data[this.pos++], a.blendOp = this.data[this.pos++], a.data = [];
            break;

          case "IDAT":
          case "fdAT":
            for ("fdAT" === h && (this.pos += 4, e -= 4), t = (null != a ? a.data : void 0) || this.imgData, f = 0; 0 <= e ? f < e : e < f; 0 <= e ? ++f : --f) {
              t.push(this.data[this.pos++]);
            }

            break;

          case "tRNS":
            switch (this.transparency = {}, this.colorType) {
              case 3:
                if (r = this.palette.length / 3, this.transparency.indexed = this.read(e), this.transparency.indexed.length > r) throw new Error("More transparent colors than palette size");
                if (0 < (u = r - this.transparency.indexed.length)) for (p = 0; 0 <= u ? p < u : u < p; 0 <= u ? ++p : --p) {
                  this.transparency.indexed.push(255);
                }
                break;

              case 0:
                this.transparency.grayscale = this.read(e)[0];
                break;

              case 2:
                this.transparency.rgb = this.read(e);
            }

            break;

          case "tEXt":
            s = (c = this.read(e)).indexOf(0), l = String.fromCharCode.apply(String, c.slice(0, s)), this.text[l] = String.fromCharCode.apply(String, c.slice(s + 1));
            break;

          case "IEND":
            return a && this.animation.frames.push(a), this.colors = function () {
              switch (this.colorType) {
                case 0:
                case 3:
                case 4:
                  return 1;

                case 2:
                case 6:
                  return 3;
              }
            }.call(this), this.hasAlphaChannel = 4 === (d = this.colorType) || 6 === d, n = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * n, this.colorSpace = function () {
              switch (this.colors) {
                case 1:
                  return "DeviceGray";

                case 3:
                  return "DeviceRGB";
              }
            }.call(this), void (this.imgData = new Uint8Array(this.imgData));

          default:
            this.pos += e;
        }

        if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
      }
    }

    i.load = function (t, e, n) {
      var r;
      return "function" == typeof e && (n = e), (r = new XMLHttpRequest()).open("GET", t, !0), r.responseType = "arraybuffer", r.onload = function () {
        var t;
        return t = new i(new Uint8Array(r.response || r.mozResponseArrayBuffer)), "function" == typeof (null != e ? e.getContext : void 0) && t.render(e), "function" == typeof n ? n(t) : void 0;
      }, r.send(null);
    }, i.prototype.read = function (t) {
      var e, n;

      for (n = [], e = 0; 0 <= t ? e < t : t < e; 0 <= t ? ++e : --e) {
        n.push(this.data[this.pos++]);
      }

      return n;
    }, i.prototype.readUInt32 = function () {
      return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
    }, i.prototype.readUInt16 = function () {
      return this.data[this.pos++] << 8 | this.data[this.pos++];
    }, i.prototype.decodePixels = function (C) {
      var B = this.pixelBitlength / 8,
          j = new Uint8Array(this.width * this.height * B),
          E = 0,
          M = this;
      if (null == C && (C = this.imgData), 0 === C.length) return new Uint8Array(0);

      function t(t, e, n, r) {
        var i,
            o,
            a,
            s,
            l,
            h,
            u,
            c,
            f,
            p,
            d,
            g,
            m,
            y,
            v,
            w,
            b,
            x,
            N,
            L,
            A,
            S = Math.ceil((M.width - t) / n),
            _ = Math.ceil((M.height - e) / r),
            F = M.width == S && M.height == _;

        for (y = B * S, g = F ? j : new Uint8Array(y * _), h = C.length, o = m = 0; m < _ && E < h;) {
          switch (C[E++]) {
            case 0:
              for (s = b = 0; b < y; s = b += 1) {
                g[o++] = C[E++];
              }

              break;

            case 1:
              for (s = x = 0; x < y; s = x += 1) {
                i = C[E++], l = s < B ? 0 : g[o - B], g[o++] = (i + l) % 256;
              }

              break;

            case 2:
              for (s = N = 0; N < y; s = N += 1) {
                i = C[E++], a = (s - s % B) / B, v = m && g[(m - 1) * y + a * B + s % B], g[o++] = (v + i) % 256;
              }

              break;

            case 3:
              for (s = L = 0; L < y; s = L += 1) {
                i = C[E++], a = (s - s % B) / B, l = s < B ? 0 : g[o - B], v = m && g[(m - 1) * y + a * B + s % B], g[o++] = (i + Math.floor((l + v) / 2)) % 256;
              }

              break;

            case 4:
              for (s = A = 0; A < y; s = A += 1) {
                i = C[E++], a = (s - s % B) / B, l = s < B ? 0 : g[o - B], 0 === m ? v = w = 0 : (v = g[(m - 1) * y + a * B + s % B], w = a && g[(m - 1) * y + (a - 1) * B + s % B]), u = l + v - w, c = Math.abs(u - l), p = Math.abs(u - v), d = Math.abs(u - w), f = c <= p && c <= d ? l : p <= d ? v : w, g[o++] = (i + f) % 256;
              }

              break;

            default:
              throw new Error("Invalid filter algorithm: " + C[E - 1]);
          }

          if (!F) {
            var P = ((e + m * r) * M.width + t) * B,
                k = m * y;

            for (s = 0; s < S; s += 1) {
              for (var I = 0; I < B; I += 1) {
                j[P++] = g[k++];
              }

              P += (n - 1) * B;
            }
          }

          m++;
        }
      }

      return C = (C = new kt(C)).getBytes(), 1 == M.interlaceMethod ? (t(0, 0, 8, 8), t(4, 0, 8, 8), t(0, 4, 4, 8), t(2, 0, 4, 4), t(0, 2, 2, 4), t(1, 0, 2, 2), t(0, 1, 1, 2)) : t(0, 0, 1, 1), j;
    }, i.prototype.decodePalette = function () {
      var t, e, n, r, i, o, a, s, l;

      for (n = this.palette, o = this.transparency.indexed || [], i = new Uint8Array((o.length || 0) + n.length), r = 0, n.length, e = a = t = 0, s = n.length; a < s; e = a += 3) {
        i[r++] = n[e], i[r++] = n[e + 1], i[r++] = n[e + 2], i[r++] = null != (l = o[t++]) ? l : 255;
      }

      return i;
    }, i.prototype.copyToImageData = function (t, e) {
      var n, r, i, o, a, s, l, h, u, c, f;
      if (r = this.colors, u = null, n = this.hasAlphaChannel, this.palette.length && (u = null != (f = this._decodedPalette) ? f : this._decodedPalette = this.decodePalette(), r = 4, n = !0), h = (i = t.data || t).length, a = u || e, o = s = 0, 1 === r) for (; o < h;) {
        l = u ? 4 * e[o / 4] : s, c = a[l++], i[o++] = c, i[o++] = c, i[o++] = c, i[o++] = n ? a[l++] : 255, s = l;
      } else for (; o < h;) {
        l = u ? 4 * e[o / 4] : s, i[o++] = a[l++], i[o++] = a[l++], i[o++] = a[l++], i[o++] = n ? a[l++] : 255, s = l;
      }
    }, i.prototype.decode = function () {
      var t;
      return t = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t, this.decodePixels()), t;
    };

    try {
      n = Nt.document.createElement("canvas"), r = n.getContext("2d");
    } catch (t) {
      return -1;
    }

    return h = function h(t) {
      var e;
      return r.width = t.width, r.height = t.height, r.clearRect(0, 0, t.width, t.height), r.putImageData(t, 0, 0), (e = new Image()).src = n.toDataURL(), e;
    }, i.prototype.decodeFrames = function (t) {
      var e, n, r, i, o, a, s, l;

      if (this.animation) {
        for (l = [], n = o = 0, a = (s = this.animation.frames).length; o < a; n = ++o) {
          e = s[n], r = t.createImageData(e.width, e.height), i = this.decodePixels(new Uint8Array(e.data)), this.copyToImageData(r, i), e.imageData = r, l.push(e.image = h(r));
        }

        return l;
      }
    }, i.prototype.renderFrame = function (t, e) {
      var n, r, i;
      return n = (r = this.animation.frames)[e], i = r[e - 1], 0 === e && t.clearRect(0, 0, this.width, this.height), 1 === (null != i ? i.disposeOp : void 0) ? t.clearRect(i.xOffset, i.yOffset, i.width, i.height) : 2 === (null != i ? i.disposeOp : void 0) && t.putImageData(i.imageData, i.xOffset, i.yOffset), 0 === n.blendOp && t.clearRect(n.xOffset, n.yOffset, n.width, n.height), t.drawImage(n.image, n.xOffset, n.yOffset);
    }, i.prototype.animate = function (n) {
      var _r,
          i,
          o,
          a,
          s,
          t,
          l = this;

      return i = 0, t = this.animation, a = t.numFrames, o = t.frames, s = t.numPlays, (_r = function r() {
        var t, e;
        if (t = i++ % a, e = o[t], l.renderFrame(n, t), 1 < a && i / a < s) return l.animation._timeout = setTimeout(_r, e.delay);
      })();
    }, i.prototype.stopAnimation = function () {
      var t;
      return clearTimeout(null != (t = this.animation) ? t._timeout : void 0);
    }, i.prototype.render = function (t) {
      var e, n;
      return t._png && t._png.stopAnimation(), t._png = this, t.width = this.width, t.height = this.height, e = t.getContext("2d"), this.animation ? (this.decodeFrames(e), this.animate(e)) : (n = e.createImageData(this.width, this.height), this.copyToImageData(n, this.decodePixels()), e.putImageData(n, 0, 0));
    }, i;
  }(), Nt.PNG = Lt;
  /*
     * Extracted from pdf.js
     * https://github.com/andreasgal/pdf.js
     *
     * Copyright (c) 2011 Mozilla Foundation
     *
     * Contributors: Andreas Gal <gal@mozilla.com>
     *               Chris G Jones <cjones@mozilla.com>
     *               Shaon Barman <shaon.barman@gmail.com>
     *               Vivien Nicolas <21@vingtetun.org>
     *               Justin D'Arcangelo <justindarc@gmail.com>
     *               Yury Delendik
     *
     * 
     */

  var Pt = function () {
    function t() {
      this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = null;
    }

    return t.prototype = {
      ensureBuffer: function ensureBuffer(t) {
        var e = this.buffer,
            n = e ? e.byteLength : 0;
        if (t < n) return e;

        for (var r = 512; r < t;) {
          r <<= 1;
        }

        for (var i = new Uint8Array(r), o = 0; o < n; ++o) {
          i[o] = e[o];
        }

        return this.buffer = i;
      },
      getByte: function getByte() {
        for (var t = this.pos; this.bufferLength <= t;) {
          if (this.eof) return null;
          this.readBlock();
        }

        return this.buffer[this.pos++];
      },
      getBytes: function getBytes(t) {
        var e = this.pos;

        if (t) {
          this.ensureBuffer(e + t);

          for (var n = e + t; !this.eof && this.bufferLength < n;) {
            this.readBlock();
          }

          var r = this.bufferLength;
          r < n && (n = r);
        } else {
          for (; !this.eof;) {
            this.readBlock();
          }

          n = this.bufferLength;
        }

        return this.pos = n, this.buffer.subarray(e, n);
      },
      lookChar: function lookChar() {
        for (var t = this.pos; this.bufferLength <= t;) {
          if (this.eof) return null;
          this.readBlock();
        }

        return String.fromCharCode(this.buffer[this.pos]);
      },
      getChar: function getChar() {
        for (var t = this.pos; this.bufferLength <= t;) {
          if (this.eof) return null;
          this.readBlock();
        }

        return String.fromCharCode(this.buffer[this.pos++]);
      },
      makeSubStream: function makeSubStream(t, e, n) {
        for (var r = t + e; this.bufferLength <= r && !this.eof;) {
          this.readBlock();
        }

        return new Stream(this.buffer, t, e, n);
      },
      skip: function skip(t) {
        t || (t = 1), this.pos += t;
      },
      reset: function reset() {
        this.pos = 0;
      }
    }, t;
  }(),
      kt = function () {
    if ("undefined" != typeof Uint32Array) {
      var k = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
          I = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]),
          C = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]),
          B = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9],
          j = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
      return (t.prototype = Object.create(Pt.prototype)).getBits = function (t) {
        for (var e, n = this.codeSize, r = this.codeBuf, i = this.bytes, o = this.bytesPos; n < t;) {
          void 0 === (e = i[o++]) && E("Bad encoding in flate stream"), r |= e << n, n += 8;
        }

        return e = r & (1 << t) - 1, this.codeBuf = r >> t, this.codeSize = n -= t, this.bytesPos = o, e;
      }, t.prototype.getCode = function (t) {
        for (var e = t[0], n = t[1], r = this.codeSize, i = this.codeBuf, o = this.bytes, a = this.bytesPos; r < n;) {
          var s;
          void 0 === (s = o[a++]) && E("Bad encoding in flate stream"), i |= s << r, r += 8;
        }

        var l = e[i & (1 << n) - 1],
            h = l >> 16,
            u = 65535 & l;
        return (0 == r || r < h || 0 == h) && E("Bad encoding in flate stream"), this.codeBuf = i >> h, this.codeSize = r - h, this.bytesPos = a, u;
      }, t.prototype.generateHuffmanTable = function (t) {
        for (var e = t.length, n = 0, r = 0; r < e; ++r) {
          t[r] > n && (n = t[r]);
        }

        for (var i = 1 << n, o = new Uint32Array(i), a = 1, s = 0, l = 2; a <= n; ++a, s <<= 1, l <<= 1) {
          for (var h = 0; h < e; ++h) {
            if (t[h] == a) {
              var u = 0,
                  c = s;

              for (r = 0; r < a; ++r) {
                u = u << 1 | 1 & c, c >>= 1;
              }

              for (r = u; r < i; r += l) {
                o[r] = a << 16 | h;
              }

              ++s;
            }
          }
        }

        return [o, n];
      }, t.prototype.readBlock = function () {
        function t(t, e, n, r, i) {
          for (var o = t.getBits(n) + r; 0 < o--;) {
            e[l++] = i;
          }
        }

        var e = this.getBits(3);

        if (1 & e && (this.eof = !0), 0 != (e >>= 1)) {
          var n, r;
          if (1 == e) n = B, r = j;else if (2 == e) {
            for (var i = this.getBits(5) + 257, o = this.getBits(5) + 1, a = this.getBits(4) + 4, s = Array(k.length), l = 0; l < a;) {
              s[k[l++]] = this.getBits(3);
            }

            for (var h = this.generateHuffmanTable(s), u = 0, c = (l = 0, i + o), f = new Array(c); l < c;) {
              var p = this.getCode(h);
              16 == p ? t(this, f, 2, 3, u) : 17 == p ? t(this, f, 3, 3, u = 0) : 18 == p ? t(this, f, 7, 11, u = 0) : f[l++] = u = p;
            }

            n = this.generateHuffmanTable(f.slice(0, i)), r = this.generateHuffmanTable(f.slice(i, c));
          } else E("Unknown block type in flate stream");

          for (var d = (_ = this.buffer) ? _.length : 0, g = this.bufferLength;;) {
            var m = this.getCode(n);
            if (m < 256) d <= g + 1 && (d = (_ = this.ensureBuffer(g + 1)).length), _[g++] = m;else {
              if (256 == m) return void (this.bufferLength = g);
              var y = (m = I[m -= 257]) >> 16;
              0 < y && (y = this.getBits(y));
              u = (65535 & m) + y;
              m = this.getCode(r), 0 < (y = (m = C[m]) >> 16) && (y = this.getBits(y));
              var v = (65535 & m) + y;
              d <= g + u && (d = (_ = this.ensureBuffer(g + u)).length);

              for (var w = 0; w < u; ++w, ++g) {
                _[g] = _[g - v];
              }
            }
          }
        } else {
          var b,
              x = this.bytes,
              N = this.bytesPos;
          void 0 === (b = x[N++]) && E("Bad block header in flate stream");
          var L = b;
          void 0 === (b = x[N++]) && E("Bad block header in flate stream"), L |= b << 8, void 0 === (b = x[N++]) && E("Bad block header in flate stream");
          var A = b;
          void 0 === (b = x[N++]) && E("Bad block header in flate stream"), (A |= b << 8) != (65535 & ~L) && E("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;

          var S = this.bufferLength,
              _ = this.ensureBuffer(S + L),
              F = S + L;

          this.bufferLength = F;

          for (var P = S; P < F; ++P) {
            if (void 0 === (b = x[N++])) {
              this.eof = !0;
              break;
            }

            _[P] = b;
          }

          this.bytesPos = N;
        }
      }, t;
    }

    function E(t) {
      throw new Error(t);
    }

    function t(t) {
      var e = 0,
          n = t[e++],
          r = t[e++];
      -1 != n && -1 != r || E("Invalid header in flate stream"), 8 != (15 & n) && E("Unknown compression method in flate stream"), ((n << 8) + r) % 31 != 0 && E("Bad FCHECK in flate stream"), 32 & r && E("FDICT bit set in flate stream"), this.bytes = t, this.bytesPos = 2, this.codeSize = 0, this.codeBuf = 0, Pt.call(this);
    }
  }();

  window.tmp = kt;
});

try {
  module.exports = jsPDF;
} catch (t) {}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],37:[function(require,module,exports){
"use strict";

// THIS FILE IS GENERATED - DO NOT EDIT!

/*!mobile-detect v1.4.4 2019-09-21*/

/*global module:false, define:false*/

/*jshint latedef:false*/

/*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
(function (define, undefined) {
  define(function () {
    'use strict';

    var impl = {};
    impl.mobileDetectRules = {
      "phones": {
        "iPhone": "\\biPhone\\b|\\biPod\\b",
        "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+",
        "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
        "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
        "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
        "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
        "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F",
        "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710",
        "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
        "Asus": "Asus.*Galaxy|PadFone.*Mobile",
        "NokiaLumia": "Lumia [0-9]{3,4}",
        "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
        "Palm": "PalmSource|Palm",
        "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
        "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
        "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
        "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
        "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
        "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
        "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
        "Alcatel": "Alcatel",
        "Nintendo": "Nintendo (3DS|Switch)",
        "Amoi": "Amoi",
        "INQ": "INQ",
        "OnePlus": "ONEPLUS",
        "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
      },
      "tablets": {
        "iPad": "iPad|iPad.*Mobile",
        "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
        "GoogleTablet": "Android.*Pixel C",
        "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V",
        "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk\/[0-9.]+ like Chrome\/[0-9.]+ (?!Mobile)",
        "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
        "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
        "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
        "BlackBerryTablet": "PlayBook|RIM Tablet",
        "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
        "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
        "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
        "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30",
        "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
        "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
        "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
        "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
        "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X",
        "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
        "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
        "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
        "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
        "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
        "IRUTablet": "M702pro",
        "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
        "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
        "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
        "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
        "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
        "NokiaLumiaTablet": "Lumia 2520",
        "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
        "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
        "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
        "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
        "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
        "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
        "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
        "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
        "FlyTablet": "IQ310|Fly Vision",
        "bqTablet": "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus",
        "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19",
        "NecTablet": "\\bN-06D|\\bN-08D",
        "PantechTablet": "Pantech.*P4100",
        "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
        "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
        "ZyncTablet": "z1000|Z99 2G|z930|z990|z909|Z919|z900",
        "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
        "NabiTablet": "Android.*\\bNabi",
        "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
        "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
        "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
        "PlaystationTablet": "Playstation.*(Portable|Vita)",
        "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
        "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
        "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
        "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
        "GalapadTablet": "Android.*\\bG1\\b(?!\\))",
        "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
        "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
        "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
        "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
        "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
        "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
        "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
        "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
        "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
        "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
        "DPSTablet": "DPS Dream 9|DPS Dual 7",
        "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
        "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
        "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
        "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
        "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
        "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
        "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
        "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
        "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
        "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400",
        "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
        "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
        "iMobileTablet": "i-mobile i-note",
        "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
        "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
        "AMPETablet": "Android.* A78 ",
        "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
        "TecnoTablet": "TECNO P9|TECNO DP8D",
        "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
        "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
        "FX2Tablet": "FX2 PAD7|FX2 PAD10",
        "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
        "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
        "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
        "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
        "CaptivaTablet": "CAPTIVA PAD",
        "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
        "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
        "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
        "JaytechTablet": "TPC-PA762",
        "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
        "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
        "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
        "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
        "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
        "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
        "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
        "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
        "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
        "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
        "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
        "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
        "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
        "UbislateTablet": "UbiSlate[\\s]?7C",
        "PocketBookTablet": "Pocketbook",
        "KocasoTablet": "\\b(TB-1207)\\b",
        "HisenseTablet": "\\b(F5281|E2371)\\b",
        "Hudl": "Hudl HT7S3|Hudl 2",
        "TelstraTablet": "T-Hub2",
        "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
      },
      "oss": {
        "AndroidOS": "Android",
        "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
        "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
        "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
        "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;",
        "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
        "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
        "iPadOS": "CPU OS 13",
        "MeeGoOS": "MeeGo",
        "MaemoOS": "Maemo",
        "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
        "webOS": "webOS|hpwOS",
        "badaOS": "\\bBada\\b",
        "BREWOS": "BREW"
      },
      "uas": {
        "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
        "Dolfin": "\\bDolfin\\b",
        "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+$|Coast\/[0-9.]+",
        "Skyfire": "Skyfire",
        "Edge": "Mobile Safari\/[.0-9]* Edge",
        "IE": "IEMobile|MSIEMobile",
        "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
        "Bolt": "bolt",
        "TeaShark": "teashark",
        "Blazer": "Blazer",
        "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
        "WeChat": "\\bMicroMessenger\\b",
        "UCBrowser": "UC.*Browser|UCWEB",
        "baiduboxapp": "baiduboxapp",
        "baidubrowser": "baidubrowser",
        "DiigoBrowser": "DiigoBrowser",
        "Mercury": "\\bMercury\\b",
        "ObigoBrowser": "Obigo",
        "NetFront": "NF-Browser",
        "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
        "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
      },
      "props": {
        "Mobile": "Mobile\/[VER]",
        "Build": "Build\/[VER]",
        "Version": "Version\/[VER]",
        "VendorID": "VendorID\/[VER]",
        "iPad": "iPad.*CPU[a-z ]+[VER]",
        "iPhone": "iPhone.*CPU[a-z ]+[VER]",
        "iPod": "iPod.*CPU[a-z ]+[VER]",
        "Kindle": "Kindle\/[VER]",
        "Chrome": ["Chrome\/[VER]", "CriOS\/[VER]", "CrMo\/[VER]"],
        "Coast": ["Coast\/[VER]"],
        "Dolfin": "Dolfin\/[VER]",
        "Firefox": ["Firefox\/[VER]", "FxiOS\/[VER]"],
        "Fennec": "Fennec\/[VER]",
        "Edge": "Edge\/[VER]",
        "IE": ["IEMobile\/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident\/[0-9.]+;.*rv:[VER]"],
        "NetFront": "NetFront\/[VER]",
        "NokiaBrowser": "NokiaBrowser\/[VER]",
        "Opera": [" OPR\/[VER]", "Opera Mini\/[VER]", "Version\/[VER]"],
        "Opera Mini": "Opera Mini\/[VER]",
        "Opera Mobi": "Version\/[VER]",
        "UCBrowser": ["UCWEB[VER]", "UC.*Browser\/[VER]"],
        "MQQBrowser": "MQQBrowser\/[VER]",
        "MicroMessenger": "MicroMessenger\/[VER]",
        "baiduboxapp": "baiduboxapp\/[VER]",
        "baidubrowser": "baidubrowser\/[VER]",
        "SamsungBrowser": "SamsungBrowser\/[VER]",
        "Iron": "Iron\/[VER]",
        "Safari": ["Version\/[VER]", "Safari\/[VER]"],
        "Skyfire": "Skyfire\/[VER]",
        "Tizen": "Tizen\/[VER]",
        "Webkit": "webkit[ \/][VER]",
        "PaleMoon": "PaleMoon\/[VER]",
        "Gecko": "Gecko\/[VER]",
        "Trident": "Trident\/[VER]",
        "Presto": "Presto\/[VER]",
        "Goanna": "Goanna\/[VER]",
        "iOS": " \\bi?OS\\b [VER][ ;]{1}",
        "Android": "Android [VER]",
        "BlackBerry": ["BlackBerry[\\w]+\/[VER]", "BlackBerry.*Version\/[VER]", "Version\/[VER]"],
        "BREW": "BREW [VER]",
        "Java": "Java\/[VER]",
        "Windows Phone OS": ["Windows Phone OS [VER]", "Windows Phone [VER]"],
        "Windows Phone": "Windows Phone [VER]",
        "Windows CE": "Windows CE\/[VER]",
        "Windows NT": "Windows NT [VER]",
        "Symbian": ["SymbianOS\/[VER]", "Symbian\/[VER]"],
        "webOS": ["webOS\/[VER]", "hpwOS\/[VER];"]
      },
      "utils": {
        "Bot": "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp",
        "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
        "DesktopMode": "WPDesktop",
        "TV": "SonyDTV|HbbTV",
        "WebKit": "(webkit)[ \/]([\\w.]+)",
        "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
        "Watch": "SM-V700"
      }
    }; // following patterns come from http://detectmobilebrowsers.com/

    impl.detectMobileBrowsers = {
      fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
      shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
      tabletPattern: /android|ipad|playbook|silk/i
    };
    var hasOwnProp = Object.prototype.hasOwnProperty,
        isArray;
    impl.FALLBACK_PHONE = 'UnknownPhone';
    impl.FALLBACK_TABLET = 'UnknownTablet';
    impl.FALLBACK_MOBILE = 'UnknownMobile';
    isArray = 'isArray' in Array ? Array.isArray : function (value) {
      return Object.prototype.toString.call(value) === '[object Array]';
    };

    function equalIC(a, b) {
      return a != null && b != null && a.toLowerCase() === b.toLowerCase();
    }

    function containsIC(array, value) {
      var valueLC,
          i,
          len = array.length;

      if (!len || !value) {
        return false;
      }

      valueLC = value.toLowerCase();

      for (i = 0; i < len; ++i) {
        if (valueLC === array[i].toLowerCase()) {
          return true;
        }
      }

      return false;
    }

    function convertPropsToRegExp(object) {
      for (var key in object) {
        if (hasOwnProp.call(object, key)) {
          object[key] = new RegExp(object[key], 'i');
        }
      }
    }

    function prepareUserAgent(userAgent) {
      return (userAgent || '').substr(0, 500); // mitigate vulnerable to ReDoS
    }

    (function init() {
      var key,
          values,
          value,
          i,
          len,
          verPos,
          mobileDetectRules = impl.mobileDetectRules;

      for (key in mobileDetectRules.props) {
        if (hasOwnProp.call(mobileDetectRules.props, key)) {
          values = mobileDetectRules.props[key];

          if (!isArray(values)) {
            values = [values];
          }

          len = values.length;

          for (i = 0; i < len; ++i) {
            value = values[i];
            verPos = value.indexOf('[VER]');

            if (verPos >= 0) {
              value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
            }

            values[i] = new RegExp(value, 'i');
          }

          mobileDetectRules.props[key] = values;
        }
      }

      convertPropsToRegExp(mobileDetectRules.oss);
      convertPropsToRegExp(mobileDetectRules.phones);
      convertPropsToRegExp(mobileDetectRules.tablets);
      convertPropsToRegExp(mobileDetectRules.uas);
      convertPropsToRegExp(mobileDetectRules.utils); // copy some patterns to oss0 which are tested first (see issue#15)

      mobileDetectRules.oss0 = {
        WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
        WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
      };
    })();
    /**
     * Test userAgent string against a set of rules and find the first matched key.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
     * @private
     */


    impl.findMatch = function (rules, userAgent) {
      for (var key in rules) {
        if (hasOwnProp.call(rules, key)) {
          if (rules[key].test(userAgent)) {
            return key;
          }
        }
      }

      return null;
    };
    /**
     * Test userAgent string against a set of rules and return an array of matched keys.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
     * @private
     */


    impl.findMatches = function (rules, userAgent) {
      var result = [];

      for (var key in rules) {
        if (hasOwnProp.call(rules, key)) {
          if (rules[key].test(userAgent)) {
            result.push(key);
          }
        }
      }

      return result;
    };
    /**
     * Check the version of the given property in the User-Agent.
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {String} version or <tt>null</tt> if version not found
     * @private
     */


    impl.getVersionStr = function (propertyName, userAgent) {
      var props = impl.mobileDetectRules.props,
          patterns,
          i,
          len,
          match;

      if (hasOwnProp.call(props, propertyName)) {
        patterns = props[propertyName];
        len = patterns.length;

        for (i = 0; i < len; ++i) {
          match = patterns[i].exec(userAgent);

          if (match !== null) {
            return match[1];
          }
        }
      }

      return null;
    };
    /**
     * Check the version of the given property in the User-Agent.
     * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {Number} version or <tt>NaN</tt> if version not found
     * @private
     */


    impl.getVersion = function (propertyName, userAgent) {
      var version = impl.getVersionStr(propertyName, userAgent);
      return version ? impl.prepareVersionNo(version) : NaN;
    };
    /**
     * Prepare the version number.
     *
     * @param {String} version
     * @return {Number} the version number as a floating number
     * @private
     */


    impl.prepareVersionNo = function (version) {
      var numbers;
      numbers = version.split(/[a-z._ \/\-]/i);

      if (numbers.length === 1) {
        version = numbers[0];
      }

      if (numbers.length > 1) {
        version = numbers[0] + '.';
        numbers.shift();
        version += numbers.join('');
      }

      return Number(version);
    };

    impl.isMobileFallback = function (userAgent) {
      return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
    };

    impl.isTabletFallback = function (userAgent) {
      return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
    };

    impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
      if (cache.mobile !== undefined) {
        return;
      }

      var phone, tablet, phoneSized; // first check for stronger tablet rules, then phone (see issue#5)

      tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);

      if (tablet) {
        cache.mobile = cache.tablet = tablet;
        cache.phone = null;
        return; // unambiguously identified as tablet
      }

      phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);

      if (phone) {
        cache.mobile = cache.phone = phone;
        cache.tablet = null;
        return; // unambiguously identified as phone
      } // our rules haven't found a match -> try more general fallback rules


      if (impl.isMobileFallback(userAgent)) {
        phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);

        if (phoneSized === undefined) {
          cache.mobile = impl.FALLBACK_MOBILE;
          cache.tablet = cache.phone = null;
        } else if (phoneSized) {
          cache.mobile = cache.phone = impl.FALLBACK_PHONE;
          cache.tablet = null;
        } else {
          cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
          cache.phone = null;
        }
      } else if (impl.isTabletFallback(userAgent)) {
        cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
        cache.phone = null;
      } else {
        // not mobile at all!
        cache.mobile = cache.tablet = cache.phone = null;
      }
    }; // t is a reference to a MobileDetect instance


    impl.mobileGrade = function (t) {
      // impl note:
      // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
      // When changes are made in Mobile_Detect.php, copy this method and replace:
      //     $this-> / t.
      //     self::MOBILE_GRADE_(.) / '$1'
      //     , self::VERSION_TYPE_FLOAT / (nothing)
      //     isIOS() / os('iOS')
      //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
      var $isMobile = t.mobile() !== null;

      if ( // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
      t.os('iOS') && t.version('iPad') >= 4.3 || t.os('iOS') && t.version('iPhone') >= 3.1 || t.os('iOS') && t.version('iPod') >= 3.1 || // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
      // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
      // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
      // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
      t.version('Android') > 2.1 && t.is('Webkit') || // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
      t.version('Windows Phone OS') >= 7.0 || // Blackberry 7 - Tested on BlackBerry Torch 9810
      // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
      t.is('BlackBerry') && t.version('BlackBerry') >= 6.0 || // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
      t.match('Playbook.*Tablet') || // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
      t.version('webOS') >= 1.4 && t.match('Palm|Pre|Pixi') || // Palm WebOS 3.0  - Tested on HP TouchPad
      t.match('hp.*TouchPad') || // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
      t.is('Firefox') && t.version('Firefox') >= 12 || // Chrome for Android - Tested on Android 4.0, 4.1 device
      t.is('Chrome') && t.is('AndroidOS') && t.version('Android') >= 4.0 || // Skyfire 4.1 - Tested on Android 2.3 device
      t.is('Skyfire') && t.version('Skyfire') >= 4.1 && t.is('AndroidOS') && t.version('Android') >= 2.3 || // Opera Mobile 11.5-12: Tested on Android 2.3
      t.is('Opera') && t.version('Opera Mobi') > 11 && t.is('AndroidOS') || // Meego 1.2 - Tested on Nokia 950 and N9
      t.is('MeeGoOS') || // Tizen (pre-release) - Tested on early hardware
      t.is('Tizen') || // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
      // @todo: more tests here!
      t.is('Dolfin') && t.version('Bada') >= 2.0 || // UC Browser - Tested on Android 2.3 device
      (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android') >= 2.3 || // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
      t.match('Kindle Fire') || t.is('Kindle') && t.version('Kindle') >= 3.0 || // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
      t.is('AndroidOS') && t.is('NookTablet') || // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
      t.version('Chrome') >= 11 && !$isMobile || // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
      t.version('Safari') >= 5.0 && !$isMobile || // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
      t.version('Firefox') >= 4.0 && !$isMobile || // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
      t.version('MSIE') >= 7.0 && !$isMobile || // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
      // @reference: http://my.opera.com/community/openweb/idopera/
      t.version('Opera') >= 10 && !$isMobile) {
        return 'A';
      }

      if (t.os('iOS') && t.version('iPad') < 4.3 || t.os('iOS') && t.version('iPhone') < 3.1 || t.os('iOS') && t.version('iPod') < 3.1 || // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
      t.is('Blackberry') && t.version('BlackBerry') >= 5 && t.version('BlackBerry') < 6 || //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
      t.version('Opera Mini') >= 5.0 && t.version('Opera Mini') <= 6.5 && (t.version('Android') >= 2.3 || t.is('iOS')) || // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
      t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') || // @todo: report this (tested on Nokia N71)
      t.version('Opera Mobi') >= 11 && t.is('SymbianOS')) {
        return 'B';
      }

      if ( // Blackberry 4.x - Tested on the Curve 8330
      t.version('BlackBerry') < 5.0 || // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
      t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile') <= 5.2) {
        return 'C';
      } //All older smartphone platforms and featurephones - Any device that doesn't support media queries
      //will receive the basic, C grade experience.


      return 'C';
    };

    impl.detectOS = function (ua) {
      return impl.findMatch(impl.mobileDetectRules.oss0, ua) || impl.findMatch(impl.mobileDetectRules.oss, ua);
    };

    impl.getDeviceSmallerSide = function () {
      return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
    };
    /**
     * Constructor for MobileDetect object.
     * <br>
     * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
     * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
     *     <strong>Find information how to download and install:</strong>
     *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
     * </div>
     *
     * @example <pre>
     *     var md = new MobileDetect(window.navigator.userAgent);
     *     if (md.mobile()) {
     *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
     *     }
     * </pre>
     *
     * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
     * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
     *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
     *        as phone.
     *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
     *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
     *        for Android</a>.<br>
     *        If you provide a value < 0, then this "fuzzy" check is disabled.
     * @constructor
     * @global
     */


    function MobileDetect(userAgent, maxPhoneWidth) {
      this.ua = prepareUserAgent(userAgent);
      this._cache = {}; //600dp is typical 7" tablet minimum width

      this.maxPhoneWidth = maxPhoneWidth || 600;
    }

    MobileDetect.prototype = {
      constructor: MobileDetect,

      /**
       * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
       * <br>
       * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
       * <br>
       * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
       * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
       * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
       * <code>UnknownMobile</code> is returned.<br>
       * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
       * <br>
       * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
       * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
       * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
       * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
       * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
       * <br>
       * In most cases you will use the return value just as a boolean.
       *
       * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
       * @function MobileDetect#mobile
       */
      mobile: function mobile() {
        impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
        return this._cache.mobile;
      },

      /**
       * Returns the detected phone type/family string or <tt>null</tt>.
       * <br>
       * The returned tablet (family or producer) is one of following keys:<br>
       * <br><tt>iPhone, BlackBerry, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
       * NokiaLumia, Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile, SimValley,
       * Wolfgang, Alcatel, Nintendo, Amoi, INQ, OnePlus, GenericPhone</tt><br>
       * <br>
       * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
       * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
       * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
       * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
       * <br>
       * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
       * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
       * will return <code>UnknownMobile</code>.<br>
       * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
       * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
       * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
       * <br>
       * In most cases you will use the return value just as a boolean.
       *
       * @returns {String} the key of the phone family or producer, e.g. "iPhone"
       * @function MobileDetect#phone
       */
      phone: function phone() {
        impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
        return this._cache.phone;
      },

      /**
       * Returns the detected tablet type/family string or <tt>null</tt>.
       * <br>
       * The returned tablet (family or producer) is one of following keys:<br>
       * <br><tt>iPad, NexusTablet, GoogleTablet, SamsungTablet, Kindle, SurfaceTablet,
       * HPTablet, AsusTablet, BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet,
       * AcerTablet, ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet,
       * LenovoTablet, DellTablet, YarvikTablet, MedionTablet, ArnovaTablet,
       * IntensoTablet, IRUTablet, MegafonTablet, EbodaTablet, AllViewTablet,
       * ArchosTablet, AinolTablet, NokiaLumiaTablet, SonyTablet, PhilipsTablet,
       * CubeTablet, CobyTablet, MIDTablet, MSITablet, SMiTTablet, RockChipTablet,
       * FlyTablet, bqTablet, HuaweiTablet, NecTablet, PantechTablet, BronchoTablet,
       * VersusTablet, ZyncTablet, PositivoTablet, NabiTablet, KoboTablet, DanewTablet,
       * TexetTablet, PlaystationTablet, TrekstorTablet, PyleAudioTablet, AdvanTablet,
       * DanyTechTablet, GalapadTablet, MicromaxTablet, KarbonnTablet, AllFineTablet,
       * PROSCANTablet, YONESTablet, ChangJiaTablet, GUTablet, PointOfViewTablet,
       * OvermaxTablet, HCLTablet, DPSTablet, VistureTablet, CrestaTablet,
       * MediatekTablet, ConcordeTablet, GoCleverTablet, ModecomTablet, VoninoTablet,
       * ECSTablet, StorexTablet, VodafoneTablet, EssentielBTablet, RossMoorTablet,
       * iMobileTablet, TolinoTablet, AudioSonicTablet, AMPETablet, SkkTablet,
       * TecnoTablet, JXDTablet, iJoyTablet, FX2Tablet, XoroTablet, ViewsonicTablet,
       * VerizonTablet, OdysTablet, CaptivaTablet, IconbitTablet, TeclastTablet,
       * OndaTablet, JaytechTablet, BlaupunktTablet, DigmaTablet, EvolioTablet,
       * LavaTablet, AocTablet, MpmanTablet, CelkonTablet, WolderTablet, MediacomTablet,
       * MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
       * PocketBookTablet, KocasoTablet, HisenseTablet, Hudl, TelstraTablet,
       * GenericTablet</tt><br>
       * <br>
       * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
       * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
       * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
       * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
       * <br>
       * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
       * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
       * will return <code>UnknownMobile</code>.<br>
       * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
       * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
       * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
       * <br>
       * In most cases you will use the return value just as a boolean.
       *
       * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
       * @function MobileDetect#tablet
       */
      tablet: function tablet() {
        impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
        return this._cache.tablet;
      },

      /**
       * Returns the (first) detected user-agent string or <tt>null</tt>.
       * <br>
       * The returned user-agent is one of following keys:<br>
       * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
       * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
       * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
       * <br>
       * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
       * cases where a mobile device pretends to be more than one particular browser. You can get the
       * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
       * providing one of the defined keys as first argument to {@link MobileDetect#is}.
       *
       * @returns {String} the key for the detected user-agent or <tt>null</tt>
       * @function MobileDetect#userAgent
       */
      userAgent: function userAgent() {
        if (this._cache.userAgent === undefined) {
          this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
        }

        return this._cache.userAgent;
      },

      /**
       * Returns all detected user-agent strings.
       * <br>
       * The array is empty or contains one or more of following keys:<br>
       * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
       * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
       * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
       * <br>
       * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
       * cases where a mobile device pretends to be more than one particular browser. You can get the
       * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
       * providing one of the defined keys as first argument to {@link MobileDetect#is}.
       *
       * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
       * @function MobileDetect#userAgents
       */
      userAgents: function userAgents() {
        if (this._cache.userAgents === undefined) {
          this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
        }

        return this._cache.userAgents;
      },

      /**
       * Returns the detected operating system string or <tt>null</tt>.
       * <br>
       * The operating system is one of following keys:<br>
       * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
       * iOS, iPadOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
       *
       * @returns {String} the key for the detected operating system.
       * @function MobileDetect#os
       */
      os: function os() {
        if (this._cache.os === undefined) {
          this._cache.os = impl.detectOS(this.ua);
        }

        return this._cache.os;
      },

      /**
       * Get the version (as Number) of the given property in the User-Agent.
       * <br>
       * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
       *
       * @param {String} key a key defining a thing which has a version.<br>
       *        You can use one of following keys:<br>
       * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
       * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
       * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
       * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
       * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
       * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
       *
       * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
       *          Be careful when comparing this value with '==' operator!
       * @function MobileDetect#version
       */
      version: function version(key) {
        return impl.getVersion(key, this.ua);
      },

      /**
       * Get the version (as String) of the given property in the User-Agent.
       * <br>
       *
       * @param {String} key a key defining a thing which has a version.<br>
       *        You can use one of following keys:<br>
       * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
       * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
       * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
       * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
       * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
       * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
       *
       * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
       *
       * @function MobileDetect#versionStr
       */
      versionStr: function versionStr(key) {
        return impl.getVersionStr(key, this.ua);
      },

      /**
       * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
       *
       * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
       *        tablet family.<br>
       *        For a complete list of possible values, see {@link MobileDetect#userAgent},
       *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
       *        Additionally you have following keys:<br>
       * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
       *
       * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
       *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
       * @function MobileDetect#is
       */
      is: function is(key) {
        return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
      },

      /**
       * Do a quick test against navigator::userAgent.
       *
       * @param {String|RegExp} pattern the pattern, either as String or RegExp
       *                        (a string will be converted to a case-insensitive RegExp).
       * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
       * @function MobileDetect#match
       */
      match: function match(pattern) {
        if (!(pattern instanceof RegExp)) {
          pattern = new RegExp(pattern, 'i');
        }

        return pattern.test(this.ua);
      },

      /**
       * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
       * <br>
       * Obviously this method makes sense in browser environments only (not for Node.js)!
       * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
       *        The argument is optional and if not present or falsy, the value of the constructor is taken.
       * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
       *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
       *          Will always return <code>undefined</code> server-side.
       */
      isPhoneSized: function isPhoneSized(maxPhoneWidth) {
        return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
      },

      /**
       * Returns the mobile grade ('A', 'B', 'C').
       *
       * @returns {String} one of the mobile grades ('A', 'B', 'C').
       * @function MobileDetect#mobileGrade
       */
      mobileGrade: function mobileGrade() {
        if (this._cache.grade === undefined) {
          this._cache.grade = impl.mobileGrade(this);
        }

        return this._cache.grade;
      }
    }; // environment-dependent

    if (typeof window !== 'undefined' && window.screen) {
      MobileDetect.isPhoneSized = function (maxPhoneWidth) {
        return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
      };
    } else {
      MobileDetect.isPhoneSized = function () {};
    } // should not be replaced by a completely new object - just overwrite existing methods


    MobileDetect._impl = impl;
    MobileDetect.version = '1.4.4 2019-09-21';
    return MobileDetect;
  }); // end of call of define()
})(function (undefined) {
  if (typeof module !== 'undefined' && module.exports) {
    return function (factory) {
      module.exports = factory();
    };
  } else if (typeof define === 'function' && define.amd) {
    return define;
  } else if (typeof window !== 'undefined') {
    return function (factory) {
      window.MobileDetect = factory();
    };
  } else {
    // please file a bug if you get this error!
    throw new Error('unknown environment');
  }
}());

},{}],38:[function(require,module,exports){
(function (Buffer){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

;

(function (sax) {
  // wrapper for non-node envs
  sax.parser = function (strict, opt) {
    return new SAXParser(strict, opt);
  };

  sax.SAXParser = SAXParser;
  sax.SAXStream = SAXStream;
  sax.createStream = createStream; // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.

  sax.MAX_BUFFER_LENGTH = 64 * 1024;
  var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];
  sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];

  function SAXParser(strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt);
    }

    var parser = this;
    clearBuffers(parser);
    parser.q = parser.c = '';
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
    parser.opt = opt || {};
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
    parser.tags = [];
    parser.closed = parser.closedRoot = parser.sawRoot = false;
    parser.tag = parser.error = null;
    parser.strict = !!strict;
    parser.noscript = !!(strict || parser.opt.noscript);
    parser.state = S.BEGIN;
    parser.strictEntities = parser.opt.strictEntities;
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
    parser.attribList = []; // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.

    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS);
    } // mostly just for error reporting


    parser.trackPosition = parser.opt.position !== false;

    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0;
    }

    emit(parser, 'onready');
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F() {}

      F.prototype = o;
      var newf = new F();
      return newf;
    };
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = [];

      for (var i in o) {
        if (o.hasOwnProperty(i)) a.push(i);
      }

      return a;
    };
  }

  function checkBufferLength(parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
    var maxActual = 0;

    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length;

      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser);
            break;

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
            break;

          case 'script':
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
            break;

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
        }
      }

      maxActual = Math.max(maxActual, len);
    } // schedule the next check for the earliest possible buffer overrun.


    var m = sax.MAX_BUFFER_LENGTH - maxActual;
    parser.bufferCheckPosition = m + parser.position;
  }

  function clearBuffers(parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = '';
    }
  }

  function flushBuffers(parser) {
    closeText(parser);

    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata);
      parser.cdata = '';
    }

    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }
  }

  SAXParser.prototype = {
    end: function end() {
      _end(this);
    },
    write: write,
    resume: function resume() {
      this.error = null;
      return this;
    },
    close: function close() {
      return this.write(null);
    },
    flush: function flush() {
      flushBuffers(this);
    }
  };
  var Stream;

  try {
    Stream = require('stream').Stream;
  } catch (ex) {
    Stream = function Stream() {};
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end';
  });

  function createStream(strict, opt) {
    return new SAXStream(strict, opt);
  }

  function SAXStream(strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt);
    }

    Stream.apply(this);
    this._parser = new SAXParser(strict, opt);
    this.writable = true;
    this.readable = true;
    var me = this;

    this._parser.onend = function () {
      me.emit('end');
    };

    this._parser.onerror = function (er) {
      me.emit('error', er); // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.

      me._parser.error = null;
    };

    this._decoder = null;
    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function get() {
          return me._parser['on' + ev];
        },
        set: function set(h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser['on' + ev] = h;
            return h;
          }

          me.on(ev, h);
        },
        enumerable: true,
        configurable: false
      });
    });
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  });

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder;

        this._decoder = new SD('utf8');
      }

      data = this._decoder.write(data);
    }

    this._parser.write(data.toString());

    this.emit('data', data);
    return true;
  };

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk);
    }

    this._parser.end();

    return true;
  };

  SAXStream.prototype.on = function (ev, handler) {
    var me = this;

    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        args.splice(0, 0, ev);
        me.emit.apply(me, args);
      };
    }

    return Stream.prototype.on.call(me, ev, handler);
  }; // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.


  var CDATA = '[CDATA[';
  var DOCTYPE = 'DOCTYPE';
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
  var rootNS = {
    xml: XML_NAMESPACE,
    xmlns: XMLNS_NAMESPACE
  }; // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.

  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  function isWhitespace(c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t';
  }

  function isQuote(c) {
    return c === '"' || c === '\'';
  }

  function isAttribEnd(c) {
    return c === '>' || isWhitespace(c);
  }

  function isMatch(regex, c) {
    return regex.test(c);
  }

  function notMatch(regex, c) {
    return !isMatch(regex, c);
  }

  var S = 0;
  sax.STATE = {
    BEGIN: S++,
    // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++,
    // leading whitespace
    TEXT: S++,
    // general stuff
    TEXT_ENTITY: S++,
    // &amp and such.
    OPEN_WAKA: S++,
    // <
    SGML_DECL: S++,
    // <!BLARG
    SGML_DECL_QUOTED: S++,
    // <!BLARG foo "bar
    DOCTYPE: S++,
    // <!DOCTYPE
    DOCTYPE_QUOTED: S++,
    // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++,
    // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++,
    // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++,
    // <!-
    COMMENT: S++,
    // <!--
    COMMENT_ENDING: S++,
    // <!-- blah -
    COMMENT_ENDED: S++,
    // <!-- blah --
    CDATA: S++,
    // <![CDATA[ something
    CDATA_ENDING: S++,
    // ]
    CDATA_ENDING_2: S++,
    // ]]
    PROC_INST: S++,
    // <?hi
    PROC_INST_BODY: S++,
    // <?hi there
    PROC_INST_ENDING: S++,
    // <?hi "there" ?
    OPEN_TAG: S++,
    // <strong
    OPEN_TAG_SLASH: S++,
    // <strong /
    ATTRIB: S++,
    // <a
    ATTRIB_NAME: S++,
    // <a foo
    ATTRIB_NAME_SAW_WHITE: S++,
    // <a foo _
    ATTRIB_VALUE: S++,
    // <a foo=
    ATTRIB_VALUE_QUOTED: S++,
    // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++,
    // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++,
    // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++,
    // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++,
    // <foo bar=&quot
    CLOSE_TAG: S++,
    // </a
    CLOSE_TAG_SAW_WHITE: S++,
    // </a   >
    SCRIPT: S++,
    // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <

  };
  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  };
  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  };
  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key];
    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
    sax.ENTITIES[key] = s;
  });

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s;
  } // shorthand


  S = sax.STATE;

  function emit(parser, event, data) {
    parser[event] && parser[event](data);
  }

  function emitNode(parser, nodeType, data) {
    if (parser.textNode) closeText(parser);
    emit(parser, nodeType, data);
  }

  function closeText(parser) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
    parser.textNode = '';
  }

  function textopts(opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, ' ');
    return text;
  }

  function error(parser, er) {
    closeText(parser);

    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
    }

    er = new Error(er);
    parser.error = er;
    emit(parser, 'onerror', er);
    return parser;
  }

  function _end(parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');

    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
      error(parser, 'Unexpected end');
    }

    closeText(parser);
    parser.c = '';
    parser.closed = true;
    emit(parser, 'onend');
    SAXParser.call(parser, parser.strict, parser.opt);
    return parser;
  }

  function strictFail(parser, message) {
    if (_typeof(parser) !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail');
    }

    if (parser.strict) {
      error(parser, message);
    }
  }

  function newTag(parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
    var parent = parser.tags[parser.tags.length - 1] || parser;
    var tag = parser.tag = {
      name: parser.tagName,
      attributes: {}
    }; // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"

    if (parser.opt.xmlns) {
      tag.ns = parent.ns;
    }

    parser.attribList.length = 0;
    emitNode(parser, 'onopentagstart', tag);
  }

  function qname(name, attribute) {
    var i = name.indexOf(':');
    var qualName = i < 0 ? ['', name] : name.split(':');
    var prefix = qualName[0];
    var local = qualName[1]; // <x "xmlns"="http://foo">

    if (attribute && name === 'xmlns') {
      prefix = 'xmlns';
      local = '';
    }

    return {
      prefix: prefix,
      local: local
    };
  }

  function attrib(parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]();
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = '';
      return;
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true);
      var prefix = qn.prefix;
      var local = qn.local;

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else {
          var tag = parser.tag;
          var parent = parser.tags[parser.tags.length - 1] || parser;

          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns);
          }

          tag.ns[local] = parser.attribValue;
        }
      } // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order


      parser.attribList.push([parser.attribName, parser.attribValue]);
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue;
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      });
    }

    parser.attribName = parser.attribValue = '';
  }

  function openTag(parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag; // add namespace info to tag

      var qn = qname(parser.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || '';

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
        tag.uri = qn.prefix;
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;

      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          });
        });
      } // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting


      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i];
        var name = nv[0];
        var value = nv[1];
        var qualName = qname(name, true);
        var prefix = qualName.prefix;
        var local = qualName.local;
        var uri = prefix === '' ? '' : tag.ns[prefix] || '';
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }; // if there's any attributes with an undefined namespace,
        // then fail on them now.

        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
          a.uri = prefix;
        }

        parser.tag.attributes[name] = a;
        emitNode(parser, 'onattribute', a);
      }

      parser.attribList.length = 0;
    }

    parser.tag.isSelfClosing = !!selfClosing; // process the tag

    parser.sawRoot = true;
    parser.tags.push(parser.tag);
    emitNode(parser, 'onopentag', parser.tag);

    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT;
      } else {
        parser.state = S.TEXT;
      }

      parser.tag = null;
      parser.tagName = '';
    }

    parser.attribName = parser.attribValue = '';
    parser.attribList.length = 0;
  }

  function closeTag(parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.');
      parser.textNode += '</>';
      parser.state = S.TEXT;
      return;
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>';
        parser.tagName = '';
        parser.state = S.SCRIPT;
        return;
      }

      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    } // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.


    var t = parser.tags.length;
    var tagName = parser.tagName;

    if (!parser.strict) {
      tagName = tagName[parser.looseCase]();
    }

    var closeTo = tagName;

    while (t--) {
      var close = parser.tags[t];

      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag');
      } else {
        break;
      }
    } // didn't find it.  we already failed for strict, so just abort.


    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
      parser.textNode += '</' + parser.tagName + '>';
      parser.state = S.TEXT;
      return;
    }

    parser.tagName = tagName;
    var s = parser.tags.length;

    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop();
      parser.tagName = parser.tag.name;
      emitNode(parser, 'onclosetag', parser.tagName);
      var x = {};

      for (var i in tag.ns) {
        x[i] = tag.ns[i];
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;

      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p];
          emitNode(parser, 'onclosenamespace', {
            prefix: p,
            uri: n
          });
        });
      }
    }

    if (t === 0) parser.closedRoot = true;
    parser.tagName = parser.attribValue = parser.attribName = '';
    parser.attribList.length = 0;
    parser.state = S.TEXT;
  }

  function parseEntity(parser) {
    var entity = parser.entity;
    var entityLC = entity.toLowerCase();
    var num;
    var numStr = '';

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity];
    }

    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC];
    }

    entity = entityLC;

    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2);
        num = parseInt(entity, 16);
        numStr = num.toString(16);
      } else {
        entity = entity.slice(1);
        num = parseInt(entity, 10);
        numStr = num.toString(10);
      }
    }

    entity = entity.replace(/^0+/, '');

    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity');
      return '&' + parser.entity + ';';
    }

    return String.fromCodePoint(num);
  }

  function beginWhiteSpace(parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA;
      parser.startTagPosition = parser.position;
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.');
      parser.textNode = c;
      parser.state = S.TEXT;
    }
  }

  function charAt(chunk, i) {
    var result = '';

    if (i < chunk.length) {
      result = chunk.charAt(i);
    }

    return result;
  }

  function write(chunk) {
    var parser = this;

    if (this.error) {
      throw this.error;
    }

    if (parser.closed) {
      return error(parser, 'Cannot write after close. Assign an onready handler.');
    }

    if (chunk === null) {
      return _end(parser);
    }

    if (_typeof(chunk) === 'object') {
      chunk = chunk.toString();
    }

    var i = 0;
    var c = '';

    while (true) {
      c = charAt(chunk, i++);
      parser.c = c;

      if (!c) {
        break;
      }

      if (parser.trackPosition) {
        parser.position++;

        if (c === '\n') {
          parser.line++;
          parser.column = 0;
        } else {
          parser.column++;
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE;

          if (c === "\uFEFF") {
            continue;
          }

          beginWhiteSpace(parser, c);
          continue;

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c);
          continue;

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1;

            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++);

              if (c && parser.trackPosition) {
                parser.position++;

                if (c === '\n') {
                  parser.line++;
                  parser.column = 0;
                } else {
                  parser.column++;
                }
              }
            }

            parser.textNode += chunk.substring(starti, i - 1);
          }

          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.');
            }

            if (c === '&') {
              parser.state = S.TEXT_ENTITY;
            } else {
              parser.textNode += c;
            }
          }

          continue;

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING;
          } else {
            parser.script += c;
          }

          continue;

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG;
          } else {
            parser.script += '<' + c;
            parser.state = S.SCRIPT;
          }

          continue;

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL;
            parser.sgmlDecl = '';
          } else if (isWhitespace(c)) {// wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG;
            parser.tagName = c;
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG;
            parser.tagName = '';
          } else if (c === '?') {
            parser.state = S.PROC_INST;
            parser.procInstName = parser.procInstBody = '';
          } else {
            strictFail(parser, 'Unencoded <'); // if there was some whitespace, then add that in.

            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition;
              c = new Array(pad).join(' ') + c;
            }

            parser.textNode += '<' + c;
            parser.state = S.TEXT;
          }

          continue;

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata');
            parser.state = S.CDATA;
            parser.sgmlDecl = '';
            parser.cdata = '';
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT;
            parser.comment = '';
            parser.sgmlDecl = '';
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE;

            if (parser.doctype || parser.sawRoot) {
              strictFail(parser, 'Inappropriately located doctype declaration');
            }

            parser.doctype = '';
            parser.sgmlDecl = '';
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
            parser.sgmlDecl = '';
            parser.state = S.TEXT;
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED;
            parser.sgmlDecl += c;
          } else {
            parser.sgmlDecl += c;
          }

          continue;

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL;
            parser.q = '';
          }

          parser.sgmlDecl += c;
          continue;

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT;
            emitNode(parser, 'ondoctype', parser.doctype);
            parser.doctype = true; // just remember that we saw it.
          } else {
            parser.doctype += c;

            if (c === '[') {
              parser.state = S.DOCTYPE_DTD;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED;
              parser.q = c;
            }
          }

          continue;

        case S.DOCTYPE_QUOTED:
          parser.doctype += c;

          if (c === parser.q) {
            parser.q = '';
            parser.state = S.DOCTYPE;
          }

          continue;

        case S.DOCTYPE_DTD:
          parser.doctype += c;

          if (c === ']') {
            parser.state = S.DOCTYPE;
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED;
            parser.q = c;
          }

          continue;

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c;

          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD;
            parser.q = '';
          }

          continue;

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING;
          } else {
            parser.comment += c;
          }

          continue;

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED;
            parser.comment = textopts(parser.opt, parser.comment);

            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment);
            }

            parser.comment = '';
          } else {
            parser.comment += '-' + c;
            parser.state = S.COMMENT;
          }

          continue;

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment'); // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "

            parser.comment += '--' + c;
            parser.state = S.COMMENT;
          } else {
            parser.state = S.TEXT;
          }

          continue;

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING;
          } else {
            parser.cdata += c;
          }

          continue;

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2;
          } else {
            parser.cdata += ']' + c;
            parser.state = S.CDATA;
          }

          continue;

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata);
            }

            emitNode(parser, 'onclosecdata');
            parser.cdata = '';
            parser.state = S.TEXT;
          } else if (c === ']') {
            parser.cdata += ']';
          } else {
            parser.cdata += ']]' + c;
            parser.state = S.CDATA;
          }

          continue;

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY;
          } else {
            parser.procInstName += c;
          }

          continue;

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue;
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else {
            parser.procInstBody += c;
          }

          continue;

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            });
            parser.procInstName = parser.procInstBody = '';
            parser.state = S.TEXT;
          } else {
            parser.procInstBody += '?' + c;
            parser.state = S.PROC_INST_BODY;
          }

          continue;

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else {
            newTag(parser);

            if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name');
              }

              parser.state = S.ATTRIB;
            }
          }

          continue;

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true);
            closeTag(parser);
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >');
            parser.state = S.ATTRIB;
          }

          continue;

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }

          continue;

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value');
            parser.attribValue = parser.attribName;
            attrib(parser);
            openTag(parser);
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE;
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }

          continue;

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (isWhitespace(c)) {
            continue;
          } else {
            strictFail(parser, 'Attribute without value');
            parser.tag.attributes[parser.attribName] = '';
            parser.attribValue = '';
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            });
            parser.attribName = '';

            if (c === '>') {
              openTag(parser);
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
              parser.state = S.ATTRIB;
            }
          }

          continue;

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue;
          } else if (isQuote(c)) {
            parser.q = c;
            parser.state = S.ATTRIB_VALUE_QUOTED;
          } else {
            strictFail(parser, 'Unquoted attribute value');
            parser.state = S.ATTRIB_VALUE_UNQUOTED;
            parser.attribValue = c;
          }

          continue;

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
            } else {
              parser.attribValue += c;
            }

            continue;
          }

          attrib(parser);
          parser.q = '';
          parser.state = S.ATTRIB_VALUE_CLOSED;
          continue;

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes');
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }

          continue;

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U;
            } else {
              parser.attribValue += c;
            }

            continue;
          }

          attrib(parser);

          if (c === '>') {
            openTag(parser);
          } else {
            parser.state = S.ATTRIB;
          }

          continue;

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue;
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c;
                parser.state = S.SCRIPT;
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.');
              }
            } else {
              parser.tagName = c;
            }
          } else if (c === '>') {
            closeTag(parser);
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else if (parser.script) {
            parser.script += '</' + parser.tagName;
            parser.tagName = '';
            parser.state = S.SCRIPT;
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag');
            }

            parser.state = S.CLOSE_TAG_SAW_WHITE;
          }

          continue;

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue;
          }

          if (c === '>') {
            closeTag(parser);
          } else {
            strictFail(parser, 'Invalid characters in closing tag');
          }

          continue;

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState;
          var buffer;

          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT;
              buffer = 'textNode';
              break;

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED;
              buffer = 'attribValue';
              break;

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED;
              buffer = 'attribValue';
              break;
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser);
            parser.entity = '';
            parser.state = returnState;
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c;
          } else {
            strictFail(parser, 'Invalid character in entity name');
            parser[buffer] += '&' + parser.entity + c;
            parser.entity = '';
            parser.state = returnState;
          }

          continue;

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state);
      }
    } // while


    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser);
    }

    return parser;
  }
  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */

  /* istanbul ignore next */


  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;

      var fromCodePoint = function fromCodePoint() {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;

        if (!length) {
          return '';
        }

        var result = '';

        while (++index < length) {
          var codePoint = Number(arguments[index]);

          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
          codePoint < 0 || // not a valid Unicode code point
          codePoint > 0x10FFFF || // not a valid Unicode code point
          floor(codePoint) !== codePoint // not an integer
          ) {
              throw RangeError('Invalid code point: ' + codePoint);
            }

          if (codePoint <= 0xFFFF) {
            // BMP code point
            codeUnits.push(codePoint);
          } else {
            // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = codePoint % 0x400 + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }

          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }

        return result;
      };
      /* istanbul ignore next */


      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
      } else {
        String.fromCodePoint = fromCodePoint;
      }
    })();
  }
})(typeof exports === 'undefined' ? (void 0).sax = {} : exports);

}).call(this,require("buffer").Buffer)
},{"buffer":82,"stream":104,"string_decoder":105}],39:[function(require,module,exports){
"use strict";

module.exports = {
  isArray: function isArray(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    } // fallback for older browsers like  IE 8


    return Object.prototype.toString.call(value) === '[object Array]';
  }
};

},{}],40:[function(require,module,exports){
"use strict";

/*jslint node:true */
var xml2js = require('./xml2js');

var xml2json = require('./xml2json');

var js2xml = require('./js2xml');

var json2xml = require('./json2xml');

module.exports = {
  xml2js: xml2js,
  xml2json: xml2json,
  js2xml: js2xml,
  json2xml: json2xml
};

},{"./js2xml":41,"./json2xml":42,"./xml2js":44,"./xml2json":45}],41:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var helper = require('./options-helper');

var isArray = require('./array-helper').isArray;

var currentElement, currentElementName;

function validateOptions(userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('indentText', options);
  helper.ensureFlagExists('indentCdata', options);
  helper.ensureFlagExists('indentAttributes', options);
  helper.ensureFlagExists('indentInstruction', options);
  helper.ensureFlagExists('fullTagEmptyElement', options);
  helper.ensureFlagExists('noQuotesForNativeAttributes', options);
  helper.ensureSpacesExists(options);

  if (typeof options.spaces === 'number') {
    options.spaces = Array(options.spaces + 1).join(' ');
  }

  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  helper.checkFnExists('fullTagEmptyElement', options);
  return options;
}

function writeIndentation(options, depth, firstLine) {
  return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}

function writeAttributes(attributes, options, depth) {
  if (options.ignoreAttributes) {
    return '';
  }

  if ('attributesFn' in options) {
    attributes = options.attributesFn(attributes, currentElementName, currentElement);
  }

  var key,
      attr,
      attrName,
      quote,
      result = [];

  for (key in attributes) {
    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
      attr = '' + attributes[key]; // ensure number and boolean are converted to String

      attr = attr.replace(/"/g, '&quot;');
      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
      result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : ' ');
      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
  }

  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
    result.push(writeIndentation(options, depth, false));
  }

  return result.join('');
}

function writeDeclaration(declaration, options, depth) {
  currentElement = declaration;
  currentElementName = 'xml';
  return options.ignoreDeclaration ? '' : '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}

function writeInstruction(instruction, options, depth) {
  if (options.ignoreInstruction) {
    return '';
  }

  var key;

  for (key in instruction) {
    if (instruction.hasOwnProperty(key)) {
      break;
    }
  }

  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;

  if (_typeof(instruction[key]) === 'object') {
    currentElement = instruction;
    currentElementName = instructionName;
    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
  } else {
    var instructionValue = instruction[key] ? instruction[key] : '';
    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
  }
}

function writeComment(comment, options) {
  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}

function writeCdata(cdata, options) {
  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}

function writeDoctype(doctype, options) {
  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}

function writeText(text, options) {
  if (options.ignoreText) return '';
  text = '' + text; // ensure Number and Boolean are converted to String

  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization

  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}

function hasContent(element, options) {
  var i;

  if (element.elements && element.elements.length) {
    for (i = 0; i < element.elements.length; ++i) {
      switch (element.elements[i][options.typeKey]) {
        case 'text':
          if (options.indentText) {
            return true;
          }

          break;
        // skip to next key

        case 'cdata':
          if (options.indentCdata) {
            return true;
          }

          break;
        // skip to next key

        case 'instruction':
          if (options.indentInstruction) {
            return true;
          }

          break;
        // skip to next key

        case 'doctype':
        case 'comment':
        case 'element':
          return true;

        default:
          return true;
      }
    }
  }

  return false;
}

function writeElement(element, options, depth) {
  currentElement = element;
  currentElementName = element.name;
  var xml = [],
      elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
  xml.push('<' + elementName);

  if (element[options.attributesKey]) {
    xml.push(writeAttributes(element[options.attributesKey], options, depth));
  }

  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';

  if (!withClosingTag) {
    if ('fullTagEmptyElementFn' in options) {
      withClosingTag = options.fullTagEmptyElementFn(element.name, element);
    } else {
      withClosingTag = options.fullTagEmptyElement;
    }
  }

  if (withClosingTag) {
    xml.push('>');

    if (element[options.elementsKey] && element[options.elementsKey].length) {
      xml.push(writeElements(element[options.elementsKey], options, depth + 1));
      currentElement = element;
      currentElementName = element.name;
    }

    xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
    xml.push('</' + elementName + '>');
  } else {
    xml.push('/>');
  }

  return xml.join('');
}

function writeElements(elements, options, depth, firstLine) {
  return elements.reduce(function (xml, element) {
    var indent = writeIndentation(options, depth, firstLine && !xml);

    switch (element.type) {
      case 'element':
        return xml + indent + writeElement(element, options, depth);

      case 'comment':
        return xml + indent + writeComment(element[options.commentKey], options);

      case 'doctype':
        return xml + indent + writeDoctype(element[options.doctypeKey], options);

      case 'cdata':
        return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);

      case 'text':
        return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);

      case 'instruction':
        var instruction = {};
        instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
        return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
    }
  }, '');
}

function hasContentCompact(element, options, anyContent) {
  var key;

  for (key in element) {
    if (element.hasOwnProperty(key)) {
      switch (key) {
        case options.parentKey:
        case options.attributesKey:
          break;
        // skip to next key

        case options.textKey:
          if (options.indentText || anyContent) {
            return true;
          }

          break;
        // skip to next key

        case options.cdataKey:
          if (options.indentCdata || anyContent) {
            return true;
          }

          break;
        // skip to next key

        case options.instructionKey:
          if (options.indentInstruction || anyContent) {
            return true;
          }

          break;
        // skip to next key

        case options.doctypeKey:
        case options.commentKey:
          return true;

        default:
          return true;
      }
    }
  }

  return false;
}

function writeElementCompact(element, name, options, depth, indent) {
  currentElement = element;
  currentElementName = name;
  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;

  if (typeof element === 'undefined' || element === null || element === '') {
    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
  }

  var xml = [];

  if (name) {
    xml.push('<' + elementName);

    if (_typeof(element) !== 'object') {
      xml.push('>' + writeText(element, options) + '</' + elementName + '>');
      return xml.join('');
    }

    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }

    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';

    if (!withClosingTag) {
      if ('fullTagEmptyElementFn' in options) {
        withClosingTag = options.fullTagEmptyElementFn(name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }

    if (withClosingTag) {
      xml.push('>');
    } else {
      xml.push('/>');
      return xml.join('');
    }
  }

  xml.push(writeElementsCompact(element, options, depth + 1, false));
  currentElement = element;
  currentElementName = name;

  if (name) {
    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
  }

  return xml.join('');
}

function writeElementsCompact(element, options, depth, firstLine) {
  var i,
      key,
      nodes,
      xml = [];

  for (key in element) {
    if (element.hasOwnProperty(key)) {
      nodes = isArray(element[key]) ? element[key] : [element[key]];

      for (i = 0; i < nodes.length; ++i) {
        switch (key) {
          case options.declarationKey:
            xml.push(writeDeclaration(nodes[i], options, depth));
            break;

          case options.instructionKey:
            xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth));
            break;

          case options.attributesKey:
          case options.parentKey:
            break;
          // skip

          case options.textKey:
            xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options));
            break;

          case options.cdataKey:
            xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options));
            break;

          case options.doctypeKey:
            xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
            break;

          case options.commentKey:
            xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
            break;

          default:
            xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
        }

        firstLine = firstLine && !xml.length;
      }
    }
  }

  return xml.join('');
}

module.exports = function (js, options) {
  options = validateOptions(options);
  var xml = [];
  currentElement = js;
  currentElementName = '_root_';

  if (options.compact) {
    xml.push(writeElementsCompact(js, options, 0, true));
  } else {
    if (js[options.declarationKey]) {
      xml.push(writeDeclaration(js[options.declarationKey], options, 0));
    }

    if (js[options.elementsKey] && js[options.elementsKey].length) {
      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
    }
  }

  return xml.join('');
};

},{"./array-helper":39,"./options-helper":43}],42:[function(require,module,exports){
(function (Buffer){
"use strict";

var js2xml = require('./js2xml.js');

module.exports = function (json, options) {
  if (json instanceof Buffer) {
    json = json.toString();
  }

  var js = null;

  if (typeof json === 'string') {
    try {
      js = JSON.parse(json);
    } catch (e) {
      throw new Error('The JSON structure is invalid');
    }
  } else {
    js = json;
  }

  return js2xml(js, options);
};

}).call(this,require("buffer").Buffer)
},{"./js2xml.js":41,"buffer":82}],43:[function(require,module,exports){
"use strict";

var isArray = require('./array-helper').isArray;

module.exports = {
  copyOptions: function copyOptions(options) {
    var key,
        copy = {};

    for (key in options) {
      if (options.hasOwnProperty(key)) {
        copy[key] = options[key];
      }
    }

    return copy;
  },
  ensureFlagExists: function ensureFlagExists(item, options) {
    if (!(item in options) || typeof options[item] !== 'boolean') {
      options[item] = false;
    }
  },
  ensureSpacesExists: function ensureSpacesExists(options) {
    if (!('spaces' in options) || typeof options.spaces !== 'number' && typeof options.spaces !== 'string') {
      options.spaces = 0;
    }
  },
  ensureAlwaysArrayExists: function ensureAlwaysArrayExists(options) {
    if (!('alwaysArray' in options) || typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray)) {
      options.alwaysArray = false;
    }
  },
  ensureKeyExists: function ensureKeyExists(key, options) {
    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {
      options[key + 'Key'] = options.compact ? '_' + key : key;
    }
  },
  checkFnExists: function checkFnExists(key, options) {
    return key + 'Fn' in options;
  }
};

},{"./array-helper":39}],44:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var sax = require('sax');

var expat
/*= require('node-expat');*/
= {
  on: function on() {},
  parse: function parse() {}
};

var helper = require('./options-helper');

var isArray = require('./array-helper').isArray;

var options;
var pureJsParser = true;
var currentElement;

function validateOptions(userOptions) {
  options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('alwaysChildren', options);
  helper.ensureFlagExists('addParent', options);
  helper.ensureFlagExists('trim', options);
  helper.ensureFlagExists('nativeType', options);
  helper.ensureFlagExists('nativeTypeAttributes', options);
  helper.ensureFlagExists('sanitize', options);
  helper.ensureFlagExists('instructionHasAttributes', options);
  helper.ensureFlagExists('captureSpacesBetweenElements', options);
  helper.ensureAlwaysArrayExists(options);
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.ensureKeyExists('parent', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  return options;
}

function nativeType(value) {
  var nValue = Number(value);

  if (!isNaN(nValue)) {
    return nValue;
  }

  var bValue = value.toLowerCase();

  if (bValue === 'true') {
    return true;
  } else if (bValue === 'false') {
    return false;
  }

  return value;
}

function addField(type, value) {
  var key;

  if (options.compact) {
    if (!currentElement[options[type + 'Key']] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)) {
      currentElement[options[type + 'Key']] = [];
    }

    if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];
    }

    if (type + 'Fn' in options && typeof value === 'string') {
      value = options[type + 'Fn'](value, currentElement);
    }

    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          if ('instructionFn' in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          } else {
            var temp = value[key];
            delete value[key];
            value[options.instructionNameFn(key, temp, currentElement)] = temp;
          }
        }
      }
    }

    if (isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']].push(value);
    } else {
      currentElement[options[type + 'Key']] = value;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }

    var element = {};
    element[options.typeKey] = type;

    if (type === 'instruction') {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          break;
        }
      }

      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;

      if (options.instructionHasAttributes) {
        element[options.attributesKey] = value[key][options.attributesKey];

        if ('instructionFn' in options) {
          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
        }
      } else {
        if ('instructionFn' in options) {
          value[key] = options.instructionFn(value[key], key, currentElement);
        }

        element[options.instructionKey] = value[key];
      }
    } else {
      if (type + 'Fn' in options) {
        value = options[type + 'Fn'](value, currentElement);
      }

      element[options[type + 'Key']] = value;
    }

    if (options.addParent) {
      element[options.parentKey] = currentElement;
    }

    currentElement[options.elementsKey].push(element);
  }
}

function manipulateAttributes(attributes) {
  if ('attributesFn' in options && attributes) {
    attributes = options.attributesFn(attributes, currentElement);
  }

  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {
    var key;

    for (key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        if (options.trim) attributes[key] = attributes[key].trim();

        if (options.nativeTypeAttributes) {
          attributes[key] = nativeType(attributes[key]);
        }

        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);

        if ('attributeNameFn' in options) {
          var temp = attributes[key];
          delete attributes[key];
          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
        }
      }
    }
  }

  return attributes;
}

function onInstruction(instruction) {
  var attributes = {};

  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {
    var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
    var match;

    while ((match = attrsRegExp.exec(instruction.body)) !== null) {
      attributes[match[1]] = match[2] || match[3] || match[4];
    }

    attributes = manipulateAttributes(attributes);
  }

  if (instruction.name.toLowerCase() === 'xml') {
    if (options.ignoreDeclaration) {
      return;
    }

    currentElement[options.declarationKey] = {};

    if (Object.keys(attributes).length) {
      currentElement[options.declarationKey][options.attributesKey] = attributes;
    }

    if (options.addParent) {
      currentElement[options.declarationKey][options.parentKey] = currentElement;
    }
  } else {
    if (options.ignoreInstruction) {
      return;
    }

    if (options.trim) {
      instruction.body = instruction.body.trim();
    }

    var value = {};

    if (options.instructionHasAttributes && Object.keys(attributes).length) {
      value[instruction.name] = {};
      value[instruction.name][options.attributesKey] = attributes;
    } else {
      value[instruction.name] = instruction.body;
    }

    addField('instruction', value);
  }
}

function onStartElement(name, attributes) {
  var element;

  if (_typeof(name) === 'object') {
    attributes = name.attributes;
    name = name.name;
  }

  attributes = manipulateAttributes(attributes);

  if ('elementNameFn' in options) {
    name = options.elementNameFn(name, currentElement);
  }

  if (options.compact) {
    element = {};

    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = {};
      var key;

      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          element[options.attributesKey][key] = attributes[key];
        }
      }
    }

    if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
      currentElement[name] = [];
    }

    if (currentElement[name] && !isArray(currentElement[name])) {
      currentElement[name] = [currentElement[name]];
    }

    if (isArray(currentElement[name])) {
      currentElement[name].push(element);
    } else {
      currentElement[name] = element;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }

    element = {};
    element[options.typeKey] = 'element';
    element[options.nameKey] = name;

    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = attributes;
    }

    if (options.alwaysChildren) {
      element[options.elementsKey] = [];
    }

    currentElement[options.elementsKey].push(element);
  }

  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent

  currentElement = element;
}

function onText(text) {
  if (options.ignoreText) {
    return;
  }

  if (!text.trim() && !options.captureSpacesBetweenElements) {
    return;
  }

  if (options.trim) {
    text = text.trim();
  }

  if (options.nativeType) {
    text = nativeType(text);
  }

  if (options.sanitize) {
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  addField('text', text);
}

function onComment(comment) {
  if (options.ignoreComment) {
    return;
  }

  if (options.trim) {
    comment = comment.trim();
  }

  addField('comment', comment);
}

function onEndElement(name) {
  var parentElement = currentElement[options.parentKey];

  if (!options.addParent) {
    delete currentElement[options.parentKey];
  }

  currentElement = parentElement;
}

function onCdata(cdata) {
  if (options.ignoreCdata) {
    return;
  }

  if (options.trim) {
    cdata = cdata.trim();
  }

  addField('cdata', cdata);
}

function onDoctype(doctype) {
  if (options.ignoreDoctype) {
    return;
  }

  doctype = doctype.replace(/^ /, '');

  if (options.trim) {
    doctype = doctype.trim();
  }

  addField('doctype', doctype);
}

function onError(error) {
  error.note = error; //console.error(error);
}

module.exports = function (xml, userOptions) {
  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');
  var result = {};
  currentElement = result;
  options = validateOptions(userOptions);

  if (pureJsParser) {
    parser.opt = {
      strictEntities: true
    };
    parser.onopentag = onStartElement;
    parser.ontext = onText;
    parser.oncomment = onComment;
    parser.onclosetag = onEndElement;
    parser.onerror = onError;
    parser.oncdata = onCdata;
    parser.ondoctype = onDoctype;
    parser.onprocessinginstruction = onInstruction;
  } else {
    parser.on('startElement', onStartElement);
    parser.on('text', onText);
    parser.on('comment', onComment);
    parser.on('endElement', onEndElement);
    parser.on('error', onError); //parser.on('startCdata', onStartCdata);
    //parser.on('endCdata', onEndCdata);
    //parser.on('entityDecl', onEntityDecl);
  }

  if (pureJsParser) {
    parser.write(xml).close();
  } else {
    if (!parser.parse(xml)) {
      throw new Error('XML parsing error: ' + parser.getError());
    }
  }

  if (result[options.elementsKey]) {
    var temp = result[options.elementsKey];
    delete result[options.elementsKey];
    result[options.elementsKey] = temp;
    delete result.text;
  }

  return result;
};

},{"./array-helper":39,"./options-helper":43,"sax":38}],45:[function(require,module,exports){
"use strict";

var helper = require('./options-helper');

var xml2js = require('./xml2js');

function validateOptions(userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureSpacesExists(options);
  return options;
}

module.exports = function (xml, userOptions) {
  var options, js, json, parentKey;
  options = validateOptions(userOptions);
  js = xml2js(xml, options);
  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent'; // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this

  if ('addParent' in options && options.addParent) {
    json = JSON.stringify(js, function (k, v) {
      return k === parentKey ? '_' : v;
    }, options.spaces);
  } else {
    json = JSON.stringify(js, null, options.spaces);
  }

  return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
};

},{"./options-helper":43,"./xml2js":44}],46:[function(require,module,exports){
module.exports={
  "name": "formssewernet",
  "version": "1.0.59",
  "description": "Forms for bmaps sewernet",
  "main": "forms.js",
  "scripts": {
    "test": "mocha test/forms.test.js",
    "watch": "watchify -g [ babelify --presets [ @babel/preset-env ] ] forms.js -o ../src/formsBundle.js",
    "dist": "browserify -g [ babelify --presets [ @babel/preset-env ] ] forms.js -o ../src/formsBundle.js | uglifyjs ../src/formsBundle.js -mc > ../dist/formsBundle.$npm_package_version.min.js",
    "build": "./build.sh"
  },
  "author": "Leandro Lopez-guerrero Hirsch",
  "license": "ISC",
  "dependencies": {
    "axios": "^0.19.2",
    "browser-request": "^0.3.3",
    "install": "^0.13.0",
    "jspdf": "^1.5.3",
    "mobile-detect": "^1.4.4",
    "npm": "^6.13.7",
    "xml-js": "^1.6.11"
  },
  "devDependencies": {
    "@babel/core": "^7.8.4",
    "@babel/preset-env": "^7.8.4",
    "babelify": "^10.0.0",
    "chai": "^4.2.0",
    "jsdom": "^11.12.0",
    "jsdom-global": "^3.0.2",
    "mocha": "^4.1.0",
    "mocha-jsdom": "^1.2.0",
    "sinon": "^4.5.0",
    "sinon-chai": "^2.14.0"
  }
}

},{}],47:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var jsPDF = require('jsPDF');

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _expected_api_version;

  var _composers;

  var _composerData;

  util.inherits(Print, _events);

  function Print(options) {
    _token = options.token;
    _baseHref = options.baseHref;
    _device = options.device;
    _expected_api_version = options.expected_api_version;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "Print.js", "Search module loaded", "success");
    }, 500);
  }

  function setToken(token) {
    _token = token;
  } //****************************************************************
  //*****************         GET PRINT FORM         ***************
  //****************************************************************

  /***
  	getPrintForm
  		builds print form
  			@scope public
  		@param composers<object>
  		@param cb<function>
  	***/


  function getPrintForm(composers, cb) {
    _self.emit("log", "Print.js", "getPrintForm(" + composers + ")", "info", composers);

    var retorno = Array();
    var composerNames = Array();
    _composerData = Array();
    _composerData.ComposerTemplates = Array();

    if (_typeof(composers) == "object") {
      for (var i = 0; i < composers.length; i++) {
        if (composers[i].getAttribute('name')) {
          var x;

          (function () {
            var item = {};
            item.ComposerTemplate = composers[i].getAttribute('name');
            item.ComposerMap = Array();
            x = composers[i].childNodes;
            x.forEach(function (node) {
              if (node.nodeName === "ComposerMap") {
                var ComposerMap = {
                  'width': node.getAttribute('width'),
                  'height': node.getAttribute('height'),
                  'name': node.getAttribute('name')
                };
                item.ComposerMap.push(ComposerMap);
              }
            });

            _composerData.ComposerTemplates.push(item);

            composerNames.push(composers[i].getAttribute('name'));
          })();
        }
      }
    }

    if (composerNames.length > 0) {
      var dataToSend = {};
      dataToSend.device = _device;
      dataToSend.composers = JSON.stringify(composerNames);
      dataToSend.token = _token;
      dataToSend.what = 'GET_PRINT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        try {
          if (response.data.status === "Accepted") {
            _self.emit("log", "Print.js", "getPrintForm", "success", response.data.message);

            if (typeof response.data.message.formTabs != "undefined") {
              retorno = response.data.message.formTabs;

              for (var _i = 0; _i < retorno.length; _i++) {
                for (var f = 0; f < retorno[_i].fields.length; f++) {
                  if (retorno[_i].fields[f]) {
                    if (retorno[_i].fields[f].type === "combo") {
                      retorno[_i].fields[f].comboValues = _assignValuesToCombo(retorno[_i].fields[f]);
                    }
                  }
                } //add a button


                retorno[_i].buttons = [_createButton("Print", "print", "printAction", false), _createButton("Screenshot", "screenshot", "captureScreenAction", false)]; //set active tab

                var activeTabIndex = _getActiveTab(response.data.message.formTabs);

                retorno.activeTab = response.data.message.formTabs[activeTabIndex];
                retorno.activeTab.activeTabIndex = activeTabIndex;
                retorno.formName = response.data.message.formInfo.formName;
              }

              cb(null, retorno);
            } else {
              cb("no fields", "no fields");
            }
          } else {
            cb(response.data, response.data);
          }
        } catch (e) {
          _self.emit("log", "Print.js", "getPrintForm", "error", e.message);

          cb("Error in getPrintForm: " + e.message, null);
        }
      })["catch"](function (error) {
        _self.emit("log", "Print.js", "getPrintForm", "error", error);
      });
    } else {
      cb("no composers", "no composers");
    }
  } //****************************************************************
  //*****************      END GET PRINT FORM        ***************
  //****************************************************************
  //****************************************************************
  //*****************           UPDATE PRINT         ***************
  //****************************************************************

  /***
  	updatePrint
  
  		@scope public
  		@param formData<object>
  		@param extent<string>
  			@param cb<function>
  	***/


  function updatePrint(formData, extent, use_tiled_background, cb) {
    _self.emit("log", "Print.js", "updatePrint(" + extent + "," + use_tiled_background + ")", "info", formData);

    var dataToSend = {};
    dataToSend.device = _device; //"ComposerTemplates":[{"ComposerTemplate":"mincutA4","ComposerMap":[{"width":"179.414","height":"140.826","name":"map0"},{"width":"77.729","height":"55.9066","name":"map7"}]},{"ComposerTemplate":"mincutA3","ComposerMap":[{"width":"53.44","height":"55.9066","name":"map7"},{"width":"337.865","height":"275.914","name":"map6"}]}]
    //dynamic attributes

    for (var k in formData) {
      if (formData.hasOwnProperty(k)) {
        if (formData[k] != "") {
          dataToSend[k] = formData[k];
        } else if (formData[k] === 0) {
          dataToSend[k] = "0";
        }
      }
    } //Add composer templates


    for (var k in _composerData) {
      if (_composerData.hasOwnProperty(k)) {
        if (_composerData[k] != "") {
          dataToSend[k] = _composerData[k];
        } else if (_composerData[k] === 0) {
          dataToSend[k] = "0";
        }
      }
    }

    dataToSend.extent = extent;
    dataToSend.use_tiled_background = use_tiled_background;
    dataToSend.token = _token;
    dataToSend.what = 'UPDATE_PRINT';
    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      try {
        if (response.data.status === "Accepted") {
          _self.emit("log", "Print.js", "updatePrint", "success", response.data.message);

          var retorno = {};
          var composerName = formData['composer'];
          retorno.composerName = composerName;
          retorno.extent = response.data.message.data.extent;
          retorno.map = response.data.message.data.map;
          retorno.geometry = response.data.message.data.geometry;

          if (typeof response.data.message.tiledLayers != "undefined") {
            var tiledLayers = Array();

            for (var i = 0; i < response.data.message.tiledLayers.length; i++) {
              tiledLayers.push(response.data.message.tiledLayers[i].layer_id);
            }

            retorno.tiledLayers = tiledLayers;
          } else {
            retorno.tiledLayers = null;
          }

          if (composerName) {
            cb(null, retorno);
          } else {
            cb("composer not found", "composer not found");
          }
        } else {
          cb(response.data, response.data);
        }
      } catch (e) {
        _self.emit("log", "Print.js", "updatePrint", "error", e.message);

        cb("Error in updatePrint: " + e.message, null);
      }
    })["catch"](function (error) {
      _self.emit("log", "Print.js", "updatePrint", "error", error);
    });
  } //****************************************************************
  //*****************       END UPDATE PRINT         ***************
  //****************************************************************
  //****************************************************************
  //*****************          PRINT COMPOSER        ***************
  //****************************************************************

  /***
  	printComposer
  		prints a composer
  			@scope public
  		@param composer<string>
  		@param extent<string>
  		@param cb<function>
  	***/


  function printComposer(composer, extent, map, tiledLayers, cb) {
    _self.emit("log", "Print.js", "printComposer(" + composer + "," + extent + "," + map + ")", "info", _baseHref + 'print.php?composer=' + composer + '&extent=' + extent.slice(1, -1) + "&map=" + map + "&tiledLayers=" + tiledLayers);

    window.open(_baseHref + 'print.php?composer=' + composer + '&extent=' + extent.slice(1, -1) + "&map=" + map + "&tiledLayers=" + tiledLayers); //delete generated pdf from server after N seconds

    setTimeout(function () {
      var dataToSend = {};
      dataToSend.token = _token;
      dataToSend.composer = composer;
      dataToSend.what = 'CLEAN_PRINT';
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "forms.js", "getWebForms", "success", response.data.message);

        cb(null, response.data);
      })["catch"](function (error) {
        _self.emit("log", "Print.js", "printComposer", "error", error);
      });
    }, 5000);
  } //****************************************************************
  //*****************       END PRINT COMPOSER       ***************
  //****************************************************************
  //****************************************************************
  //*****************          CAPTURE SCREEN        ***************
  //****************************************************************


  function captureScreen(map, cb) {
    _self.emit("log", "Print.js", "captureScreen()", "info");

    var format = 'a4';
    var resolution = 150;
    var dim = [297, 210];
    var width = Math.round(dim[0] * resolution / 25.4);
    var height = Math.round(dim[1] * resolution / 25.4);
    var size =
    /** @type {module:ol/size~Size} */
    map.getSize();
    var totalLayers = map.getLayers().getLength();
    var currentRendered = 0;
    var tiledStarted = 0;
    var tiledEnd = 0;
    var pdfGenerated = false;
    var extent = map.getView().calculateExtent(size);
    var erroTo = setTimeout(function () {
      _self.emit("log", "Print.js", "captureScreen() error", "warn");

      map.setSize(size);
      map.getView().fit(extent, {
        size: size
      });
      cb(true, "Uncacatched print error");
    }, 60000);
    map.setSize(size);
    map.getView().fit(extent, {
      size: size
    });
    map.once('postcompose', function (event) {
      try {
        var canvas = event.context.canvas;
        map.getLayers().forEach(function (layer) {
          layer.once('postcompose', function (evt2) {
            var sc = layer.getSource();
            var listenerKey = sc.on('tileloadstart', function () {
              tiledStarted++;
            });
            var listenerKey2 = sc.on('tileloadend', function (kk) {
              tiledEnd++;

              if (tiledStarted == tiledEnd) {
                if (!pdfGenerated) {
                  pdfGenerated = true;
                  setTimeout(function () {
                    var data = canvas.toDataURL('image/png');
                    var pdf = new jsPDF('landscape', undefined, format);
                    pdf.addImage(data, 'JPEG', 0, 0, dim[0], dim[1]);
                    pdf.save('map.pdf');

                    _self.emit("log", "Print.js", "captureScreen() PDF generated", "success");

                    map.setSize(size);
                    map.getView().fit(extent, {
                      size: size
                    });
                    ol.Observable.unByKey(listenerKey);
                    ol.Observable.unByKey(listenerKey2);
                    cb(null, null);
                    clearTimeout(erroTo);
                    erroTo = null;
                  }, 10000);
                }
              }
            });
          });
        });
      } catch (e) {
        _self.emit("log", "Print.js", "captureScreen() CORS error", "warn", e);

        map.setSize(size);
        map.getView().fit(extent, {
          size: size
        });
        cb(true, "One of the backgrounds is not exportable");
      }
    }); // Set print size

    var printSize = [width, height];
    map.setSize(printSize);
    map.getView().fit(extent, {
      size: printSize
    });
    map.renderSync();
  } //****************************************************************
  //*****************       END CAPTURE SCREEN       ***************
  //****************************************************************
  //****************************************************************
  //*************           SETTERS/GETTERS          ***************
  //****************************************************************

  /***
  	_createCombo
  		creates JSON for form combo component
  			@scope private
  		@param data<json>
  			@return <json>
  	***/


  function _createCombo(data) {
    var retorno = {};
    retorno.comboIds = data;
    retorno.comboNames = data;
    var comboValues = Array();

    for (var i = 0; i < data.length; i++) {
      comboValues.push({
        id: data[i],
        name: data[i]
      });
    }

    retorno.comboValues = comboValues;
    retorno.dataType = "string";
    retorno.disabled = false;
    retorno.label = "Composer";
    retorno.name = "Composer";
    retorno.selectedId = data[0];
    retorno.type = "combo";
    return retorno;
  }
  /***
  	_createButton
  		creates JSON for form button component
  			@scope private
  		@param label<string>
  		@param name<string>
  		@param action<string>
  		@param disabled<boolean>
  			@return <json>
  	***/


  function _createButton(label, name, action, disabled) {
    var retorno = {};
    retorno.buttonAction = action;
    retorno.disabled = disabled;
    retorno.label = label;
    retorno.name = name;
    retorno.type = "button";
    return retorno;
  }
  /***
  	_assignValuesToCombo
  		formats data for form combo component
  			@scope private
  		@param object<object>
  			@return <json>
  	***/


  function _assignValuesToCombo(object) {
    var comboValues = Array();

    try {
      for (var i = 0; i < object.comboIds.length; i++) {
        comboValues.push({
          id: object.comboIds[i],
          name: object.comboNames[i]
        });

        if (object.name === "composer") {
          for (var c = 0; c < _composerData.length; c++) {
            if (_composerData[i] === object.comboNames[i]) {
              _composerData[i].id = object.comboIds[i];
            }
          }
        }
      }

      if (object.name === "composer") {
        _composers = comboValues;
      }

      return comboValues;
    } catch (e) {
      _self.emit("log", "print.js", "_assignValuesToCombo error formatting combo", "error", e.message);

      return false;
    }
  }

  function _getActiveTab(tabs) {
    if (tabs.length > 0) {
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].active) {
          return i;
          break;
        }
      }
    }
  } //****************************************************************
  //*************          END SETTERS/GETTERS       ***************
  //****************************************************************


  module.exports = Print;
  Print.prototype.getPrintForm = getPrintForm;
  Print.prototype.printComposer = printComposer;
  Print.prototype.updatePrint = updatePrint;
  Print.prototype.captureScreen = captureScreen;
  Print.prototype.setToken = setToken;
})();

},{"axios":10,"events":84,"jsPDF":36,"util":109}],48:[function(require,module,exports){
"use strict";

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _expected_api_version;

  var _activeTab = null;
  var _tabs = null;

  var _availableTabs = Array('network', 'search', 'hydro', 'workcat', 'psector', 'address', 'visit');

  util.inherits(Search, _events);

  function Search(options) {
    _token = options.token;
    _baseHref = options.baseHref;
    _device = options.device;
    _expected_api_version = options.expected_api_version;
    _self = this;
    setTimeout(function () {
      _self.emit("log", "Search.js", "Search module loaded", "success");
    }, 700);
  }

  function setToken(token) {
    _token = token;
  } //****************************************************************
  //*****************         GET SEARCH FORM        ***************
  //****************************************************************

  /***
  	getSearchForm
  		gets search  forms
  			@scope public
  		@param cb<function>
  	***/


  function getSearchForm(cb) {
    _self.emit("log", "Search.js", "getSearchForm()", "info");

    var dataToSend = {};
    dataToSend.device = _device;
    dataToSend.token = _token;
    dataToSend.what = 'GET_SEARCH';
    dataToSend.expected_api_version = _expected_api_version;
    var retorno = {};
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      try {
        if (response.data.status === "Accepted") {
          _self.emit("log", "Search.js", "getSearchForm", "success", response.data.message);

          if (typeof response.data.message.formTabs != "undefined") {
            retorno = response.data.message.formTabs;

            for (var i = 0; i < retorno.length; i++) {
              if (_availableTabs.indexOf(retorno[i].tabName.toLowerCase()) > -1) {
                for (var f = 0; f < retorno[i].fields.length; f++) {
                  if (retorno[i].fields[f]) {
                    if (retorno[i].fields[f].type === "combo") {
                      retorno[i].fields[f].comboValues = _assignValuesToCombo(retorno[i].fields[f]);

                      if (retorno[i].tabName.toLowerCase() === "address") {
                        retorno[i].fields[f].changeAction = "searchTown";
                      }
                    } else if (retorno[i].fields[f].type === "typeahead") {
                      var actions = _getTabActions(retorno[i].tabName.toLowerCase(), retorno[i].fields[f].name);

                      retorno[i].fields[f].getDataAction = actions.dataAction;
                      retorno[i].fields[f].selectAction = actions.selectAction;
                      retorno[i].fields[f].tabName = retorno[i].tabName.toLowerCase();

                      if (typeof retorno[i].fields[f].searchService == "undefined") {
                        retorno[i].fields[f].searchService = null;
                      }
                    }
                  }
                }
              } else {
                _self.emit("log", "Search.js", "getSearchForm tab " + retorno[i].tabName + " not implemented", "error");
              }
            } //sets active tab


            var activeTabIndex = _getActiveTab(response.data.message.formTabs);

            retorno.activeTab = response.data.message.formTabs[activeTabIndex];
            retorno.activeTab.activeTabIndex = activeTabIndex;
            _tabs = retorno;
            cb(null, retorno);
          } else {
            cb("no fields", "no fields");
          }
        } else {
          cb(body, body.message);
        }
      } catch (e) {
        _self.emit("log", "Search.js", "getSearchForm", "error", e.message);

        cb("Error in getSearchForm: " + e.message, null);
      }
    })["catch"](function (error) {
      _self.emit("log", "Search.js", "getSearchForm", "error", error);
    });
  } //****************************************************************
  //*************           END GET SEARCH FORM      ***************
  //****************************************************************
  //****************************************************************
  //*****************           GET ADDRESS          ***************
  //****************************************************************

  /***
  	getDataForAddress
  		gets data for typeahead address with nominatim
  			@scope public
  		@param cb<function>
  	***/


  function getDataForAddress(extent, val, searchService) {
    _self.emit("log", "Search.js", "getDataForAddress(" + extent + "," + val + "," + searchService + ")", "info");

    var options = {
      uri: _baseHref + "/ajax.address.php",
      qs: {
        criteria: val,
        country: 'es',
        token: _token,
        extent: extent,
        service: searchService,
        json: 1
      },

      /*	headers: {
      			'User-Agent': 'Request-Promise'
      	},*/
      json: true
    };
    return axios.post(_baseHref + '/ajax.address.php', options).then(function (response) {
      return response.data.map(function (item) {
        return item;
      });
    })["catch"](function (error) {
      return error;
    });
    /*	return rp(options).then(function (response) {
    		return response.map(function(item){
    			return item;
    		});
    	}).catch(function (err) {
    		return err;
    	});*/
  } //****************************************************************
  //*************             END GET ADDRESS        ***************
  //****************************************************************
  //****************************************************************
  //*****************         UPDATE SEARCH          ***************
  //****************************************************************


  function updateSearch(fields, tabName, fieldName, val) {
    _self.emit("log", "Search.js", "updateSearch(" + tabName + "," + fieldName + "," + val + ")", "info", fields);

    var _processedFields = _processDataToSend(tabName, fields);

    var dataToSend = {};
    dataToSend.device = _device;
    dataToSend.token = _token;
    dataToSend.what = 'UPDATE_SEARCH';
    dataToSend.expected_api_version = _expected_api_version;
    dataToSend.searchData = JSON.stringify(_processedFields);
    dataToSend.json = 1;
    return axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        return response.data.message.data.map(function (item) {
          return item;
        });
      } else {
        return response;
      }
    })["catch"](function (error) {
      return error;
    });
    /*
    var options = {
    		method: 'POST',
    		uri: _baseHref+"/ajax.sewernet.php",
    		body: dataToSend,
    		headers: {
    				'User-Agent': 'Request-Promise'
    		},
    		json: true
    };
    return rp(options).then(function (response) {
    			if(response.status==="Accepted"){
    			return response.message.data.map(function(item){
    				return item;
    			});
    		}else{
    			return response;
    		}
    	}).catch(function (err) {
    		return err;
    	});*/
  } //****************************************************************
  //*****************        END UPDATE SEARCH       ***************
  //****************************************************************
  //****************************************************************
  //*****************       UPDATE SEARCH ADD        ***************
  //****************************************************************


  function updateSearchAdd(fields, tabName, fieldName, val) {
    _self.emit("log", "Search.js", "updateSearchAdd(" + tabName + "," + fieldName + "," + val + ")", "info", fields);

    var _processedFields = _processDataToSend(tabName, fields);

    var dataToSend = {};
    dataToSend.device = _device;
    dataToSend.token = _token;
    dataToSend.what = 'UPDATE_SEARCH_ADD';
    dataToSend.expected_api_version = _expected_api_version;
    dataToSend.searchData = JSON.stringify(_processedFields);
    dataToSend.json = 1;
    return axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      if (response.data.status === "Accepted") {
        return response.data.message.data.map(function (item) {
          return item;
        });
      } else {
        return response;
      }
    })["catch"](function (error) {
      return error;
    });
    /*
    var options = {
    		method: 'POST',
    		uri: _baseHref+"/ajax.sewernet.php",
    		body: dataToSend,
    		headers: {
    				'User-Agent': 'Request-Promise'
    		},
    		json: true
    };
    return rp(options).then(function (response) {
    			if(response.status==="Accepted"){
    			return response.message.data.map(function(item){
    				return item;
    			});
    		}else{
    			return response;
    		}
    	}).catch(function (err) {
    		return err;
    	});*/
  } //****************************************************************
  //****************      END UPDATE SEARCH ADD      ***************
  //****************************************************************
  //****************************************************************
  //*************           SETTERS/GETTERS          ***************
  //****************************************************************

  /***
  	_assignValuesToCombo
  		formats data for form combo component
  			@scope private
  		@param object<object>
  			@return <json>
  	***/


  function _assignValuesToCombo(object) {
    var comboValues = Array();

    try {
      for (var i = 0; i < object.comboIds.length; i++) {
        comboValues.push({
          id: object.comboIds[i],
          name: object.comboNames[i]
        });
      }

      return comboValues;
    } catch (e) {
      _self.emit("log", "Search.js", "_assignValuesToCombo error formatting combo", "error", e.message);

      return false;
    }
  }
  /***
  	_getTabActions
  		assigns actions to typeahead components
  			@scope private
  		@param tabName <string>
  		@param fieldName <string>
  			@return <json>
  	***/


  function _getTabActions(tabName, fieldName) {
    if (tabName.toLowerCase() === "search") {
      return {
        dataAction: "getDataForAddress",
        selectAction: "selectAddress"
      };
    } else if (tabName.toLowerCase() === "address") {
      if (fieldName === "add_street") {
        return {
          dataAction: "updateSearch",
          selectAction: "selectStreet"
        };
      } else if (fieldName === "add_postnumber") {
        return {
          dataAction: "updateSearchAdd",
          selectAction: "selectAddress"
        };
      } else {
        return {
          dataAction: "updateSearch",
          selectAction: "selectAddress"
        };
      }
    } else {
      return {
        dataAction: "updateSearch",
        selectAction: "executeSearch"
      };
    }
  }
  /***
  	_processDataToSend
  		gets the fields&values from a tab
  			@scope private
  		@param tabName<string>
  		@param fields<json>
  			@return <json>
  ***/


  function _processDataToSend(tabName, fields) {
    var retorno = [];

    for (var i = 0; i < _tabs.length; i++) {
      if (_tabs[i].tabName === tabName) {
        var item = {};
        item['tabName'] = _tabs[i].tabName.toLowerCase();

        for (var key in fields) {
          for (var f = 0; f < _tabs[i].fields.length; f++) {
            if (_tabs[i].fields[f].name === key) {
              if (_tabs[i].fields[f].type === "combo") {
                //find comboName
                var name = _tabs[i].fields[f].comboNames[_tabs[i].fields[f].comboIds.indexOf(fields[key])];

                item[key] = {
                  "id": fields[key],
                  "name": name
                };
              } else if (_tabs[i].fields[f].type === "typeahead") {
                item[key] = {
                  "text": fields[key]
                };
              }
            }
          }
        }

        retorno.push(item);
      }
    }

    return retorno;
  }

  function _getActiveTab(tabs) {
    if (tabs.length > 0) {
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].active) {
          return i;
          break;
        }
      }
    }
  } //****************************************************************
  //*************          END SETTERS/GETTERS       ***************
  //****************************************************************


  module.exports = Search;
  Search.prototype.getSearchForm = getSearchForm;
  Search.prototype.getDataForAddress = getDataForAddress;
  Search.prototype.updateSearch = updateSearch;
  Search.prototype.updateSearchAdd = updateSearchAdd;
  Search.prototype.setToken = setToken;
})();

},{"axios":10,"events":84,"util":109}],49:[function(require,module,exports){
"use strict";

var _mapStorage = _interopRequireDefault(require("../offline/mapStorage"));

var _visits_offline = _interopRequireDefault(require("../offline/visits_offline"));

var _richLogger = _interopRequireDefault(require("../src/richLogger"));

var _form_utils = _interopRequireDefault(require("./form_utils"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*jshint esversion: 6 */
(function () {
  'use strict';

  var util = require('util');

  var _events = require('events').EventEmitter;

  var axios = require('axios');

  var parser = require('xml-js');

  var _version = "1.1.3";

  var _self;

  var _token;

  var _baseHref;

  var _device;

  var _tabs = null;

  var _expected_api_version;

  var _options = null;
  var _formUtils = null; //form utils module

  var _logger = null; //logger module

  var _storage = null; //storage module

  var _visitOffline = null; //visits offline module

  util.inherits(Visits, _events);

  function Visits(options) {
    _token = options.token;
    _baseHref = options.baseHref;
    _device = options.device;
    _expected_api_version = options.expected_api_version;
    _self = this;
    _options = options;
    _logger = new _richLogger["default"](_options.env, {});
    _formUtils = new _form_utils["default"](_options, _self, _logger);
    setTimeout(function () {
      _self.emit("log", "visits.js", "Visits v." + _version + " loaded", "success", _options);
    }, 500);
  }

  function setToken(token) {
    _token = token;
  } //****************************************************************
  //******************           VISIT         *********************
  //****************************************************************


  function getVisitsFromFeature(layer, pol_id, id_name, options, cb) {
    _self.emit("log", "visits.js", "getVisitsFromFeature(" + layer + "," + pol_id + ")", "info", options);

    try {
      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.device = _device;
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name; //remove timezone from filters

      if (options) {
        var date = options.visit_start;
        var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes()));
        options.visit_start = utcDate;
        date = options.visit_end;
        utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes()));
        options.visit_end = utcDate;
        dataToSend.options = JSON.stringify(options);
      }

      dataToSend.token = _token;
      dataToSend.what = 'VISITS_FROM_FEAUTURE';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "getVisitsFromFeature", "success", response.data.message);

        cb(null, response.data.message);
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "getVisitsFromFeature error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "getVisitsFromFeature error", "error", e);

      cb(e, false);
    }
  }

  function getWebFormsForVisit(formIdentifier, pol_id, id_name, options, constants, cb) {
    _self.emit("log", "visits.js", "getWebFormsForVisit(" + formIdentifier + "," + pol_id + ")", "info", options);

    try {
      var dataToSend = {}; //dataToSend.layer			= layer

      dataToSend.device = _device;
      dataToSend.form = formIdentifier;
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name; //remove timezone from filters

      if (options) {
        var date = options.visit_start;
        var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes()));
        options.visit_start = utcDate;
        date = options.visit_end;
        utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes()));
        options.visit_end = utcDate;
        dataToSend.options = JSON.stringify(options);
      }

      dataToSend.token = _token;
      dataToSend.what = 'VISITS';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          var msg = response.data.message;
          var retorn = {};

          _self.emit("log", "visits.js", "getWebFormsForVisit", "success", msg); //parameter type select


          if (msg.parameter_type_options.length > 0) {
            //msg.parameter_type_options.unshift({'parameter_type':constants.get('SELECT')});
            retorn.parameter_type_options = msg.parameter_type_options;

            if (options.parameter_type === null) {
              retorn.parameter_type = msg.parameter_type_options[0].id;
            } else {
              var obj = msg.parameter_type_options;
              var index = functionFindIndexByKeyValue(obj, "id", options.parameter_type);

              if (index > -1 && index != null) {
                retorn.parameter_type = msg.parameter_type_options[index].id;
              } else {
                retorn.parameter_type = msg.parameter_type_options[0].id;
              }
            }
          } //parameter_id select


          if (msg.parameter_id_options.length > 0) {
            //msg.parameter_id_options.unshift({'parameter_id':constants.get('SELECT')});
            retorn.parameter_id_options = msg.parameter_id_options;

            if (options.parameter_id === null) {
              retorn.parameter_id = msg.parameter_id_options[0].id;
            } else {
              var _obj = msg.parameter_id_options;

              var _index = functionFindIndexByKeyValue(_obj, "id", options.parameter_id);

              if (_index > -1 && _index != null) {
                retorn.parameter_id = msg.parameter_id_options[_index].id;
              } else {
                retorn.parameter_id = msg.parameter_id_options[0].id;
              }
            }
          } //events view


          if (msg.events.length > 0) {
            retorn.visitData_options = msg.events;
          } else {
            retorn.visitData_options = Array();
          }

          if (msg.parameter_id_options.length === 0 || msg.parameter_type_options.length === "0") {
            retorn = {};
            cb("Error requesting visit form", retorn);
          } else {
            cb(null, retorn);
          }
        } else {
          cb(response.data, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "getWebFormsForVisit error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "getWebFormsForVisit error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //******************        END VISIT         ********************
  //****************************************************************
  //****************************************************************
  //*******************         VISIT DELETE        ****************
  //****************************************************************


  function deleteVisit(visit_id, layer, cb) {
    try {
      _self.emit("log", "visits.js", "deleteVisit(" + visit_id + "," + layer + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.visit_id = visit_id;
      dataToSend.token = _token;
      dataToSend.what = 'DELETE_VISIT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "deleteVisit", "success", response.data.message);

        if (response.data.status === "Accepted") {
          cb(null, true);
        } else {
          cb(response.data.message, false);
        }
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "deleteVisit error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "deleteVisit error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*******************      END VISIT DELETE       ****************
  //****************************************************************
  //****************************************************************
  //*******************          INSERT VISIT       ****************
  //****************************************************************


  function upsertVisit(layer, coordinates, epsg, pol_id, id_name, cb) {
    try {
      _self.emit("log", "visits.js", "upsertVisit(" + layer + "," + coordinates + "," + epsg + "," + pol_id + "," + id_name + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.coordinates = coordinates.toString();
      dataToSend.epsg = epsg;
      dataToSend.device = _device;
      dataToSend.token = _token;
      dataToSend.what = 'UPSERT_VISIT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "visits.js", "upsertVisit response", "success", response.data.message);

          var retorno = {};
          retorno.visitcat_id_options = response.data.message.visicat_id_options;
          retorno.visitcat_id = response.data.message.visicat_id[0];
          retorno.visit_id = response.data.message.visit_id;
          retorno.visit_isDone = response.data.message.visit_isDone; //parameter type

          if (response.data.message.parameter_type_options.length > 0) {
            retorno.parameter_type_options = response.data.message.parameter_type_options;
          }

          retorno.parameter_type = retorno.parameter_type_options[0].id; //parameter_id

          if (response.data.message.parameter_id_options.length > 0) {
            retorno.parameter_id_options = response.data.message.parameter_id_options;
            retorno.parameter_id = retorno.parameter_id_options[0].id;
          } else {
            _self.emit("log", "visits.js", "upsertVisit no parameter_id_options", "warn");
          }

          retorno.code = response.data.message.code; //Events

          if (typeof response.data.message.events == "undefined") {
            retorno.events = [];
          } else {
            retorno.events = response.data.message.events;
          }

          cb(null, retorno);
        } else {
          cb(response.data, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "upsertVisit error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "upsertVisit error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*******************       END INSERT VISIT      ****************
  //****************************************************************
  //****************************************************************
  //*******************          UPDATE VISIT       ****************
  //****************************************************************


  function updateVisit(layer, visit_id, key, value, pol_id, id_name, cb) {
    try {
      _self.emit("log", "visits.js", "updateVisit(" + layer + "," + key + "," + value + "," + pol_id + "," + id_name + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.visit_id = visit_id;
      dataToSend.key = key;
      dataToSend.value = value;
      dataToSend.token = _token;
      dataToSend.what = 'UPDATE_VISIT';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "updateVisit", "success", response.data.message);

        if (response.data.status === "Accepted") {
          cb(null, response.data.message);
        } else {
          cb(response.data.message, response.data.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "updateVisit error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "updateVisit error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //*******************      END UPDATE VISIT       ****************
  //****************************************************************
  //****************************************************************
  //******     GET PARAMETER ID FOR A PARAMETER TYPE      **********
  //****************************************************************


  function getParameterIdFromParameterType(layer, parameterType, id_name, cb) {
    try {
      _self.emit("log", "visits.js", "getParameterIdFromParameterType(" + layer + "," + parameterType + ")", "info");

      var dataToSend = {};
      dataToSend.layer = layer;
      dataToSend.parameterType = parameterType;
      dataToSend.id_name = id_name;
      dataToSend.token = _token;
      dataToSend.what = 'GET_PARAMETER_ID_FOR_PARAMETER_ID';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "getParameterIdFromParameterType", "success", response.data.message);

        if (response.data.status === "Accepted") {
          cb(null, response.data.message.parameter_id_options);
        } else {
          cb(response.data.message, false);
        }
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "getParameterIdFromParameterType error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "getParameterIdFromParameterType error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //******   END GET PARAMETER ID FOR A PARAMETER TYPE     *********
  //****************************************************************
  //****************************************************************
  //*************                                    ***************
  //*************     NEW VISITS IMPLEMENTATION      ***************
  //*************                                    ***************
  //****************************************************************
  //****************************************************************
  //*************              GET VISITS            ***************
  //****************************************************************

  /*
  	gwGetVisit
  		Chapuza, las requests que vengan del antiguo tab visits, llevan chapuza=true porque la query va harcoded....
  	*/


  function gwGetVisit(data, cb) {
    try {
      _self.emit("log", "visits.js", "gwGetVisit(" + data.pol_id + "," + data.id_name + "," + data.tableName + ',' + data.visit_id + ")", "info", data);

      var action = null;
      var _extraData = data.extraData;
      var extraDataToSend = _extraData;

      if (_extraData) {
        if (_extraData.action === "newFile") {
          action = _extraData.action;
          var metaData = null;

          if (typeof data.metaData != 'undefined') {
            metaData = data.metaData;
          }

          extraDataToSend = _formUtils.formatPhotoData(_extraData.fileName, _extraData.hash, data.visit_id, data.deviceTrace, metaData);
        } else if (_extraData.action === "deleteFile") {
          action = _extraData.action;
          extraDataToSend = {
            'deleteFile': {
              'feature': {
                'id': _extraData.deleteFile.feature
              }
            }
          };
        }

        data.extraData = extraDataToSend;
      }

      if (_options.visit_offline && action === null && !data.isOffline) {
        //get offline form
        if (!data.online) {
          var form = _storage.getItem("bmaps_".concat(_options.project_id, "_ov_").concat(data.tableName, "_").concat(data.visitType));

          if (form) {
            _self.emit("log", "visits.js", "gwGetVisit offline form", "info", {
              'form': form,
              'formContent': JSON.parse(form)
            });

            cb(null, JSON.parse(form));
            return;
          } else {
            _self.emit("log", "visits.js", "gwGetVisit offline form not found", "warning", JSON.parse(form));

            return;
          }
        }

        delete data.online;

        _dogwGetVisitRequest(data, cb);
      } else {
        _dogwGetVisitRequest(data, cb);
      }
    } catch (e) {
      _self.emit("log", "visits.js", "gwGetVisit error", "error", e);

      cb(e, false);
    }
  }

  function _dogwGetVisitRequest(data, cb) {
    _self.emit("log", "visits.js", "_dogwGetVisitRequest", "info", data);

    var dataToSend = {};
    dataToSend.pol_id = data.pol_id;
    dataToSend.id_name = data.id_name;
    dataToSend.device = data.device;
    dataToSend.info_type = data.info_type;
    dataToSend.visit_id = data.visit_id;
    dataToSend.visitType = data.visitType;
    dataToSend.tableName = data.tableName;
    dataToSend.isOffline = data.isOffline;
    dataToSend.formParameters = JSON.stringify(data.formParameters);
    dataToSend.formFeatureData = JSON.stringify(data.formFeatureData);
    dataToSend.formPagination = JSON.stringify(data.formPagination);
    dataToSend.extraData = JSON.stringify(data.extraData);
    dataToSend.deviceTrace = JSON.stringify(data.deviceTrace);
    dataToSend.token = _options.token; //dynamic attributes

    for (var k in data.formData) {
      if (data.formData.hasOwnProperty(k)) {
        if (data.formData[k] != "") {
          dataToSend[k] = data.formData[k];
        } else if (data.formData[k] === 0) {
          dataToSend[k] = "0";
        }
      }
    }

    if (data.chapuza) {
      dataToSend.what = 'gwGetVisitChapuza';
    } else {
      dataToSend.what = 'gwGetVisit';
    }

    dataToSend.expected_api_version = _expected_api_version;
    axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
      _processReponse(null, response.data, 'gwGetVisit', cb);
    })["catch"](function (error) {
      _self.emit("log", "visits.js", "gwGetVisit error", "error", error);

      cb(error, false);
    });
  }

  function _prepareFormsToDonwload() {
    _self.emit("log", "visits.js", "_prepareFormsToDonwload()", "info", _options);

    var formsWithLayers = Array();

    for (var i = 0; i < _options.project_layers.names.length; i++) {
      //check is layer is available offline
      if (_options.project_layers.offline.indexOf(_options.project_layers.names[i]) > -1) {
        //check is layer is visitable
        if (_options.project_layers.visitable.indexOf(_options.project_layers.names[i]) > -1) {
          formsWithLayers.push({
            'name': _options.project_layers.names[i],
            'table': _options.project_layers.tables[i],
            'visitType': 'visit'
          });
          formsWithLayers.push({
            'name': _options.project_layers.names[i],
            'table': _options.project_layers.tables[i],
            'visitType': 'incidence'
          });
        }
      }
    }

    return formsWithLayers;
  } //get offline visit form


  function storeVisitForms() {
    _self.emit("log", "visits.js", "storeVisitForms", "info");

    var availableForms = _prepareFormsToDonwload();

    if (availableForms.length === 0) {
      _self.emit("log", "visits.js", "No available forms to donwload", "warn", {
        'offline': _options.project_layers.offline,
        'visitibale': _options.project_layers.visitable
      });

      _self.emit("offlineEvent", "dumpData", {
        "text": "noDownloadbaleForms"
      });

      return;
    }

    _self.emit("log", "visits.js", "storeVisitForms " + availableForms.length + " available Forms", "info", availableForms);

    _visitOffline.clearVisitedSpots(); //get layer id name from WFS request


    var _loop = function _loop() {
      _self.emit("log", "visits.js", "trying to store ", "info", availableForms[i]);

      var visitType = availableForms[i].visitType;

      _getWfsLayerIdName(availableForms[i].name, availableForms[i].table).then(function (response) {
        if (response) {
          var dataToSend = {
            'pol_id': null,
            'id_name': response.id_name,
            'visitType': visitType,
            'tableName': response.table,
            'visit_id': null,
            'info_type': _options.info_type,
            'formParameters': {},
            'formFeatureData': null,
            'formPagination': null,
            'feature': null,
            'deviceTrace': null,
            'extraData': null,
            'chapuza': false,
            'device': _options.device,
            'isOffline': true
          };
          gwGetVisit(dataToSend, function (e, res) {
            if (e) {
              _self.emit("log", "visits.js", "storing offline visit error", 'error', {
                'error': e,
                'response': res
              });

              _self.emit("offlineEvent", "dumpData", {
                "text": "visitFormDownloadError"
              });

              return;
            } //store form here


            _self.emit("log", "visits.js", "storing visit form as bmaps_".concat(_options.project_id, "_ov_").concat(response.table, "_").concat(visitType), "success", res);

            _storage.setItem("bmaps_".concat(_options.project_id, "_ov_").concat(response.table, "_").concat(visitType), JSON.stringify(res));

            if (i === availableForms.length) {
              _self.emit("log", "visits.js", "storing offline visit forms DONE", "success", res);

              _self.emit("offlineEvent", "dumpData", {
                "text": "visitFormDownloadDone"
              });
            }
          });
        } else {
          _self.emit("log", "visits.js", "storeVisitForms empty WFS response", "error", response);

          _self.emit("offlineEvent", "dumpData", {
            "text": "visitFormDownloadError"
          });
        }
      })["catch"](function (e) {
        _self.emit("log", "visits.js", "storeVisitForms error requesting WFS", "error", e);

        _self.emit("offlineEvent", "dumpData", {
          "text": "visitFormDownloadError"
        });
      });
    };

    for (var i = 0; i < availableForms.length; i++) {
      _loop();
    }
  } //****************************************************************
  //************            END GET VISITS             *************
  //****************************************************************
  //****************************************************************
  //************                SET VISIT              *************
  //****************************************************************


  function gwSetVisit(data, cb) {
    try {
      _self.emit("log", "visits.js", "gwSetVisit()", "info", data);

      var retorno = {};

      var dataToSend = _formatDataForgwSetVisit(data);

      if (navigator.onLine) {
        axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
          _self.emit("log", "visits.js", "gwSetVisit", "success", response.data.message);

          if (response.data.status === "Accepted") {
            if (_options.visited_spots_layer) {
              if (_visitOffline != null) {
                _visitOffline.storeVisitedSpot(_options.project_id, data.selectedGeomString);
              }
            }

            cb(null, response.data.message);
          } else {
            _self.emit("log", "visits.js", "gwSetVisit", "error", response.data.message);

            cb(response.data.message, response.data.message);
          }
        })["catch"](function (error) {
          _self.emit("log", "visits.js", "gwSetVisit error", "error", error);

          cb(error, false);
        });
      } else {
        if (_visitOffline === null) {
          cb("offline visit not supported", false);
          return;
        }

        if (_options.visit_offline) {
          //store here setVisit request
          _visitOffline.storeOfflineVisit(_options.project_id, {
            'pol_id': data.pol_id,
            'id_name': data.pol_id_name,
            'tableName': data.tableName,
            'dataToSend': dataToSend,
            'type': 'data',
            'selectedGeomString': data.selectedGeomString
          });

          cb(false, {
            'message': {
              'text': 'offline visit stored'
            },
            'body': {
              'data': {}
            }
          });
        } else {
          cb("offline visit not supported", false);
        }
      }
    } catch (e) {
      _self.emit("log", "visits.js", "gwSetVisit error", "error", e);

      cb(e, false);
    }
  }

  function _formatDataForgwSetVisit(data) {
    try {
      _self.emit("log", "visits.js", "_formatDataForgwSetVisit(" + data.pol_id + "," + data.id_name + "," + data.device + "," + data.idName + ")", "info", data);

      var dataToSend = {};
      dataToSend.pol_id = data.pol_id;
      dataToSend.id_name = data.pol_id_name;
      dataToSend.device = data.device;
      dataToSend.info_type = data.info_type;
      dataToSend.featureType = data.featureType;
      dataToSend.tableName = data.tableName;
      dataToSend.idName = data.idName;
      dataToSend.id = data.id;
      dataToSend.token = _token;
      dataToSend.deviceTrace = JSON.stringify(data.deviceTrace); //dynamic attributes

      for (var k in data.formData) {
        if (data.formData.hasOwnProperty(k)) {
          if (data.formData[k] != "") {
            dataToSend[k] = data.formData[k];
          } else if (data.formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      var extraDataToSend = null;

      if (data.extraData) {
        //TBR!!!
        if (data.extraData.action === "newFile") {
          var metaData = null;
          extraDataToSend = _formUtils.formatPhotoData(data.extraData.fileName, data.extraData.hash, data.id, data.deviceTrace, metaData);
        } else if (extraData.action === "deleteFile") {//extraDataToSend = {'deleteFile':{'feature':{'id':extraData.deleteFile.feature}}};
        }

        dataToSend.extradata = extraDataToSend;
      }

      if (data.photos.length > 0) {
        dataToSend.photos = JSON.stringify(data.photos);
      }

      dataToSend.what = 'gwSetVisit';
      dataToSend.expected_api_version = _expected_api_version;
      return dataToSend;
    } catch (e) {
      _self.emit("log", "visits.js", "_formatDataForgwSetVisit()", "error", e);

      return false;
    }
  } //****************************************************************
  //************             END SET VISIT             *************
  //****************************************************************
  //****************************************************************
  //************                SET VISIT              *************
  //****************************************************************


  function gwSetDelete(pol_id, id_name, info_type, featureType, tableName, idName, id, formData, device, cb) {
    try {
      _self.emit("log", "visits.js", "gwSetDelete(" + pol_id + "," + id_name + "," + info_type + "," + device + "," + idName + ")", "info");

      var retorno = {};
      var dataToSend = {};
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.device = device;
      dataToSend.info_type = info_type;
      dataToSend.featureType = featureType;
      dataToSend.tableName = tableName;
      dataToSend.idName = idName;
      dataToSend.id = id;
      dataToSend.token = _token; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'gwSetDelete';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "gwSetDelete", "success", response.data.message);

        cb(null, response.data.message);
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "gwSetDelete error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "gwSetDelete error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************             END DELETE VISIT          *************
  //****************************************************************
  //****************************************************************
  //************               VISIT MANAGER           *************
  //****************************************************************


  function gwGetVisitManager(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, device, cb) {
    try {
      _self.emit("log", "visits.js", "gwGetVisitManager(" + pol_id + "," + id_name + "," + visit_id + "," + info_type + "," + device + ")", "info", {
        formParameters: formParameters,
        formFeatureData: formFeatureData,
        formData: formData,
        deviceTrace: deviceTrace,
        extraData: extraData,
        formPagination: formPagination
      });

      var dataToSend = {};
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.device = device;
      dataToSend.info_type = info_type;
      dataToSend.formParameters = JSON.stringify(formParameters);
      dataToSend.formFeatureData = JSON.stringify(formFeatureData);
      dataToSend.formPagination = JSON.stringify(formPagination);
      dataToSend.deviceTrace = JSON.stringify(deviceTrace); //	dataToSend.extraData				= JSON.stringify(extraDataToSend);

      dataToSend.token = _token; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'gwGetVisitManager';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _processReponse(null, response.data, 'gwGetVisitManager', cb);
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "gwGetVisitManager error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "gwGetVisitManager error", "error", e);

      cb(e, false);
    }
  }

  function gw_api_setvisitmanagerend(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, device, cb) {
    try {
      _self.emit("log", "visits.js", "gw_api_setvisitmanagerend(" + pol_id + "," + id_name + "," + visit_id + "," + info_type + "," + device + ")", "info", {
        formParameters: formParameters,
        formFeatureData: formFeatureData,
        formData: formData,
        deviceTrace: deviceTrace,
        extraData: extraData,
        formPagination: formPagination
      });

      var dataToSend = {};
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.device = device;
      dataToSend.info_type = info_type;
      dataToSend.formParameters = JSON.stringify(formParameters);
      dataToSend.formFeatureData = JSON.stringify(formFeatureData);
      dataToSend.formPagination = JSON.stringify(formPagination); //	dataToSend.extraData				= JSON.stringify(extraDataToSend);

      dataToSend.token = _token; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'gw_api_setvisitmanagerend';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _processReponse(null, response.data, 'gw_api_setvisitmanagerend', cb);
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "gw_api_setvisitmanagerend error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "gw_api_setvisitmanagerend error", "error", e);

      cb(e, false);
    }
  }

  function gw_api_setvisitmanagerstart(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, device, cb) {
    try {
      _self.emit("log", "visits.js", "gw_api_setvisitmanagerstart(" + pol_id + "," + id_name + "," + visit_id + "," + info_type + "," + device + ")", "info", {
        formParameters: formParameters,
        formFeatureData: formFeatureData,
        formData: formData,
        deviceTrace: deviceTrace,
        extraData: extraData,
        formPagination: formPagination
      });

      var dataToSend = {};
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.device = device;
      dataToSend.info_type = info_type;
      dataToSend.formParameters = JSON.stringify(formParameters);
      dataToSend.formFeatureData = JSON.stringify(formFeatureData);
      dataToSend.formPagination = JSON.stringify(formPagination); //	dataToSend.extraData				= JSON.stringify(extraDataToSend);

      dataToSend.token = _token; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'gw_api_setvisitmanagerstart';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _processReponse(null, response.data, 'gw_api_setvisitmanagerstart', cb);
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "gw_api_setvisitmanagerstart error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "gw_api_setvisitmanagerstart error", "error", e);

      cb(e, false);
    }
  }

  function gwSetVisitManager(pol_id, id_name, visit_id, info_type, formParameters, formFeatureData, formPagination, formData, deviceTrace, extraData, device, cb) {
    try {
      _self.emit("log", "visits.js", "gwSetVisitManager(" + pol_id + "," + id_name + "," + visit_id + "," + info_type + "," + device + ")", "info", {
        formParameters: formParameters,
        formFeatureData: formFeatureData,
        formData: formData,
        deviceTrace: deviceTrace,
        extraData: extraData,
        formPagination: formPagination
      });

      var dataToSend = {};
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.device = device;
      dataToSend.info_type = info_type;
      dataToSend.formParameters = JSON.stringify(formParameters);
      dataToSend.formFeatureData = JSON.stringify(formFeatureData);
      dataToSend.formPagination = JSON.stringify(formPagination);
      dataToSend.deviceTrace = JSON.stringify(deviceTrace);
      dataToSend.token = _token; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'gwSetVisitManager';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _processReponse(null, response.data, 'gwSetVisitManager', cb);
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "gwSetVisitManager error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "gwSetVisitManager error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************           END VISIT MANAGER           *************
  //****************************************************************
  //****************************************************************
  //************               GET LOT                 *************
  //****************************************************************


  function gwGetLot(pol_id, id_name, info_type, featureType, tableName, idName, id, formData, device, cb) {
    try {
      _self.emit("log", "visits.js", "gwGetLot(" + pol_id + "," + id_name + "," + info_type + "," + device + "," + idName + ")", "info");

      var retorno = {};
      var dataToSend = {};
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.device = device;
      dataToSend.info_type = info_type;
      dataToSend.featureType = featureType;
      dataToSend.tableName = tableName;
      dataToSend.idName = idName;
      dataToSend.id = id;
      dataToSend.token = _token; //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'gwGetLot';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        if (response.data.status === "Accepted") {
          _self.emit("log", "visits.js", "gwGetLot", "success", response.data.message);

          _processReponse(null, response.data, 'gwGetLot', cb);
        } else {
          _self.emit("log", "visits.js", "gwGetLot", "error", response.data.message);

          cb(response.data.status, body.message);
        }
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "gwGetLot error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "gwGetLot error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************              END GET LOT              *************
  //****************************************************************
  //****************************************************************
  //************                SET LOT                *************
  //****************************************************************


  function gwSetLot(pol_id, id_name, info_type, featureType, tableName, idName, id, formData, deviceTrace, device, cb) {
    try {
      _self.emit("log", "visits.js", "gwSetLot(" + pol_id + "," + id_name + "," + info_type + "," + device + "," + idName + ")", "info", deviceTrace);

      var retorno = {};
      var dataToSend = {};
      dataToSend.pol_id = pol_id;
      dataToSend.id_name = id_name;
      dataToSend.device = device;
      dataToSend.info_type = info_type;
      dataToSend.featureType = featureType;
      dataToSend.tableName = tableName;
      dataToSend.idName = idName;
      dataToSend.id = id;
      dataToSend.token = _token;
      dataToSend.deviceTrace = JSON.stringify(deviceTrace); //dynamic attributes

      for (var k in formData) {
        if (formData.hasOwnProperty(k)) {
          if (formData[k] != "") {
            dataToSend[k] = formData[k];
          } else if (formData[k] === 0) {
            dataToSend[k] = "0";
          }
        }
      }

      dataToSend.what = 'gwSetLot';
      dataToSend.expected_api_version = _expected_api_version;
      axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
        _self.emit("log", "visits.js", "gwSetLot", "success", response.data.message);

        cb(null, response.data.message);
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "gwSetLot error", "error", error);

        cb(error, false);
      });
    } catch (e) {
      _self.emit("log", "visits.js", "gwSetLot error", "error", e);

      cb(e, false);
    }
  } //****************************************************************
  //************               END SET LOT             *************
  //****************************************************************
  //****************************************************************
  //**********            SET VEHICLE PARAMETER        *************
  //****************************************************************


  function gwSetVehicleLoad(info_type, formData, deviceTrace, device, cb) {
    return new Promise(function (resolve, reject) {
      try {
        _self.emit("log", "visits.js", "gwSetVehicleLoad(" + info_type + "," + device + ")", "info", deviceTrace);

        var retorno = {};
        var dataToSend = {};
        dataToSend.device = device;
        dataToSend.info_type = info_type;
        dataToSend.token = _token;
        dataToSend.deviceTrace = JSON.stringify(deviceTrace); //dynamic attributes

        for (var k in formData) {
          if (formData.hasOwnProperty(k)) {
            if (formData[k] != "") {
              dataToSend[k] = formData[k];
            } else if (formData[k] === 0) {
              dataToSend[k] = "0";
            }
          }
        }

        dataToSend.what = 'SET_VEHICLE_LOAD';
        dataToSend.expected_api_version = _expected_api_version;
        axios.post(_baseHref + '/ajax.sewernet.php', dataToSend).then(function (response) {
          _self.emit("log", "visits.js", "gwSetVehicleLoad", "success", response.data.message);

          if (response.data.status === "Accepted") {
            resolve(response.data.message);
          } else {
            reject(response.data.message);
          }
        })["catch"](function (error) {
          _self.emit("log", "visits.js", "gwSetVehicleLoad error", "error", error);

          reject(error);
        });
      } catch (e) {
        _self.emit("log", "visits.js", "gwSetVehicleLoad error", "error", e);

        reject(e);
      }
    });
  } //****************************************************************
  //**********        END SET VEHICLE PARAMETER        *************
  //****************************************************************
  //****************************************************************
  //*************                                    ***************
  //*************   END NEW VISITS IMPLEMENTATION    ***************
  //*************                                    ***************
  //****************************************************************
  //****************************************************************
  //*************                                    ***************
  //*************          OFFLINE VISITS            ***************
  //*************                                    ***************
  //****************************************************************


  function setUpOfflineVisit(props) {
    _self.emit("log", "visits.js", "setUpOfflineVisit", "info", props);

    return new Promise(function (resolve, reject) {
      for (var key in props) {
        _options[key] = props[key];
      }

      var response = {
        'mustDowloadData': false,
        'pending': false
      };

      if (_options.visit_offline) {
        var wsData = {};
        _options.cacheVersion = document.getElementById('cacheVersion').value;
        _options.localForageVersion = document.getElementById('localForageVersion').value;
        _options.serverInstance = document.getElementById('serverInstance').value;
        _storage = new _mapStorage["default"](_options, _events, _logger);
        _visitOffline = new _visits_offline["default"](_options, _self, _logger);

        if (_options.off_download_data) {
          var d1 = new Date();
          var d2 = new Date(_storage.getItem("bmaps_".concat(_options.project_id, "_lastDownload")));

          if (d1.getTime() > d2.getTime()) {
            response.mustDowloadData = true;
          }
        }

        var id = _storage.getItem('bmaps_photo_id');

        if (id === null) {
          _storage.setItem('bmaps_photo_id', 1);
        }

        if (_visitOffline.getOfflineVisits(_options.project_id).length > 0) {
          response.pending = true;
          resolve(response);
        } else {
          resolve(response);
        }
      } else {
        reject("Project hasn't visit offline");
      }
    });
  }

  function clearOfflineVisits(data) {
    return _visitOffline.clearOfflineVisits(data);
  } //****************************************************************
  //*************                                    ***************
  //*************         END OFFLINE VISITS         ***************
  //*************                                    ***************
  //****************************************************************
  //****************************************************************
  //*************               HELPERS              ***************
  //****************************************************************

  /***
  	_getWfsLayerIdName
  	gets layer id name from wfs
  			@scope private
  		@param layer_name <string>
  		@param table_name <string>
  			@return promise <json>
  	***/


  function _getWfsLayerIdName(layer_name, table_name) {
    return new Promise(function (resolve, reject) {
      //Get from WFS layer data
      _self.emit("log", "visits.js", "_getWfsLayerIdName(" + layer_name + "," + table_name + ")", "info");

      var id_name = null;
      layer_name = layer_name.replace(/\s+/g, '_');
      axios.get(_options.urlWMS + '?service=WFS&request=DescribeFeatureType&version=1.0.0&typename=' + layer_name).then(function (response) {
        var json = JSON.parse(parser.xml2json(response.data, {
          compact: true,
          spaces: 4
        })); //_self.emit("log","visits.js","_getWfsLayerIdName("+layer_name+","+table_name+"),"info",json);

        if (typeof json.schema != "undefined") {
          if (typeof json.schema.complexType != "undefined") {
            if (typeof json.schema.complexType.complexContent != "undefined") {
              if (typeof json.schema.complexType.complexContent.extension != "undefined") {
                if (typeof json.schema.complexType.complexContent.extension.sequence != "undefined") {
                  if (typeof json.schema.complexType.complexContent.extension.sequence.element != "undefined") {
                    //id_name MUST be first at position 1
                    id_name = json.schema.complexType.complexContent.extension.sequence.element[1]._attributes.name;
                  }
                }
              }
            }
          }
        }

        if (id_name) {
          resolve({
            'id_name': id_name,
            'table': table_name
          });
        } else {
          resolve(null);
        }
      })["catch"](function (error) {
        _self.emit("log", "visits.js", "_getWfsLayerIdName error", "error", error);

        reject(error);
      });
    });
  }

  function functionFindIndexByKeyValue(arraytosearch, key, valuetosearch) {
    for (var i = 0; i < arraytosearch.length; i++) {
      if (arraytosearch[i][key] == valuetosearch) {
        return i;
      }
    }

    return null;
  }
  /***
  	_assignValuesToCombo
  		formats data for form combo component
  			@scope private
  		@param object<object>
  			@return <json>
  	***/


  function _assignValuesToCombo(object) {
    var comboValues = Array();

    try {
      for (var i = 0; i < object.comboIds.length; i++) {
        comboValues.push({
          id: object.comboIds[i],
          name: object.comboNames[i]
        });
      }

      return comboValues;
    } catch (e) {
      _self.emit("log", "visits.js", "_assignValuesToCombo error formatting combo", "error", e.message);

      return false;
    }
  }

  function _getActiveTab(tabs) {
    if (tabs.length > 0) {
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].active) {
          return i;
          break;
        }
      }
    }
  }

  function _processReponse(err, response, caller, cb) {
    var retorno = {};

    if (err) {
      _self.emit("log", "visits.js", caller + " error on request", "error", err);

      cb(err, response);
    }

    if (response.status === "Accepted") {
      _self.emit("log", "visits.js", caller, "success", response);

      if (typeof response.message.body.form.formTabs != "undefined") {
        retorno.feature = response.message.body.feature;
        retorno.formName = response.message.body.form.formName;
        retorno.formId = response.message.body.form.formId;
        retorno.data = response.message.body.data;

        for (var i = 0; i < response.message.body.form.formTabs.length; i++) {
          if (typeof response.message.body.form.formTabs[i].fields != "undefined") {
            for (var f = 0; f < response.message.body.form.formTabs[i].fields.length; f++) {
              if (response.message.body.form.formTabs[i].fields[f]) {
                if (response.message.body.form.formTabs[i].fields[f].type === "combo") {
                  response.message.body.form.formTabs[i].fields[f].comboValues = _assignValuesToCombo(response.message.body.form.formTabs[i].fields[f]);
                }
              }
            }
          }
        }

        retorno.msgToDisplay = response.message.message;
        retorno.formTabs = response.message.body.form.formTabs; //sets active tab

        var activeTabIndex = _getActiveTab(response.message.body.form.formTabs);

        if (typeof activeTabIndex == "undefined") {
          _self.emit("log", "visits.js", caller + " NO ACTIVE TAB", "warn", response.message.body.form.formTabs);

          var dataToSend = {
            "evt": "JS ERROR",
            "msg": "FORM NO ACTIVE TAB on gwGetVisit",
            "status": "KO",
            "response": JSON.stringify(response),
            "bucket": "LOG_FR_"
          };
          axios.post(_baseHref + '/error.logger.php', dataToSend).then(function (response) {
            _self.emit("log", "visits.js", "logging error", "success", response.data.message);
          })["catch"](function (error) {
            _self.emit("log", "visits.js", "logging error", "error", error);
          });
          activeTabIndex = 0;
          response.message.body.form.formTabs[activeTabIndex].active = true;
        }

        retorno.activeTab = response.message.body.form.formTabs[activeTabIndex];
        retorno.activeTab.activeTabIndex = activeTabIndex;
        _tabs = retorno;
        cb(null, retorno);
      } else {
        cb("no fields", "no fields");
      }
    } else {
      cb(response, response.message);
    }
  } //****************************************************************
  //*************                END HELPERS         ***************
  //****************************************************************


  module.exports = Visits;
  Visits.prototype.deleteVisit = deleteVisit;
  Visits.prototype.upsertVisit = upsertVisit;
  Visits.prototype.updateVisit = updateVisit;
  Visits.prototype.getVisitsFromFeature = getVisitsFromFeature;
  Visits.prototype.getWebFormsForVisit = getWebFormsForVisit;
  Visits.prototype.getParameterIdFromParameterType = getParameterIdFromParameterType; //new implementation

  Visits.prototype.gwGetVisit = gwGetVisit;
  Visits.prototype.gwSetVisit = gwSetVisit;
  Visits.prototype.gwSetDelete = gwSetDelete;
  Visits.prototype.gwGetVisitManager = gwGetVisitManager;
  Visits.prototype.gwSetVisitManager = gwSetVisitManager;
  Visits.prototype.gw_api_setvisitmanagerstart = gw_api_setvisitmanagerstart;
  Visits.prototype.gw_api_setvisitmanagerend = gw_api_setvisitmanagerend;
  Visits.prototype.gwGetLot = gwGetLot;
  Visits.prototype.gwSetLot = gwSetLot;
  Visits.prototype.setToken = setToken;
  Visits.prototype.gwSetVehicleLoad = gwSetVehicleLoad;
  Visits.prototype.setUpOfflineVisit = setUpOfflineVisit;
  Visits.prototype.storeVisitForms = storeVisitForms;
  Visits.prototype.clearOfflineVisits = clearOfflineVisits;

  Visits.prototype.storeDownloadDate = function () {
    if (_visitOffline) {
      return _visitOffline.storeDownloadDate();
    }
  };

  Visits.prototype.dumpOfflineVisits = function (data) {
    if (_visitOffline) {
      return _visitOffline.dumpOfflineVisits(data);
    }
  };

  Visits.prototype.saveVisitPicture = function (data, preview, fileName, metaData) {
    if (_visitOffline) {
      return _visitOffline.saveVisitPicture(_formatDataForgwSetVisit(data), preview, fileName, metaData);
    }
  };

  Visits.prototype.renderVisitedSpotsLayer = function (options) {
    if (_visitOffline) {
      return _visitOffline.renderVisitedSpotsLayer(options);
    }
  };

  Visits.prototype.toggleVisitedSpots = function (options) {
    if (_visitOffline) {
      return _visitOffline.toggleVisitedSpots(options);
    }
  };

  Visits.prototype.clearVisitedSpots = function () {
    if (_visitOffline) {
      return _visitOffline.clearVisitedSpots();
    }
  };
})();

},{"../offline/mapStorage":50,"../offline/visits_offline":78,"../src/richLogger":79,"./form_utils":5,"axios":10,"events":84,"util":109,"xml-js":40}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _localforage = _interopRequireDefault(require("localforage"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _version = '2.0.0',
    _script = 'mapStorage';
var _logger = null,
    _options = null,
    _localStorageSupport = false,
    _databaseName = null,
    isInitialized = false,
    _fs = null,
    _self = null;

var MapStorage =
/*#__PURE__*/
function () {
  function MapStorage(options, events, logger) {
    _classCallCheck(this, MapStorage);

    _logger = logger;
    _self = this;

    _logger.info(_script + " v." + _version, "Loaded", options);

    if (typeof options.localForageVersion === 'undefined') {
      options.localForageVersion = '2.0';
    }

    if (typeof options.storeName === 'undefined') {
      options.storeName = 'bmaps-default';
    }

    var getUrl = window.location;
    _databaseName = getUrl.protocol + "//" + getUrl.host + "/";

    try {
      window.localStorage.getItem('testkey');
      _localStorageSupport = true;
    } catch (e) {
      _logger.warn(_script + " v." + _version, "No localStorage support");
    }

    _options = options;

    _self.initLocalForage(_options);
  }

  _createClass(MapStorage, [{
    key: "closeLocalforage",
    value: function closeLocalforage() {
      _logger.info(_script + " v." + _version, "closeLocalforage()");

      isInitialized = false;
    }
  }, {
    key: "initLocalForage",
    value: function initLocalForage(options) {
      _logger.info(_script + " v." + _version, "initLocalForage()", {
        'databaseName': _databaseName,
        'storeName': options.storeName,
        'localForageVersion': options.localForageVersion
      });

      if (!isInitialized && _localforage["default"]) {
        _localforage["default"].config({
          name: _databaseName,
          storeName: options.storeName,
          size: 50 * 1024 * 1024,
          // Only use by webSQL
          version: options.localForageVersion,
          description: 'Storage for ' + _databaseName
        });

        var requestedBytes = 1024 * 1024 * 1000; // 1GB

        navigator.webkitPersistentStorage.requestQuota(requestedBytes, function (grantedBytes) {
          _logger.success(_script + " v." + _version, "granted ".concat(grantedBytes, " bytes"));

          isInitialized = true;
        }, function (e) {
          _logger.error(_script + " v." + _version, 'Error grantig space file system', e);
        }); //file System

        window.webkitRequestFileSystem(window.PERSISTENT, 1024 * 1024 * 1024
        /*1GB*/
        , function (fs) {
          _logger.info(_script + " v." + _version, "Opened file system", fs);

          _fs = fs;
        }, function (e) {
          _logger.error(_script + " v." + _version, "Error opening file system", e);
        });
      }
    }
  }, {
    key: "localStorageSpace",
    value: function localStorageSpace() {
      _logger.info(_script + " v." + _version, "localStorageSpace()");

      return new Promise(function (resolve, reject) {
        var data = '';
        var returnInfo = {};

        for (var key in window.localStorage) {
          if (window.localStorage.hasOwnProperty(key)) {
            data += window.localStorage[key];
          }
        }

        returnInfo.localStorageUsed = data.length;
        navigator.webkitTemporaryStorage.queryUsageAndQuota(function (usedBytes, grantedBytes) {
          returnInfo.indexDbUsedMb = (usedBytes / (1024 * 1024)).toFixed(2);
          returnInfo.indexDbGrantedMb = (grantedBytes / (1024 * 1024)).toFixed(2);
          returnInfo.totalUsed = ((usedBytes + returnInfo.localStorageUsed) / (1024 * 1024)).toFixed(2);
          returnInfo.localStorageUsed = (returnInfo.localStorageUsed / (1024 * 1024)).toFixed(2);
          returnInfo.usedPercentage = _self.usedPercentage(returnInfo.indexDbUsedMb, returnInfo.indexDbGrantedMb); //console.log('we are using ', usedBytes, ' of ', grantedBytes, 'bytes');
          //console.log('we are using ', usedMb, ' of ', granteMb, 'MB');

          resolve(returnInfo);
        }, function (e) {
          console.log('Error', e);
          reject(e);
        });
      });
    } //****************************************************************
    //******************     fileSystem HELPERS      *****************
    //****************************************************************

  }, {
    key: "readFilesFromFileSystem",
    value: function readFilesFromFileSystem() {
      _logger.info(_script + " v." + _version, "readFilesFromFileSystem()");

      return new Promise(function (resolve, reject) {
        var dirReader = _fs.root.createReader();

        var entries = []; // Call the reader.readEntries() until no more results are returned.

        var readEntries = function readEntries() {
          dirReader.readEntries(function (results) {
            if (!results.length) {
              resolve(entries.sort());
            } else {
              entries = entries.concat(_self.toArray(results));
              readEntries();
            }
          }, function (e) {
            _logger.error(_script + " v." + _version, "readFilesFromFileSystem() - error", e);

            reject(e);
          });
        };

        readEntries(); // Start reading dirs.
      });
    }
  }, {
    key: "resetFileSystem",
    value: function resetFileSystem() {
      _logger.info(_script + " v." + _version, "resetFileSystem()");

      _self.readFilesFromFileSystem().then(function (response) {
        response.forEach(function (entry, i) {
          _self.removeFileFromFileSystem(entry);
        });
      })["catch"](function (e) {
        _logger.error(_script + " v." + _version, "resetFileSystem() error reading files", e);
      });
    }
  }, {
    key: "removeFileFromFileSystem",
    value: function removeFileFromFileSystem(fileName) {
      _logger.info(_script + " v." + _version, "removeFileFromFileSystem(" + fileName + ")");

      _fs.root.getFile(fileName, {}, function (fileEntry) {
        fileEntry.remove(function () {
          _logger.success(_script + " v." + _version, "removeFileFromFileSystem(" + fileName + ") - File removed");
        }, function (e) {
          _logger.error(_script + " v." + _version, "removeFileFromFileSystem(" + fileName + ") - error removing file", e);
        });
      }, function (e) {
        _logger.warn(_script + " v." + _version, "removeFileFromFileSystem(" + fileName + ") - - could not find file", e);
      });
    } //****************************************************************
    //***************    END fileSystem HELPERS      *****************
    //****************************************************************
    //****************************************************************
    //******************     indexedDB HELPERS      ******************
    //****************************************************************

  }, {
    key: "clearIndexedDb",
    value: function clearIndexedDb() {
      _logger.info(_script + " v." + _version, "clearIndexedDb()", _databaseName);

      var req = indexedDB.deleteDatabase(_databaseName);

      req.onsuccess = function () {
        _logger.success(_script + " v." + _version, "Deleted database successfully");
      };

      req.onerror = function () {
        _logger.error(_script + " v." + _version, "Couldn't delete database", e);
      };

      req.onblocked = function () {
        _logger.error(_script + " v." + _version, "Couldn't delete database due to the operation being blocke");
      };
    } //****************************************************************
    //****************    END indexedDB HELPERS      *****************
    //****************************************************************
    //****************************************************************
    //***************     LocalStorage HELPERS      ******************
    //****************************************************************

  }, {
    key: "clearLocalStorage",
    value: function clearLocalStorage() {
      _logger.info(_script + " v." + _version, "clearLocalStorage()");

      return window.localStorage.clear();
    }
  }, {
    key: "getItem",
    value: function getItem(key) {
      if (_localStorageSupport) {
        return window.localStorage.getItem(key);
      }
    }
  }, {
    key: "setItem",
    value: function setItem(key, data) {
      if (_localStorageSupport) {
        return window.localStorage.setItem(key, data);
      }
    }
  }, {
    key: "removeItem",
    value: function removeItem(key) {
      if (_localStorageSupport) {
        return window.localStorage.removeItem(key);
      }
    } //****************************************************************
    //***************    END LocalStorage HELPERS      ***************
    //****************************************************************
    //****************************************************************
    //***************      LocalForage HELPERS         ***************
    //****************************************************************

  }, {
    key: "setTile",
    value: function setTile(key, dataURI) {
      _logger.info(_script + " v." + _version, "setTile(".concat(key, ")"), dataURI);

      return new Promise(function (resolve, reject) {
        if (isInitialized) {
          _localforage["default"].setItem(key, dataURI).then(function (value) {
            _logger.success(_script + " v." + _version, "setTile(".concat(key, ")"));

            resolve();
          })["catch"](function (err) {
            _logger.error(_script + " v." + _version, "setTile(".concat(key, ")"), err);

            reject(err);
          });
        } else {
          _logger.error(_script + " v." + _version, "setTile(".concat(key, ")"), 'localForage not initiated');

          reject('localForage not initiated');
        }
      });
    }
  }, {
    key: "getTile",
    value: function getTile(key) {
      _logger.info(_script + " v." + _version, "getTile(".concat(key, ")"), isInitialized);

      return new Promise(function (resolve, reject) {
        if (isInitialized) {
          _localforage["default"].getItem(key, function (err, compressedDataURI) {
            if (err) {
              _logger.error(_script + " v." + _version, "getTile(".concat(key, ")"), err);

              reject(err);
              return;
            }

            _logger.success(_script + " v." + _version, "getTile(".concat(key, ")"), compressedDataURI);

            resolve(_self.decompress(compressedDataURI));
          });
        } else {
          _logger.error(_script + " v." + _version, "setTile(".concat(key, ")"), 'localForage not initiated');

          reject('localForage not initiated');
        }
      });
    }
  }, {
    key: "removeTile",
    value: function removeTile(key) {
      _logger.info(_script + " v." + _version, "removeTile(".concat(key, ")"));

      return _localforage["default"].removeItem(key);
    } //****************************************************************
    //***************     END LocalForage HELPERS      ***************
    //****************************************************************
    //****************************************************************
    //***************     CacheStorage HELPERS      ******************
    //****************************************************************

  }, {
    key: "clearCacheStorage",
    value: function clearCacheStorage(version) {
      _logger.info(_script + " v." + _version, "clearCacheStorage(" + version + ")");

      caches.open(version).then(function (cache) {
        cache.keys().then(function (keys) {
          keys.forEach(function (request, index, array) {
            cache["delete"](request);
          });
        });
      });
    } //****************************************************************
    //***************    END CacheStorage HELPERS    *****************
    //****************************************************************
    //****************************************************************
    //***********************       HELPERS     **********************
    //****************************************************************

  }, {
    key: "usedPercentage",
    value: function usedPercentage(used, total) {
      return (100 * used / total).toFixed(2);
    }
  }, {
    key: "compress",
    value: function compress(s) {
      if (!s) {
        return s;
      }

      var i,
          l,
          out = '';

      if (s.length % 2 !== 0) {
        s += ' ';
      }

      for (i = 0, l = s.length; i < l; i += 2) {
        out += String.fromCharCode(s.charCodeAt(i) * 256 + s.charCodeAt(i + 1));
      }

      return String.fromCharCode(9731) + out;
    }
  }, {
    key: "decompress",
    value: function decompress(s) {
      if (!s) {
        return s;
      }

      var i,
          l,
          n,
          m,
          out = '';

      if (s.charCodeAt(0) !== 9731) {
        return s;
      }

      for (i = 1, l = s.length; i < l; i++) {
        n = s.charCodeAt(i);
        m = Math.floor(n / 256);
        out += String.fromCharCode(m, n % 256);
      }

      return out;
    }
  }, {
    key: "toArray",
    value: function toArray(list) {
      return Array.prototype.slice.call(list || [], 0);
    } //****************************************************************
    //***********************    END HELPERS    **********************
    //****************************************************************

  }]);

  return MapStorage;
}();

exports["default"] = MapStorage;

},{"localforage":77}],51:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./lib/axios":53,"dup":10}],52:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var settle = require('./../core/settle');

var buildURL = require('./../helpers/buildURL');

var parseHeaders = require('./../helpers/parseHeaders');

var isURLSameOrigin = require('./../helpers/isURLSameOrigin');

var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies'); // Add xsrf header


      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (config.withCredentials) {
      request.withCredentials = true;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

},{"../core/createError":59,"./../core/settle":63,"./../helpers/buildURL":67,"./../helpers/cookies":69,"./../helpers/isURLSameOrigin":71,"./../helpers/parseHeaders":73,"./../utils":75}],53:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./cancel/Cancel":54,"./cancel/CancelToken":55,"./cancel/isCancel":56,"./core/Axios":57,"./core/mergeConfig":62,"./defaults":65,"./helpers/bind":66,"./helpers/spread":74,"./utils":75,"dup":12}],54:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],55:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./Cancel":54,"dup":14}],56:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],57:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var buildURL = require('../helpers/buildURL');

var InterceptorManager = require('./InterceptorManager');

var dispatchRequest = require('./dispatchRequest');

var mergeConfig = require('./mergeConfig');
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);
  config.method = config.method ? config.method.toLowerCase() : 'get'; // Hook up interceptors middleware

  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

},{"../helpers/buildURL":67,"./../utils":75,"./InterceptorManager":58,"./dispatchRequest":60,"./mergeConfig":62}],58:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./../utils":75,"dup":17}],59:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./enhanceError":61,"dup":19}],60:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var transformData = require('./transformData');

var isCancel = require('../cancel/isCancel');

var defaults = require('../defaults');

var isAbsoluteURL = require('./../helpers/isAbsoluteURL');

var combineURLs = require('./../helpers/combineURLs');
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Support baseURL config

  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  } // Ensure headers exist


  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":56,"../defaults":65,"./../helpers/combineURLs":68,"./../helpers/isAbsoluteURL":70,"./../utils":75,"./transformData":64}],61:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],62:[function(require,module,exports){
'use strict';

var utils = require('../utils');
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });
  utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  utils.forEach(['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath'], function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  return config;
};

},{"../utils":75}],63:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./createError":59,"dup":23}],64:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./../utils":75,"dup":24}],65:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./utils');

var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter; // Only Node.JS has a process variable that is of [[Class]] process

  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

}).call(this,require('_process'))
},{"./adapters/http":52,"./adapters/xhr":52,"./helpers/normalizeHeaderName":72,"./utils":75,"_process":90}],66:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],67:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./../utils":75,"dup":27}],68:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],69:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./../utils":75,"dup":29}],70:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],71:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./../utils":75,"dup":31}],72:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"../utils":75,"dup":32}],73:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./../utils":75,"dup":33}],74:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],75:[function(require,module,exports){
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var bind = require('./helpers/bind');

var isBuffer = require('is-buffer');
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && _typeof(val) === 'object';
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function deepMerge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (_typeof(val) === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":66,"is-buffer":76}],76:[function(require,module,exports){
"use strict";

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
module.exports = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
};

},{}],77:[function(require,module,exports){
(function (global){
"use strict";

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/*!
    localForage -- Offline Storage, Improved
    Version 1.7.3
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof2(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;

    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }

    g.localforage = f();
  }
})(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }

        var l = n[o] = {
          exports: {}
        };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }

      return n[o].exports;
    }

    var i = typeof require == "function" && require;

    for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }

    return s;
  }({
    1: [function (_dereq_, module, exports) {
      (function (global) {
        'use strict';

        var Mutation = global.MutationObserver || global.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick);
            var element = global.document.createTextNode('');
            observer.observe(element, {
              characterData: true
            });

            scheduleDrain = function scheduleDrain() {
              element.data = called = ++called % 2;
            };
          } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
            var channel = new global.MessageChannel();
            channel.port1.onmessage = nextTick;

            scheduleDrain = function scheduleDrain() {
              channel.port2.postMessage(0);
            };
          } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
            scheduleDrain = function scheduleDrain() {
              // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
              // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
              var scriptEl = global.document.createElement('script');

              scriptEl.onreadystatechange = function () {
                nextTick();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };

              global.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function scheduleDrain() {
              setTimeout(nextTick, 0);
            };
          }
        }
        var draining;
        var queue = []; //named nextTick for less confusing stack traces

        function nextTick() {
          draining = true;
          var i, oldQueue;
          var len = queue.length;

          while (len) {
            oldQueue = queue;
            queue = [];
            i = -1;

            while (++i < len) {
              oldQueue[i]();
            }

            len = queue.length;
          }

          draining = false;
        }

        module.exports = immediate;

        function immediate(task) {
          if (queue.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    2: [function (_dereq_, module, exports) {
      'use strict';

      var immediate = _dereq_(1);
      /* istanbul ignore next */


      function INTERNAL() {}

      var handlers = {};
      var REJECTED = ['REJECTED'];
      var FULFILLED = ['FULFILLED'];
      var PENDING = ['PENDING'];
      module.exports = Promise;

      function Promise(resolver) {
        if (typeof resolver !== 'function') {
          throw new TypeError('resolver must be a function');
        }

        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;

        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }

      Promise.prototype["catch"] = function (onRejected) {
        return this.then(null, onRejected);
      };

      Promise.prototype.then = function (onFulfilled, onRejected) {
        if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
          return this;
        }

        var promise = new this.constructor(INTERNAL);

        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }

        return promise;
      };

      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;

        if (typeof onFulfilled === 'function') {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }

        if (typeof onRejected === 'function') {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }

      QueueItem.prototype.callFulfilled = function (value) {
        handlers.resolve(this.promise, value);
      };

      QueueItem.prototype.otherCallFulfilled = function (value) {
        unwrap(this.promise, this.onFulfilled, value);
      };

      QueueItem.prototype.callRejected = function (value) {
        handlers.reject(this.promise, value);
      };

      QueueItem.prototype.otherCallRejected = function (value) {
        unwrap(this.promise, this.onRejected, value);
      };

      function unwrap(promise, func, value) {
        immediate(function () {
          var returnValue;

          try {
            returnValue = func(value);
          } catch (e) {
            return handlers.reject(promise, e);
          }

          if (returnValue === promise) {
            handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
          } else {
            handlers.resolve(promise, returnValue);
          }
        });
      }

      handlers.resolve = function (self, value) {
        var result = tryCatch(getThen, value);

        if (result.status === 'error') {
          return handlers.reject(self, result.value);
        }

        var thenable = result.value;

        if (thenable) {
          safelyResolveThenable(self, thenable);
        } else {
          self.state = FULFILLED;
          self.outcome = value;
          var i = -1;
          var len = self.queue.length;

          while (++i < len) {
            self.queue[i].callFulfilled(value);
          }
        }

        return self;
      };

      handlers.reject = function (self, error) {
        self.state = REJECTED;
        self.outcome = error;
        var i = -1;
        var len = self.queue.length;

        while (++i < len) {
          self.queue[i].callRejected(error);
        }

        return self;
      };

      function getThen(obj) {
        // Make sure we only access the accessor once as required by the spec
        var then = obj && obj.then;

        if (obj && (_typeof2(obj) === 'object' || typeof obj === 'function') && typeof then === 'function') {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }

      function safelyResolveThenable(self, thenable) {
        // Either fulfill, reject or reject with error
        var called = false;

        function onError(value) {
          if (called) {
            return;
          }

          called = true;
          handlers.reject(self, value);
        }

        function onSuccess(value) {
          if (called) {
            return;
          }

          called = true;
          handlers.resolve(self, value);
        }

        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }

        var result = tryCatch(tryToUnwrap);

        if (result.status === 'error') {
          onError(result.value);
        }
      }

      function tryCatch(func, value) {
        var out = {};

        try {
          out.value = func(value);
          out.status = 'success';
        } catch (e) {
          out.status = 'error';
          out.value = e;
        }

        return out;
      }

      Promise.resolve = resolve;

      function resolve(value) {
        if (value instanceof this) {
          return value;
        }

        return handlers.resolve(new this(INTERNAL), value);
      }

      Promise.reject = reject;

      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers.reject(promise, reason);
      }

      Promise.all = all;

      function all(iterable) {
        var self = this;

        if (Object.prototype.toString.call(iterable) !== '[object Array]') {
          return this.reject(new TypeError('must be an array'));
        }

        var len = iterable.length;
        var called = false;

        if (!len) {
          return this.resolve([]);
        }

        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);

        while (++i < len) {
          allResolver(iterable[i], i);
        }

        return promise;

        function allResolver(value, i) {
          self.resolve(value).then(resolveFromAll, function (error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });

          function resolveFromAll(outValue) {
            values[i] = outValue;

            if (++resolved === len && !called) {
              called = true;
              handlers.resolve(promise, values);
            }
          }
        }
      }

      Promise.race = race;

      function race(iterable) {
        var self = this;

        if (Object.prototype.toString.call(iterable) !== '[object Array]') {
          return this.reject(new TypeError('must be an array'));
        }

        var len = iterable.length;
        var called = false;

        if (!len) {
          return this.resolve([]);
        }

        var i = -1;
        var promise = new this(INTERNAL);

        while (++i < len) {
          resolver(iterable[i]);
        }

        return promise;

        function resolver(value) {
          self.resolve(value).then(function (response) {
            if (!called) {
              called = true;
              handlers.resolve(promise, response);
            }
          }, function (error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
        }
      }
    }, {
      "1": 1
    }],
    3: [function (_dereq_, module, exports) {
      (function (global) {
        'use strict';

        if (typeof global.Promise !== 'function') {
          global.Promise = _dereq_(2);
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "2": 2
    }],
    4: [function (_dereq_, module, exports) {
      'use strict';

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function getIDB() {
        /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
        try {
          if (typeof indexedDB !== 'undefined') {
            return indexedDB;
          }

          if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
          }

          if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
          }

          if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
          }

          if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
          }
        } catch (e) {
          return;
        }
      }

      var idb = getIDB();

      function isIndexedDBValid() {
        try {
          // Initialize IndexedDB; fall back to vendor-prefixed versions
          // if needed.
          if (!idb) {
            return false;
          } // We mimic PouchDB here;
          //
          // We test for openDatabase because IE Mobile identifies itself
          // as Safari. Oh the lulz...


          var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1; // Safari <10.1 does not meet our requirements for IDB support (#5572)
          // since Safari 10.1 shipped with fetch, we can use that to detect it

          return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== 'undefined';
        } catch (e) {
          return false;
        }
      } // Abstracts constructing a Blob object, so it also works in older
      // browsers that don't support the native Blob constructor. (i.e.
      // old QtWebKit versions, at least).
      // Abstracts constructing a Blob object, so it also works in older
      // browsers that don't support the native Blob constructor. (i.e.
      // old QtWebKit versions, at least).


      function createBlob(parts, properties) {
        /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
        parts = parts || [];
        properties = properties || {};

        try {
          return new Blob(parts, properties);
        } catch (e) {
          if (e.name !== 'TypeError') {
            throw e;
          }

          var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();

          for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
          }

          return builder.getBlob(properties.type);
        }
      } // This is CommonJS because lie is an external dependency, so Rollup
      // can just ignore it.


      if (typeof Promise === 'undefined') {
        // In the "nopromises" build this will just throw if you don't have
        // a global promise object, but it would throw anyway later.
        _dereq_(3);
      }

      var Promise$1 = Promise;

      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function (result) {
            callback(null, result);
          }, function (error) {
            callback(error);
          });
        }
      }

      function executeTwoCallbacks(promise, callback, errorCallback) {
        if (typeof callback === 'function') {
          promise.then(callback);
        }

        if (typeof errorCallback === 'function') {
          promise["catch"](errorCallback);
        }
      }

      function normalizeKey(key) {
        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
          console.warn(key + ' used as a key, but it is not a string.');
          key = String(key);
        }

        return key;
      }

      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
          return arguments[arguments.length - 1];
        }
      } // Some code originally from async_storage.js in
      // [Gaia](https://github.com/mozilla-b2g/gaia).


      var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString = Object.prototype.toString; // Transaction Modes

      var READ_ONLY = 'readonly';
      var READ_WRITE = 'readwrite'; // Transform a binary string to an array buffer, because otherwise
      // weird stuff happens when you try to work with the binary string directly.
      // It is known.
      // From http://stackoverflow.com/questions/14967647/ (continues on next line)
      // encode-decode-image-with-base64-breaks-image (2013-04-21)

      function _binStringToArrayBuffer(bin) {
        var length = bin.length;
        var buf = new ArrayBuffer(length);
        var arr = new Uint8Array(buf);

        for (var i = 0; i < length; i++) {
          arr[i] = bin.charCodeAt(i);
        }

        return buf;
      } //
      // Blobs are not supported in all versions of IndexedDB, notably
      // Chrome <37 and Android <5. In those versions, storing a blob will throw.
      //
      // Various other blob bugs exist in Chrome v37-42 (inclusive).
      // Detecting them is expensive and confusing to users, and Chrome 37-42
      // is at very low usage worldwide, so we do a hacky userAgent check instead.
      //
      // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
      // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
      // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
      //
      // Code borrowed from PouchDB. See:
      // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
      //


      function _checkBlobSupportWithoutCaching(idb) {
        return new Promise$1(function (resolve) {
          var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob(['']);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

          txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
          };

          txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//); // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx

            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function () {
          return false; // error, so assume unsupported
        });
      }

      function _checkBlobSupport(idb) {
        if (typeof supportsBlobs === 'boolean') {
          return Promise$1.resolve(supportsBlobs);
        }

        return _checkBlobSupportWithoutCaching(idb).then(function (value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }

      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name]; // Create a deferred object representing the current database operation.

        var deferredOperation = {};
        deferredOperation.promise = new Promise$1(function (resolve, reject) {
          deferredOperation.resolve = resolve;
          deferredOperation.reject = reject;
        }); // Enqueue the deferred operation.

        dbContext.deferredOperations.push(deferredOperation); // Chain its promise to the database readiness.

        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
          });
        }
      }

      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name]; // Dequeue a deferred operation.

        var deferredOperation = dbContext.deferredOperations.pop(); // Resolve its promise (which is part of the database readiness
        // chain of promises).

        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }

      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name]; // Dequeue a deferred operation.

        var deferredOperation = dbContext.deferredOperations.pop(); // Reject its promise (which is part of the database readiness
        // chain of promises).

        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }

      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$1(function (resolve, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);

              dbInfo.db.close();
            } else {
              return resolve(dbInfo.db);
            }
          }

          var dbArgs = [dbInfo.name];

          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }

          var openreq = idb.open.apply(idb, dbArgs);

          if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
              var db = openreq.result;

              try {
                db.createObjectStore(dbInfo.storeName);

                if (e.oldVersion <= 1) {
                  // Added when support for blob shims was added
                  db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === 'ConstraintError') {
                  console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }

          openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
          };

          openreq.onsuccess = function () {
            resolve(openreq.result);

            _advanceReadiness(dbInfo);
          };
        });
      }

      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }

      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }

      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }

        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;

        if (isDowngrade) {
          // If the version is not the default one
          // then warn for impossible downgrade.
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
          } // Align the versions to prevent errors.


          dbInfo.version = dbInfo.db.version;
        }

        if (isUpgrade || isNewStore) {
          // If the store is new then increment the version (if needed).
          // This will trigger an "upgradeneeded" event which is required
          // for creating a store.
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;

            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }

          return true;
        }

        return false;
      } // encode a blob for indexeddb engines that don't support blobs


      function _encodeBlob(blob) {
        return new Promise$1(function (resolve, reject) {
          var reader = new FileReader();
          reader.onerror = reject;

          reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
              __local_forage_encoded_blob: true,
              data: base64,
              type: blob.type
            });
          };

          reader.readAsBinaryString(blob);
        });
      } // decode an encoded blob


      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));

        return createBlob([arrayBuff], {
          type: encodedBlob.type
        });
      } // is this one of our fancy encoded blobs?


      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      } // Specialize the default `ready()` function by making it dependent
      // on the current database operations. Thus, the driver will be actually
      // ready when it's been initialized (default) *and* there are no pending
      // operations on the database (initiated by some other instances).


      function _fullyReady(callback) {
        var self = this;

        var promise = self._initReady().then(function () {
          var dbContext = dbContexts[self._dbInfo.name];

          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
      } // Try to establish a new db connection to replace the
      // current one which is broken (i.e. experiencing
      // InvalidStateError while creating a transaction).


      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);

        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;

        for (var i = 0; i < forages.length; i++) {
          var forage = forages[i];

          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();

            forage._dbInfo.db = null;
          }
        }

        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function (db) {
          dbInfo.db = db;

          if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
          }

          return db;
        }).then(function (db) {
          // store the latest db reference
          // in case the db was upgraded
          dbInfo.db = dbContext.db = db;

          for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
          }
        })["catch"](function (err) {
          _rejectReadiness(dbInfo, err);

          throw err;
        });
      } // FF doesn't like Promises (micro-tasks) and IDDB store operations,
      // so we have to do it with callbacks


      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === undefined) {
          retries = 1;
        }

        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
              if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                // increase the db version, to create the new ObjectStore
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                } // Reopen the database for upgrading.


                return _getUpgradedConnection(dbInfo);
              }
            }).then(function () {
              return _tryReconnect(dbInfo).then(function () {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }

          callback(err);
        }
      }

      function createDbContext() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      } // Open the IndexedDB database (automatically creates one if one didn't
      // previously exist), using any options set in the config.


      function _initStorage(options) {
        var self = this;
        var dbInfo = {
          db: null
        };

        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        } // Get the current context of the database;


        var dbContext = dbContexts[dbInfo.name]; // ...or create a new context.

        if (!dbContext) {
          dbContext = createDbContext(); // Register the new context in the global container.

          dbContexts[dbInfo.name] = dbContext;
        } // Register itself as a running localForage in the current context.


        dbContext.forages.push(self); // Replace the default `ready()` function with the specialized one.

        if (!self._initReady) {
          self._initReady = self.ready;
          self.ready = _fullyReady;
        } // Create an array of initialization states of the related localForages.


        var initPromises = [];

        function ignoreErrors() {
          // Don't handle errors here,
          // just makes sure related localForages aren't pending.
          return Promise$1.resolve();
        }

        for (var j = 0; j < dbContext.forages.length; j++) {
          var forage = dbContext.forages[j];

          if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        } // Take a snapshot of the related localForages.


        var forages = dbContext.forages.slice(0); // Initialize the connection process only when
        // all the related localForages aren't pending.

        return Promise$1.all(initPromises).then(function () {
          dbInfo.db = dbContext.db; // Get the connection or open a new one without upgrade.

          return _getOriginalConnection(dbInfo);
        }).then(function (db) {
          dbInfo.db = db;

          if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
          }

          return db;
        }).then(function (db) {
          dbInfo.db = dbContext.db = db;
          self._dbInfo = dbInfo; // Share the final connection amongst related localForages.

          for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];

            if (forage !== self) {
              // Self is already up-to-date.
              forage._dbInfo.db = dbInfo.db;
              forage._dbInfo.version = dbInfo.version;
            }
          }
        });
      }

      function getItem(key, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName);
                var req = store.get(key);

                req.onsuccess = function () {
                  var value = req.result;

                  if (value === undefined) {
                    value = null;
                  }

                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }

                  resolve(value);
                };

                req.onerror = function () {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      } // Iterate over all items stored in database.


      function iterate(iterator, callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName);
                var req = store.openCursor();
                var iterationNumber = 1;

                req.onsuccess = function () {
                  var cursor = req.result;

                  if (cursor) {
                    var value = cursor.value;

                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }

                    var result = iterator(value, cursor.key, iterationNumber++); // when the iterator callback retuns any
                    // (non-`undefined`) value, then we stop
                    // the iteration immediately

                    if (result !== void 0) {
                      resolve(result);
                    } else {
                      cursor["continue"]();
                    }
                  } else {
                    resolve();
                  }
                };

                req.onerror = function () {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function setItem(key, value, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = new Promise$1(function (resolve, reject) {
          var dbInfo;
          self.ready().then(function () {
            dbInfo = self._dbInfo;

            if (toString.call(value) === '[object Blob]') {
              return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                if (blobSupport) {
                  return value;
                }

                return _encodeBlob(value);
              });
            }

            return value;
          }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName); // The reason we don't _save_ null is because IE 10 does
                // not support saving the `null` type in IndexedDB. How
                // ironic, given the bug below!
                // See: https://github.com/mozilla/localForage/issues/161

                if (value === null) {
                  value = undefined;
                }

                var req = store.put(value, key);

                transaction.oncomplete = function () {
                  // Cast to undefined so the value passed to
                  // callback/promise is the same as what one would get out
                  // of `getItem()` later. This leads to some weirdness
                  // (setItem('foo', undefined) will return `null`), but
                  // it's not my fault localStorage is our baseline and that
                  // it's weird.
                  if (value === undefined) {
                    value = null;
                  }

                  resolve(value);
                };

                transaction.onabort = transaction.onerror = function () {
                  var err = req.error ? req.error : req.transaction.error;
                  reject(err);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function removeItem(key, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName); // We use a Grunt task to make this safe for IE and some
                // versions of Android (including those used by Cordova).
                // Normally IE won't like `.delete()` and will insist on
                // using `['delete']()`, but we have a build step that
                // fixes this for us now.

                var req = store["delete"](key);

                transaction.oncomplete = function () {
                  resolve();
                };

                transaction.onerror = function () {
                  reject(req.error);
                }; // The request will be also be aborted if we've exceeded our storage
                // space.


                transaction.onabort = function () {
                  var err = req.error ? req.error : req.transaction.error;
                  reject(err);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function clear(callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName);
                var req = store.clear();

                transaction.oncomplete = function () {
                  resolve();
                };

                transaction.onabort = transaction.onerror = function () {
                  var err = req.error ? req.error : req.transaction.error;
                  reject(err);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function length(callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName);
                var req = store.count();

                req.onsuccess = function () {
                  resolve(req.result);
                };

                req.onerror = function () {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function key(n, callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          if (n < 0) {
            resolve(null);
            return;
          }

          self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName);
                var advanced = false;
                var req = store.openCursor();

                req.onsuccess = function () {
                  var cursor = req.result;

                  if (!cursor) {
                    // this means there weren't enough keys
                    resolve(null);
                    return;
                  }

                  if (n === 0) {
                    // We have the first key, return it if that's what they
                    // wanted.
                    resolve(cursor.key);
                  } else {
                    if (!advanced) {
                      // Otherwise, ask the cursor to skip ahead n
                      // records.
                      advanced = true;
                      cursor.advance(n);
                    } else {
                      // When we get here, we've got the nth key.
                      resolve(cursor.key);
                    }
                  }
                };

                req.onerror = function () {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function keys(callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
              if (err) {
                return reject(err);
              }

              try {
                var store = transaction.objectStore(self._dbInfo.storeName);
                var req = store.openCursor();
                var keys = [];

                req.onsuccess = function () {
                  var cursor = req.result;

                  if (!cursor) {
                    resolve(keys);
                    return;
                  }

                  keys.push(cursor.key);
                  cursor["continue"]();
                };

                req.onerror = function () {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== 'function' && options || {};

        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }

        var self = this;
        var promise;

        if (!options.name) {
          promise = Promise$1.reject('Invalid arguments');
        } else {
          var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;
          var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;

            for (var i = 0; i < forages.length; i++) {
              forages[i]._dbInfo.db = db;
            }

            return db;
          });

          if (!options.storeName) {
            promise = dbPromise.then(function (db) {
              _deferReadiness(options);

              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();

              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
              }

              var dropDBPromise = new Promise$1(function (resolve, reject) {
                var req = idb.deleteDatabase(options.name);

                req.onerror = req.onblocked = function (err) {
                  var db = req.result;

                  if (db) {
                    db.close();
                  }

                  reject(err);
                };

                req.onsuccess = function () {
                  var db = req.result;

                  if (db) {
                    db.close();
                  }

                  resolve(db);
                };
              });
              return dropDBPromise.then(function (db) {
                dbContext.db = db;

                for (var i = 0; i < forages.length; i++) {
                  var _forage = forages[i];

                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function (err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                throw err;
              });
            });
          } else {
            promise = dbPromise.then(function (db) {
              if (!db.objectStoreNames.contains(options.storeName)) {
                return;
              }

              var newVersion = db.version + 1;

              _deferReadiness(options);

              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();

              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }

              var dropObjectPromise = new Promise$1(function (resolve, reject) {
                var req = idb.open(options.name, newVersion);

                req.onerror = function (err) {
                  var db = req.result;
                  db.close();
                  reject(err);
                };

                req.onupgradeneeded = function () {
                  var db = req.result;
                  db.deleteObjectStore(options.storeName);
                };

                req.onsuccess = function () {
                  var db = req.result;
                  db.close();
                  resolve(db);
                };
              });
              return dropObjectPromise.then(function (db) {
                dbContext.db = db;

                for (var j = 0; j < forages.length; j++) {
                  var _forage2 = forages[j];
                  _forage2._dbInfo.db = db;

                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function (err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                throw err;
              });
            });
          }
        }

        executeCallback(promise, callback);
        return promise;
      }

      var asyncStorage = {
        _driver: 'asyncStorage',
        _initStorage: _initStorage,
        _support: isIndexedDBValid(),
        iterate: iterate,
        getItem: getItem,
        setItem: setItem,
        removeItem: removeItem,
        clear: clear,
        length: length,
        key: key,
        keys: keys,
        dropInstance: dropInstance
      };

      function isWebSQLValid() {
        return typeof openDatabase === 'function';
      } // Sadly, the best way to save binary data in WebSQL/localStorage is serializing
      // it to Base64, so this is how we store it to prevent very strange errors with less
      // verbose ways of binary <-> string data storage.


      var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      var BLOB_TYPE_PREFIX = '~~local_forage_type~';
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = '__lfsc__:';
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length; // OMG the serializations!

      var TYPE_ARRAYBUFFER = 'arbf';
      var TYPE_BLOB = 'blob';
      var TYPE_INT8ARRAY = 'si08';
      var TYPE_UINT8ARRAY = 'ui08';
      var TYPE_UINT8CLAMPEDARRAY = 'uic8';
      var TYPE_INT16ARRAY = 'si16';
      var TYPE_INT32ARRAY = 'si32';
      var TYPE_UINT16ARRAY = 'ur16';
      var TYPE_UINT32ARRAY = 'ui32';
      var TYPE_FLOAT32ARRAY = 'fl32';
      var TYPE_FLOAT64ARRAY = 'fl64';
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$1 = Object.prototype.toString;

      function stringToBuffer(serializedString) {
        // Fill the string into a ArrayBuffer.
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i;
        var p = 0;
        var encoded1, encoded2, encoded3, encoded4;

        if (serializedString[serializedString.length - 1] === '=') {
          bufferLength--;

          if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
          }
        }

        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);

        for (i = 0; i < len; i += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
          /*jslint bitwise: true */

          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }

        return buffer;
      } // Converts a buffer to a string to store, serialized, in the backend
      // storage library.


      function bufferToString(buffer) {
        // base64-arraybuffer
        var bytes = new Uint8Array(buffer);
        var base64String = '';
        var i;

        for (i = 0; i < bytes.length; i += 3) {
          /*jslint bitwise: true */
          base64String += BASE_CHARS[bytes[i] >> 2];
          base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
          base64String += BASE_CHARS[bytes[i + 2] & 63];
        }

        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + '=';
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + '==';
        }

        return base64String;
      } // Serialize a value, afterwards executing a callback (which usually
      // instructs the `setItem()` callback/promise to be executed). This is how
      // we store binary data with localStorage.


      function serialize(value, callback) {
        var valueType = '';

        if (value) {
          valueType = toString$1.call(value);
        } // Cannot use `value instanceof ArrayBuffer` or such here, as these
        // checks fail when running the tests using casper.js...
        //
        // TODO: See why those tests fail and use a better solution.


        if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
          // Convert binary arrays to a string and prefix the string with
          // a special marker.
          var buffer;
          var marker = SERIALIZED_MARKER;

          if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error('Failed to get type for BinaryArray'));
            }
          }

          callback(marker + bufferToString(buffer));
        } else if (valueType === '[object Blob]') {
          // Conver the blob to a binaryArray and then to a string.
          var fileReader = new FileReader();

          fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };

          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e);
          }
        }
      } // Deserialize data we've inserted into a value column/field. We place
      // special markers into our strings to mark them as encoded; this isn't
      // as nice as a meta field, but it's the only sane thing we can do whilst
      // keeping localStorage support intact.
      //
      // Oftentimes this will just deserialize JSON content, but if we have a
      // special marker (SERIALIZED_MARKER, defined above), we will extract
      // some kind of arraybuffer/binary data/typed array out of the string.


      function deserialize(value) {
        // If we haven't marked this string as being specially serialized (i.e.
        // something other than serialized JSON), we can just return it and be
        // done with it.
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        } // The following code deals with deserializing some kind of Blob or
        // TypedArray. First we separate out the type of data we're dealing
        // with from the data itself.


        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType; // Backwards-compatible blob type serialization strategy.
        // DBs created with older versions of localForage will simply not have the blob type.

        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }

        var buffer = stringToBuffer(serializedString); // Return the right type based on the code/type set during
        // serialization.

        switch (type) {
          case TYPE_ARRAYBUFFER:
            return buffer;

          case TYPE_BLOB:
            return createBlob([buffer], {
              type: blobType
            });

          case TYPE_INT8ARRAY:
            return new Int8Array(buffer);

          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);

          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);

          case TYPE_INT16ARRAY:
            return new Int16Array(buffer);

          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);

          case TYPE_INT32ARRAY:
            return new Int32Array(buffer);

          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);

          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);

          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);

          default:
            throw new Error('Unkown type: ' + type);
        }
      }

      var localforageSerializer = {
        serialize: serialize,
        deserialize: deserialize,
        stringToBuffer: stringToBuffer,
        bufferToString: bufferToString
      };
      /*
       * Includes code from:
       *
       * base64-arraybuffer
       * https://github.com/niklasvh/base64-arraybuffer
       *
       * Copyright (c) 2012 Niklas von Hertzen
       * Licensed under the MIT license.
       */

      function createDbTable(t, dbInfo, callback, errorCallback) {
        t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
      } // Open the WebSQL database (automatically creates one if one didn't
      // previously exist), using any options set in the config.


      function _initStorage$1(options) {
        var self = this;
        var dbInfo = {
          db: null
        };

        if (options) {
          for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
          }
        }

        var dbInfoPromise = new Promise$1(function (resolve, reject) {
          // Open the database; the openDatabase API will automatically
          // create it for us if it doesn't exist.
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e) {
            return reject(e);
          } // Create our key/value table if it doesn't exist.


          dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
              self._dbInfo = dbInfo;
              resolve();
            }, function (t, error) {
              reject(error);
            });
          }, reject);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }

      function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
        t.executeSql(sqlStatement, args, callback, function (t, error) {
          if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
              if (!results.rows.length) {
                // if the table is missing (was deleted)
                // re-create it table and retry
                createDbTable(t, dbInfo, function () {
                  t.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t, error);
              }
            }, errorCallback);
          } else {
            errorCallback(t, error);
          }
        }, errorCallback);
      }

      function getItem$1(key, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
              tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                var result = results.rows.length ? results.rows.item(0).value : null; // Check to see if this is serialized content we need to
                // unpack.

                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }

                resolve(result);
              }, function (t, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function iterate$1(iterator, callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
              tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                var rows = results.rows;
                var length = rows.length;

                for (var i = 0; i < length; i++) {
                  var item = rows.item(i);
                  var result = item.value; // Check to see if this is serialized content
                  // we need to unpack.

                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }

                  result = iterator(result, item.key, i + 1); // void(0) prevents problems with redefinition
                  // of `undefined`.

                  if (result !== void 0) {
                    resolve(result);
                    return;
                  }
                }

                resolve();
              }, function (t, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function _setItem(key, value, callback, retriesLeft) {
        var self = this;
        key = normalizeKey(key);
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
              value = null;
            } // Save the original value to pass to the callback.


            var originalValue = value;
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
              if (error) {
                reject(error);
              } else {
                dbInfo.db.transaction(function (t) {
                  tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                    resolve(originalValue);
                  }, function (t, error) {
                    reject(error);
                  });
                }, function (sqlError) {
                  // The transaction failed; check
                  // to see if it's a quota error.
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    // We reject the callback outright for now, but
                    // it's worth trying to re-run the transaction.
                    // Even if the user accepts the prompt to use
                    // more storage on Safari, this error will
                    // be called.
                    //
                    // Try to re-run the transaction.
                    if (retriesLeft > 0) {
                      resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                      return;
                    }

                    reject(sqlError);
                  }
                });
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function setItem$1(key, value, callback) {
        return _setItem.apply(this, [key, value, callback, 1]);
      }

      function removeItem$1(key, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
              tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                resolve();
              }, function (t, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      } // Deletes every item in the table.
      // TODO: Find out if this resets the AUTO_INCREMENT number.


      function clear$1(callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
              tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                resolve();
              }, function (t, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      } // Does a simple `COUNT(key)` to get the number of items stored in
      // localForage.


      function length$1(callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
              // Ahhh, SQL makes this one soooooo easy.
              tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                var result = results.rows.item(0).c;
                resolve(result);
              }, function (t, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      } // Return the key located at key index X; essentially gets the key from a
      // `WHERE id = ?`. This is the most efficient way I can think to implement
      // this rarely-used (in my experience) part of the API, but it can seem
      // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
      // the ID of each key will change every time it's updated. Perhaps a stored
      // procedure for the `setItem()` SQL would solve this problem?
      // TODO: Don't change ID on `setItem()`.


      function key$1(n, callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
              tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve(result);
              }, function (t, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }

      function keys$1(callback) {
        var self = this;
        var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
              tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                var keys = [];

                for (var i = 0; i < results.rows.length; i++) {
                  keys.push(results.rows.item(i).key);
                }

                resolve(keys);
              }, function (t, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      } // https://www.w3.org/TR/webdatabase/#databases
      // > There is no way to enumerate or delete the databases available for an origin from this API.


      function getAllStoreNames(db) {
        return new Promise$1(function (resolve, reject) {
          db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
              var storeNames = [];

              for (var i = 0; i < results.rows.length; i++) {
                storeNames.push(results.rows.item(i).name);
              }

              resolve({
                db: db,
                storeNames: storeNames
              });
            }, function (t, error) {
              reject(error);
            });
          }, function (sqlError) {
            reject(sqlError);
          });
        });
      }

      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== 'function' && options || {};

        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }

        var self = this;
        var promise;

        if (!options.name) {
          promise = Promise$1.reject('Invalid arguments');
        } else {
          promise = new Promise$1(function (resolve) {
            var db;

            if (options.name === currentConfig.name) {
              // use the db reference of the current instance
              db = self._dbInfo.db;
            } else {
              db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
              // drop all database tables
              resolve(getAllStoreNames(db));
            } else {
              resolve({
                db: db,
                storeNames: [options.storeName]
              });
            }
          }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
              operationInfo.db.transaction(function (t) {
                function dropTable(storeName) {
                  return new Promise$1(function (resolve, reject) {
                    t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                      resolve();
                    }, function (t, error) {
                      reject(error);
                    });
                  });
                }

                var operations = [];

                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                  operations.push(dropTable(operationInfo.storeNames[i]));
                }

                Promise$1.all(operations).then(function () {
                  resolve();
                })["catch"](function (e) {
                  reject(e);
                });
              }, function (sqlError) {
                reject(sqlError);
              });
            });
          });
        }

        executeCallback(promise, callback);
        return promise;
      }

      var webSQLStorage = {
        _driver: 'webSQLStorage',
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$1,
        length: length$1,
        key: key$1,
        keys: keys$1,
        dropInstance: dropInstance$1
      };

      function isLocalStorageValid() {
        try {
          return typeof localStorage !== 'undefined' && 'setItem' in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch (e) {
          return false;
        }
      }

      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + '/';

        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + '/';
        }

        return keyPrefix;
      } // Check if localStorage throws when saving an item


      function checkIfLocalStorageThrows() {
        var localStorageTestKey = '_localforage_support_test';

        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e) {
          return true;
        }
      } // Check if localStorage is usable and allows to save an item
      // This method checks if localStorage is usable in Safari Private Browsing
      // mode, or in any other case where the available quota for localStorage
      // is 0 and there wasn't any saved items yet.


      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      } // Config the localStorage backend, using options set in the config.


      function _initStorage$2(options) {
        var self = this;
        var dbInfo = {};

        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }

        dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

        if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
        }

        self._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$1.resolve();
      } // Remove all keys from the datastore, effectively destroying all data in
      // the app's key/value store!


      function clear$2(callback) {
        var self = this;
        var promise = self.ready().then(function () {
          var keyPrefix = self._dbInfo.keyPrefix;

          for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key);
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      } // Retrieve an item from the store. Unlike the original async_storage
      // library in Gaia, we don't modify return values at all. If a key's value
      // is `undefined`, we pass that value to the callback function.


      function getItem$2(key, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key); // If a result was found, parse it from the serialized
          // string into a JS object. If result isn't truthy, the key
          // is likely undefined and we'll pass it straight to the
          // callback.

          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }

          return result;
        });
        executeCallback(promise, callback);
        return promise;
      } // Iterate over all items in the store.


      function iterate$2(iterator, callback) {
        var self = this;
        var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length = localStorage.length; // We use a dedicated iterator instead of the `i` variable below
          // so other keys we fetch in localStorage aren't counted in
          // the `iterationNumber` argument passed to the `iterate()`
          // callback.
          //
          // See: github.com/mozilla/localForage/pull/435#discussion_r38061530

          var iterationNumber = 1;

          for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) !== 0) {
              continue;
            }

            var value = localStorage.getItem(key); // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.

            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      } // Same as localStorage's key() method, except takes a callback.


      function key$2(n, callback) {
        var self = this;
        var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var result;

          try {
            result = localStorage.key(n);
          } catch (error) {
            result = null;
          } // Remove the prefix from the key, if a key is found.


          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }

          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }

      function keys$2(callback) {
        var self = this;
        var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var length = localStorage.length;
          var keys = [];

          for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);

            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }

          return keys;
        });
        executeCallback(promise, callback);
        return promise;
      } // Supply the number of keys in the datastore to the callback function.


      function length$2(callback) {
        var self = this;
        var promise = self.keys().then(function (keys) {
          return keys.length;
        });
        executeCallback(promise, callback);
        return promise;
      } // Remove an item from the store, nice and simple.


      function removeItem$2(key, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key);
        });
        executeCallback(promise, callback);
        return promise;
      } // Set a key's value and run an optional callback once the value is set.
      // Unlike Gaia's implementation, the callback function is passed the value,
      // in case you want to operate on that value only after you're sure it
      // saved, or something like that.


      function setItem$2(key, value, callback) {
        var self = this;
        key = normalizeKey(key);
        var promise = self.ready().then(function () {
          // Convert undefined values to null.
          // https://github.com/mozilla/localForage/pull/42
          if (value === undefined) {
            value = null;
          } // Save the original value to pass to the callback.


          var originalValue = value;
          return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
              if (error) {
                reject(error);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key, value);
                  resolve(originalValue);
                } catch (e) {
                  // localStorage capacity exceeded.
                  // TODO: Make this a specific error/event.
                  if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                    reject(e);
                  }

                  reject(e);
                }
              }
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }

      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== 'function' && options || {};

        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }

        var self = this;
        var promise;

        if (!options.name) {
          promise = Promise$1.reject('Invalid arguments');
        } else {
          promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
              resolve(options.name + '/');
            } else {
              resolve(_getKeyPrefix(options, self._defaultConfig));
            }
          }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key = localStorage.key(i);

              if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
              }
            }
          });
        }

        executeCallback(promise, callback);
        return promise;
      }

      var localStorageWrapper = {
        _driver: 'localStorageWrapper',
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$2,
        dropInstance: dropInstance$2
      };

      var sameValue = function sameValue(x, y) {
        return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
      };

      var includes = function includes(array, searchElement) {
        var len = array.length;
        var i = 0;

        while (i < len) {
          if (sameValue(array[i], searchElement)) {
            return true;
          }

          i++;
        }

        return false;
      };

      var isArray = Array.isArray || function (arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
      }; // Drivers are stored here when `defineDriver()` is called.
      // They are shared across all instances of localForage.


      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ['dropInstance'];
      var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: '',
        driver: DefaultDriverOrder.slice(),
        name: 'localforage',
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: 'keyvaluepairs',
        version: 1.0
      };

      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function () {
          var _args = arguments;
          return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }

      function extend() {
        for (var i = 1; i < arguments.length; i++) {
          var arg = arguments[i];

          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }

        return arguments[0];
      }

      var LocalForage = function () {
        function LocalForage(options) {
          _classCallCheck(this, LocalForage);

          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;

              if (!DefinedDrivers[driverName]) {
                // we don't need to wait for the promise,
                // since the default drivers can be defined
                // in a blocking manner
                this.defineDriver(driver);
              }
            }
          }

          this._defaultConfig = extend({}, DefaultConfig);
          this._config = extend({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;

          this._wrapLibraryMethodsWithReady();

          this.setDriver(this._config.driver)["catch"](function () {});
        } // Set any config values for localForage; can be called anytime before
        // the first API call (e.g. `getItem`, `setItem`).
        // We loop through options so we don't overwrite existing config
        // values.


        LocalForage.prototype.config = function config(options) {
          // If the options argument is an object, we use it to set values.
          // Otherwise, we return either a specified config value or all
          // config values.
          if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
              return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
              if (i === 'storeName') {
                options[i] = options[i].replace(/\W/g, '_');
              }

              if (i === 'version' && typeof options[i] !== 'number') {
                return new Error('Database version must be a number.');
              }

              this._config[i] = options[i];
            } // after all config options are set and
            // the driver option is used, try setting it


            if ('driver' in options && options.driver) {
              return this.setDriver(this._config.driver);
            }

            return true;
          } else if (typeof options === 'string') {
            return this._config[options];
          } else {
            return this._config;
          }
        }; // Used to define a custom driver, shared across all instances of
        // localForage.


        LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function (resolve, reject) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver'); // A driver name should be defined and not overlap with the
              // library-defined, default drivers.

              if (!driverObject._driver) {
                reject(complianceError);
                return;
              }

              var driverMethods = LibraryMethods.concat('_initStorage');

              for (var i = 0, len = driverMethods.length; i < len; i++) {
                var driverMethodName = driverMethods[i]; // when the property is there,
                // it should be a method even when optional

                var isRequired = !includes(OptionalDriverMethods, driverMethodName);

                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                  reject(complianceError);
                  return;
                }
              }

              var configureMissingMethods = function configureMissingMethods() {
                var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                  return function () {
                    var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                    var promise = Promise$1.reject(error);
                    executeCallback(promise, arguments[arguments.length - 1]);
                    return promise;
                  };
                };

                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];

                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };

              configureMissingMethods();

              var setDriverSupport = function setDriverSupport(support) {
                if (DefinedDrivers[driverName]) {
                  console.info('Redefining LocalForage driver: ' + driverName);
                }

                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support; // don't use a then, so that we can define
                // drivers that have simple _support methods
                // in a blocking manner

                resolve();
              };

              if ('_support' in driverObject) {
                if (driverObject._support && typeof driverObject._support === 'function') {
                  driverObject._support().then(setDriverSupport, reject);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e) {
              reject(e);
            }
          });
          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
        };

        LocalForage.prototype.driver = function driver() {
          return this._driver || null;
        };

        LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };

        LocalForage.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };

        LocalForage.prototype.ready = function ready(callback) {
          var self = this;

          var promise = self._driverSet.then(function () {
            if (self._ready === null) {
              self._ready = self._initDriver();
            }

            return self._ready;
          });

          executeTwoCallbacks(promise, callback, callback);
          return promise;
        };

        LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self = this;

          if (!isArray(drivers)) {
            drivers = [drivers];
          }

          var supportedDrivers = this._getSupportedDrivers(drivers);

          function setDriverToConfig() {
            self._config.driver = self.driver();
          }

          function extendSelfWithDriver(driver) {
            self._extend(driver);

            setDriverToConfig();
            self._ready = self._initStorage(self._config);
            return self._ready;
          }

          function initDriver(supportedDrivers) {
            return function () {
              var currentDriverIndex = 0;

              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers.length) {
                  var driverName = supportedDrivers[currentDriverIndex];
                  currentDriverIndex++;
                  self._dbInfo = null;
                  self._ready = null;
                  return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }

                setDriverToConfig();
                var error = new Error('No available storage method found.');
                self._driverSet = Promise$1.reject(error);
                return self._driverSet;
              }

              return driverPromiseLoop();
            };
          } // There might be a driver initialization in progress
          // so wait for it to finish in order to avoid a possible
          // race condition to set _dbInfo


          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
          }) : Promise$1.resolve();
          this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;
            return self.getDriver(driverName).then(function (driver) {
              self._driver = driver._driver;
              setDriverToConfig();

              self._wrapLibraryMethodsWithReady();

              self._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };

        LocalForage.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };

        LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend(this, libraryMethodsAndProperties);
        };

        LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];

          for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];

            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }

          return supportedDrivers;
        };

        LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          // Add a stub for each driver API method that delays the call to the
          // corresponding driver method until localForage is ready. These stubs
          // will be replaced by the driver methods as soon as the driver is
          // loaded, so there is no performance impact.
          for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
          }
        };

        LocalForage.prototype.createInstance = function createInstance(options) {
          return new LocalForage(options);
        };

        return LocalForage;
      }(); // The actual localForage object that we expose as a module or via a
      // global. It's extended by pulling in one of our other libraries.


      var localforage_js = new LocalForage();
      module.exports = localforage_js;
    }, {
      "3": 3
    }]
  }, {}, [4])(4);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _richLogger = _interopRequireDefault(require("../src/richLogger"));

var _mapStorage = _interopRequireDefault(require("./mapStorage"));

var _axios = _interopRequireDefault(require("axios"));

var _form_utils = _interopRequireDefault(require("../forms/form_utils"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _self = null,
    _version = '1.0.0',
    _events = null,
    _logger = null; //modules

var _storage = null;
var _formUtils = null; //form utils module
//offline layer for visit spots

var offlineVisitSpotsSource = null,
    offlineVisitSpotsLayer = null,
    map = null,
    visitedfeautures = [],
    geom_colors = {
  visited_spots_stroke_color: 'rgba(0, 0, 0, 0.99)',
  visited_spots_fill_color: 'rgba(0, 0, 0, 0.0)',
  visited_spots_shape: 'square',
  visited_spot_radius: 12
};

var VisitsOffline =
/*#__PURE__*/
function () {
  function VisitsOffline(options, events, logger) {
    _classCallCheck(this, VisitsOffline);

    if (typeof options === 'undefined') {
      throw new TypeError('no data');
    }

    if (typeof options.baseHref === 'undefined') {
      throw new TypeError('no options baseHref');
    }

    if (typeof events === 'undefined') {
      throw new TypeError('no events');
    }

    _events = events;

    if (typeof logger === 'undefined') {
      throw new TypeError('no logger');
    }

    _logger = logger;

    if (typeof options.storage === 'undefined') {
      _storage = new _mapStorage["default"](options, _events, _logger);
    } else {
      _storage = options.storage;
    }

    _self = this;
    _self._fileName = 'visits_offline.js';
    _self.options = options;
    _formUtils = new _form_utils["default"](_self.options, events, _logger);

    _logger.info(_self._fileName, "Module loaded v.".concat(_version), options);
  }

  _createClass(VisitsOffline, [{
    key: "getOfflineVisits",
    value: function getOfflineVisits(project_id) {
      _logger.info(_self._fileName, "getOfflineVisits(".concat(project_id, ")"));

      try {
        var ofVisits = _storage.getItem("bmaps_".concat(project_id, "_visits"));

        if (ofVisits) {
          return JSON.parse(ofVisits);
        } else {
          return [];
        }
      } catch (e) {
        _logger.error(_self._fileName, 'getOfflineVisits', e);

        return [];
      }
    }
    /**
      storeVisitedSpot
        stores a visited spot
         @param project_id <int>
        @param geomString <string> geom string
      **/

  }, {
    key: "storeVisitedSpot",
    value: function storeVisitedSpot(project_id, geomString) {
      _logger.info(_self._fileName, "storeVisitedSpot(".concat(project_id, ")"), geomString);

      if (geomString) {
        if (_self.options.visited_spots_layer) {
          if (typeof ol == "undefined" || !ol) return false;

          var ofVisits_spots = _self.getVisitedSpots(project_id);

          if (ofVisits_spots) {
            var coordinates = null,
                format = new ol.format.WKT({}),
                geom2Hightlight = format.readGeometry(geomString, {
              dataProjection: _self.options.epsg,
              featureProjection: _self.options.epsg
            });

            if (geom2Hightlight.getType() === "Point" || geom2Hightlight.getType() === "point") {} //check this with linestring and polygons!!!


            coordinates = geom2Hightlight.getCoordinates();
            ofVisits_spots.push(coordinates); //add feauture to map

            _self._renderFeauture(coordinates);
          } else {
            ofVisits_spots = [data];
          }

          _storage.setItem("bmaps_".concat(project_id, "_visited_spots"), JSON.stringify(ofVisits_spots));
        }
      }
    }
    /**
      getVisitedSpots
        returns visited spots array
         @param project_id <int>
        @returns <array>
     **/

  }, {
    key: "getVisitedSpots",
    value: function getVisitedSpots(project_id) {
      _logger.info(_self._fileName, "getVisitedSpots(".concat(project_id, ")"));

      try {
        if (_self.options.visited_spots_layer) {
          var ofVisits = _storage.getItem("bmaps_".concat(project_id, "_visited_spots"));

          if (ofVisits) {
            return JSON.parse(ofVisits);
          } else {
            return [];
          }
        } else {
          return [];
        }
      } catch (e) {
        _logger.error(_self._fileName, 'getVisitedSpots', e);

        return [];
      }
    }
    /**
      clearVisitedSpots
        clears visited spots
         @param project_id <int>
     **/

  }, {
    key: "clearVisitedSpots",
    value: function clearVisitedSpots() {
      _logger.info(_self._fileName, "clearVisitedSpots()");

      try {
        _storage.removeItem("bmaps_".concat(_self.options.project_id, "_visited_spots"));

        if (offlineVisitSpotsSource) {
          offlineVisitSpotsSource.clear();
        }
      } catch (e) {
        _logger.error(_self._fileName, 'clearVisitedSpots', e);

        return false;
      }
    }
    /**
      renderVisitedSpotsLayer
        creates a vector layer and vector source for display visited spots feautures
         @param options <JSON>
                  map:  ol.Map instance
         @returns <boolean>
     **/

  }, {
    key: "renderVisitedSpotsLayer",
    value: function renderVisitedSpotsLayer(options) {
      _logger.info(_self._fileName, "renderVisitedSpotsLayer()", options);

      try {
        if (_self.options.visited_spots_layer) {
          if (!ol) return false;
          map = options.map;

          if (typeof options.geom_colors.visited_spots_stroke_color != "undefined" && options.geom_colors.visited_spots_stroke_color != '') {
            geom_colors.visited_spots_stroke_color = options.geom_colors.visited_spots_stroke_color;
          }

          if (typeof options.geom_colors.visited_spots_fill_color != "undefined" && options.geom_colors.visited_spots_fill_color != '') {
            geom_colors.visited_spots_fill_color = options.geom_colors.visited_spots_fill_color;
          }

          if (typeof options.geom_colors.visited_spots_shape != "undefined" && options.geom_colors.visited_spots_shape != '') {
            geom_colors.visited_spots_shape = options.geom_colors.visited_spots_shape;
          }

          if (typeof options.geom_colors.visited_spot_radius != "undefined" && options.geom_colors.visited_spot_radius != '') {
            geom_colors.visited_spot_radius = options.geom_colors.visited_spot_radius;
          }

          if (typeof map != "undefined" && ol) {
            offlineVisitSpotsSource = new ol.source.Vector({});
            offlineVisitSpotsLayer = new ol.layer.Vector({
              source: offlineVisitSpotsSource
            });
            map.addLayer(offlineVisitSpotsLayer); //render offline spots

            _self._renderOfflineVisitSpots();

            return true;
          } else {
            return false;
          }
        } else {
          return false;
        }
      } catch (e) {
        _logger.error(_self._fileName, "renderVisitedSpotsLayer()", e);
      }
    }
    /**
      _renderOfflineVisitSpots
        renders offline visited spots
     **/

  }, {
    key: "_renderOfflineVisitSpots",
    value: function _renderOfflineVisitSpots() {
      _logger.info(_self._fileName, "_renderOfflineVisitSpots()");

      if (_self.options.visited_spots_layer) {
        if (offlineVisitSpotsSource) {
          offlineVisitSpotsSource.clear();
        }

        var ofVisits_spots = _self.getVisitedSpots(_self.options.project_id);

        if (ofVisits_spots) {
          for (var i = 0; i < ofVisits_spots.length; i++) {
            _self._renderFeauture(ofVisits_spots[i]);
          }
        }
      }
    }
    /**
      _renderFeauture
        adds a feauture to vector source of visited spots
         @param coordinates <array> x,y
         @returns <boolean>
     **/

  }, {
    key: "_renderFeauture",
    value: function _renderFeauture(coordinates) {
      _logger.info(_self._fileName, '_renderFeauture() coordinates()', {
        'coordinates': coordinates
      });

      try {
        if (_self.options.visited_spots_layer) {
          if (typeof ol == "undefined" || !ol) return false;
          var newFeature = new ol.Feature(),
              featureGeom = null;

          if (geom_colors.visited_spots_shape === "square") {
            featureGeom = new ol.style.RegularShape({
              fill: new ol.style.Fill({
                color: geom_colors.visited_spots_fill_color
              }),
              stroke: new ol.style.Stroke({
                color: geom_colors.visited_spots_stroke_color,
                width: 1
              }),
              points: 4,
              radius: geom_colors.visited_spot_radius,
              angle: Math.PI / 4
            });
          } else {
            featureGeom = new ol.style.Circle({
              radius: geom_colors.visited_spot_radius,
              fill: new ol.style.Fill({
                color: geom_colors.visited_spots_fill_color
              }),
              stroke: new ol.style.Stroke({
                color: geom_colors.visited_spots_stroke_color,
                width: 1
              })
            });
          }

          newFeature.setStyle(new ol.style.Style({
            image: featureGeom
          }));
          newFeature.setGeometry(new ol.geom.Point(coordinates));

          if (offlineVisitSpotsSource) {
            offlineVisitSpotsSource.addFeature(newFeature);
          }
        }

        return true;
      } catch (e) {
        _logger.error(_self._fileName, '_renderFeauture()', e);

        return false;
      }
    }
    /**
      toggleVisitedSpots
        displays/hides visited spots layer
     **/

  }, {
    key: "toggleVisitedSpots",
    value: function toggleVisitedSpots(options) {
      return new Promise(function (resolve, reject) {
        if (offlineVisitSpotsLayer) {
          _logger.info(_self._fileName, 'toggleVisitedSpots', {
            'displayed': offlineVisitSpotsLayer.getVisible()
          });

          if (offlineVisitSpotsLayer.getVisible()) {
            offlineVisitSpotsLayer.setVisible(false);
            resolve(false);
          } else {
            offlineVisitSpotsLayer.setVisible(true);
            resolve(true);
          }
        } else {
          _logger.info(_self._fileName, 'toggleVisitedSpots', options);

          _self.renderVisitedSpotsLayer(options);

          resolve(true);
        }
      });
    }
  }, {
    key: "clearOfflineVisits",
    value: function clearOfflineVisits(data) {
      _logger.info(_self._fileName, 'clearOfflineVisits', data);

      return new Promise(function (resolve, reject) {
        try {
          _storage.removeItem("bmaps_".concat(data.project_id, "_visits")); //clear photos


          _self._ClearProjectPhotos(data.project_id);

          resolve();
        } catch (e) {
          _logger.error(_self._fileName, 'clearOfflineVisits', e);

          reject(e);
        }
      });
    }
  }, {
    key: "storeOfflineVisit",
    value: function storeOfflineVisit(project_id, data) {
      _logger.info(_self._fileName, "storeOfflineVisit(".concat(project_id, ")"), data);

      var ofVisits = _self.getOfflineVisits(project_id);

      if (ofVisits) {
        ofVisits.push(data);

        if (_self.options.visited_spots_layer && typeof data.selectedGeomString != "undefined") {
          //add feauture to map and store on visited spots layers
          _self.storeVisitedSpot(project_id, data.selectedGeomString);
        }
      } else {
        ofVisits = [data];
      }

      _storage.setItem("bmaps_".concat(project_id, "_visits"), JSON.stringify(ofVisits));
    }
  }, {
    key: "dumpOfflineVisits",
    value: function dumpOfflineVisits(data) {
      _logger.info(_self._fileName, 'dumpOfflineVisits', data);

      return new Promise(function (resolve, reject) {
        try {
          _self.options.project_id = data.project_id;

          var ofVisits = _self.getOfflineVisits(_self.options.project_id);

          if (ofVisits.length > 0) {
            if (ofVisits[0].type === 'data') {
              _self._insertNextVisit(ofVisits[0]);
            } else {
              _self._uploadPhoto(ofVisits[0]);
            }
          } else {
            _events.emit("offlineEvent", "dumpData", {
              "text": "no visits to dump"
            });
          }

          resolve();
        } catch (e) {
          _logger.error(_self._fileName, 'dumpOfflineVisits', e);

          reject(e);
        }
      });
    }
  }, {
    key: "_insertNextVisit",
    value: function _insertNextVisit(data) {
      _logger.info(_self._fileName, '_insertNextVisit', data);

      if (data.type === 'file') {
        _self._uploadPhoto(data);
      } else {
        _events.emit("offlineEvent", "dumpData", {
          "text": "InsertNextVisit"
        });

        data.dataToSend.token = _self.options.token;

        _axios["default"].post(_self.options.baseHref + '/ajax.sewernet.php', data.dataToSend).then(function (response) {
          _logger.success(_self._fileName, '_insertNextVisit response', response.data.message);

          if (response.data.status === "Accepted") {
            _self._updatePhotosVisitId(data.pol_id, data.id_name, response.data.message.body.feature.id);

            _self._udpateVisitIdAndRemoveVisit(data.pol_id, data.id_name, response.data.message.body.feature.id);
          } else {
            _logger.error(_self._fileName, '_insertNextVisit error', response.data.message);

            _events.emit("offlineEvent", "dumpData", {
              "text": "UploadVisitsError"
            });
          }
        })["catch"](function (error) {
          _logger.error(_self._fileName, '_insertNextVisit error', error);

          _events.emit("offlineEvent", "dumpData", {
            "text": "UploadVisitsError"
          });
        });
      }
    }
  }, {
    key: "_udpateVisitIdAndRemoveVisit",
    value: function _udpateVisitIdAndRemoveVisit(pol_id, id_name, visit_id) {
      _logger.info(_self._fileName, '_udpateVisitIdAndRemoveVisit', {
        'pol_id': pol_id,
        'id_name': id_name,
        'visit_id': visit_id
      });

      var ofVisits = _self.getOfflineVisits(_self.options.project_id); //remove first element


      ofVisits.shift();

      if (ofVisits.length > 0) {
        var _loop = function _loop(i) {
          if (ofVisits[i].pol_id == pol_id && ofVisits[i].id_name == id_name) {
            ofVisits[i].dataToSend.id = visit_id;

            _storage.setItem("bmaps_".concat(_self.options.project_id, "_visits"), JSON.stringify(ofVisits)); //reredend offline visited spots with updated data


            _self._renderOfflineVisitSpots();

            setTimeout(function () {
              _self._insertNextVisit(ofVisits[i]);
            }, 500);
            return "break";
          } else {
            _storage.setItem("bmaps_".concat(_self.options.project_id, "_visits"), JSON.stringify(ofVisits));

            setTimeout(function () {
              _self._insertNextVisit(ofVisits[i]);
            }, 500);
          }
        };

        for (var i = 0; i < ofVisits.length; i++) {
          var _ret = _loop(i);

          if (_ret === "break") break;
        }
      } else {
        _events.emit("offlineEvent", "dumpData", {
          "text": "UploadVisitsDone"
        }); //clear visited spots


        _self.clearVisitedSpots(); //clear project photos


        _self._ClearProjectPhotos(_self.options.project_id);

        _storage.setItem("bmaps_".concat(_self.options.project_id, "_visits"), JSON.stringify(ofVisits));
      }
    } //****************************************************************
    //***********************       PHOTOS      **********************
    //****************************************************************

    /*
      saveVisitPicture
        stores locally a photo
         @param data {JSON}
        @param preview {binary}
        @param fileName {string}
         @return {promise}
    */

  }, {
    key: "saveVisitPicture",
    value: function saveVisitPicture(data, preview, fileName, metaData) {
      _logger.info(_self._fileName, 'saveVisitPicture', {
        'pol_id': data.pol_id,
        'id_name': data.id_name,
        'fileName': fileName,
        'metaData': metaData
      });

      return new Promise(function (resolve, reject) {
        var temporalPhotoId = _self._addPhotoId();

        var photos = _self._getPhotos(_self.options.project_id);

        var newElement = {
          'photo_id': temporalPhotoId,
          'pol_id': data.pol_id,
          'id_name': data.id_name,
          'visit_id': null,
          'hash': null,
          'metaData': metaData
        };
        photos.push(newElement);

        _storage.setItem("bmaps_".concat(_self.options.project_id, "_photos"), JSON.stringify(photos));

        var returnData = {
          'status': "Accepted",
          'message': newElement,
          'code': 200
        };

        var compressedData = _storage.compress(preview);

        _storage.setTile("photo_".concat(temporalPhotoId), compressedData).then(function () {
          _logger.success(_self._fileName, "Photo photo_".concat(temporalPhotoId, " successfully stored localForage"));

          _self.storeOfflineVisit(_self.options.project_id, {
            'pol_id': data.pol_id,
            'id_name': data.id_name,
            'tableName': data.tableName,
            'dataToSend': data,
            'type': 'file',
            'temporalId': temporalPhotoId,
            'fileName': fileName
          });

          resolve("Photo photo_".concat(temporalPhotoId, " successfully stored localForage"));
        })["catch"](function (e) {
          _logger.error(_self._fileName, "Photo photo_".concat(temporalPhotoId, " error storing localForage"), e);

          reject(e);
        });
      });
    }
    /*
      _uploadPhoto
        upload locally stored photo
         @param data {JSON}
         @return {promise}
    */

  }, {
    key: "_uploadPhoto",
    value: function _uploadPhoto(data) {
      _logger.info(_self._fileName, '_uploadPhoto()', data);

      return new Promise(function (resolve, reject) {
        var photo = _self._getPhoto(data.temporalId);

        var metaData = null;

        if (photo.hash != null) {
          if (typeof photo.metaData != 'undefined') {
            metaData = photo.metaData;
          } //foto already uploaded


          var photosToSend = _formUtils.formatPhotoData(data.fileName, photo.hash, data.dataToSend.id, JSON.parse(data.dataToSend.deviceTrace), metaData);

          data.dataToSend.photos = JSON.stringify([photosToSend]);
          data.type = 'data';

          _self._insertNextVisit(data);

          resolve(photo.hash);
          return;
        } //1. Upload photo


        _storage.getTile("photo_".concat(data.temporalId)).then(function (binary) {
          if (binary === null) {
            _logger.error(_self._fileName, '_uploadPhoto() error, couldn\'t read photo data', binary);

            reject("Foto data is empty");
            return false;
          }

          var data2send = new FormData();
          data2send.append('what', "UPLOAD_PHOTO");
          data2send.append('token', _self.options.token);
          data2send.append('file', binary);
          data2send.append('metaData', metaData);

          _axios["default"].post(_self.options.baseHref + '/ajax.addPhoto.php', data2send).then(function (response) {
            _logger.success(_self._fileName, '_uploadPhoto response', response.data.message);

            if (response.data.status === "Accepted") {
              //2. Delete local photo
              _self._removePhoto("".concat(data.temporalId)).then(function () {
                //3. update local foto dara with online hash (in case dump fails we'll need it)
                _self._updateOfflinePhoto(data.temporalId, response.data.message.photo_id); //4. create visit with file


                var photosToSend = _formUtils.formatPhotoData(data.fileName, response.data.message.photo_id, data.dataToSend.id, JSON.parse(data.dataToSend.deviceTrace), metaData);

                data.dataToSend.photos = JSON.stringify([photosToSend]);
                data.type = 'data';

                _self._insertNextVisit(data);

                resolve(response.data.message);
              })["catch"](function (e) {
                reject(e);
              });
            } else {
              _logger.error(_self._fileName, '_uploadPhoto error', response.data.message);

              reject(response.data.message);
            }
          })["catch"](function (error) {
            _logger.error(_self._fileName, '_uploadPhoto error', error);

            reject(e);
          });
        })["catch"](function (e) {
          _logger.error(_self._fileName, '_uploadPhoto error getting stored image', e);

          reject(e);
        });
      });
    }
  }, {
    key: "_updateOfflinePhoto",
    value: function _updateOfflinePhoto(photo_id, hash) {
      _logger.info(_self._fileName, "_updateOfflinePhoto()", {
        'photo_id': photo_id,
        'hash': hash
      });

      var photos_list = JSON.parse(_storage.getItem("bmaps_".concat(_self.options.project_id, "_photos")));

      if (photos_list != null) {
        for (var i = 0; i < photos_list.length; i++) {
          if (photos_list[i].photo_id === photo_id) {
            photos_list[i].hash = hash;
            break;
          }
        }

        _storage.setItem("bmaps_".concat(_self.options.project_id, "_photos"), JSON.stringify(photos_list));
      }
    }
  }, {
    key: "_getPhotos",
    value: function _getPhotos(project_id) {
      _logger.info(_self._fileName, "_getPhotos(".concat(project_id, ")"));

      var photos_list = JSON.parse(_storage.getItem("bmaps_".concat(_self.options.project_id, "_photos")));

      if (photos_list === null) {
        photos_list = Array();
      }

      return photos_list;
    }
  }, {
    key: "_getPhoto",
    value: function _getPhoto(photo_id) {
      var photos_list = JSON.parse(_storage.getItem("bmaps_".concat(_self.options.project_id, "_photos")));

      if (photos_list != null) {
        for (var i = 0; i < photos_list.length; i++) {
          if (photos_list[i].photo_id === photo_id) {
            return photos_list[i];
          }
        }
      }
    }
  }, {
    key: "_addPhotoId",
    value: function _addPhotoId() {
      _logger.info(_self._fileName, '_addPhotoId()');

      var id = _self._getPhotoId();

      if (id === null) {
        id = 1;
      } else {
        id = id + 1;
      }

      _storage.setItem('bmaps_photo_id', parseInt(id));

      return id;
    }
  }, {
    key: "_getPhotoId",
    value: function _getPhotoId() {
      _logger.info(_self._fileName, '_getPhotoId()');

      var id = _storage.getItem('bmaps_photo_id');

      if (id === null) {
        _logger.info(_self._fileName, '_getPhotoId() not id stored()');

        _storage.setItem('bmaps_photo_id', 1);

        return 0;
      } else {
        _logger.info(_self._fileName, "_getPhotoId() last id stored ".concat(id));

        return parseInt(id);
      }
    }
  }, {
    key: "_ClearProjectPhotos",
    value: function _ClearProjectPhotos(project_id) {
      _logger.info(_self._fileName, "_ClearPhotos".concat(project_id));

      var ofPhotos = _self._getPhotos(project_id);

      for (var i = 0; i < ofPhotos.length; i++) {
        _self._removePhoto(ofPhotos[i].photo_id);
      }
    }
  }, {
    key: "_removePhoto",
    value: function _removePhoto(photo_id) {
      _logger.info(_self._fileName, '_removePhoto', {
        'photo_id': photo_id
      });

      return new Promise(function (resolve, reject) {
        _storage.removeTile("photo_" + photo_id).then(function () {
          _logger.success(_self._fileName, "removed photo_".concat(photo_id, " from localForage")); //remove photo from list


          var currentPhotos = _self._getPhotos(_self.options.project_id);

          for (var i = 0; i < currentPhotos.length; i++) {
            if ("photo_".concat(currentPhotos[i].photo_id) === photo_id) {
              currentPhotos.splice(i, 1);
            }
          }

          _storage.setItem("bmaps_".concat(_self.options.project_id, "_photos"), JSON.stringify(currentPhotos));

          resolve();
        })["catch"](function (e) {
          _logger.error(_self._fileName, "Photo photo_".concat(photo_id, " error removing from localForage"), e);

          reject();
        });
      });
    }
  }, {
    key: "_updatePhotosVisitId",
    value: function _updatePhotosVisitId(pol_id, id_name, visit_id) {
      _logger.info(_self._fileName, '_updatePhotosVisitId', {
        'pol_id': pol_id,
        'id_name': id_name,
        'visit_id': visit_id
      });

      var ofPhotos = _self._getPhotos(_self.options.project_id);

      if (ofPhotos.length > 0) {
        for (var i = 0; i < ofPhotos.length; i++) {
          if (ofPhotos[i].pol_id == pol_id && ofPhotos[i].id_name == id_name) {
            ofPhotos[i].visit_id = visit_id;
          }
        }

        _storage.setItem("bmaps_".concat(_self.options.project_id, "_photos"), JSON.stringify(ofPhotos));
      }
    } //****************************************************************
    //*********************     END PHOTOS      **********************
    //****************************************************************

  }, {
    key: "storeDownloadDate",
    value: function storeDownloadDate() {
      _logger.info(_self._fileName, 'storeDownloadDate', {});

      _storage.setItem("bmaps_".concat(_self.options.project_id, "_lastDownload"), new Date().addHours(_self.options.off_download_data_ttl).toString());
    }
    /*
       //try to insert visit in DB and get real visit ID
    function InsertNextVisit(visit,_visit_events){
      log("InsertNextVisit("+visit+")","info",_visit_events);
      $rootScope.$broadcast('offlineEvent',{evt:"dumpData",text:"InsertNextVisit"});
      var ve					= _visit_events;
      ajaxMethodForVisit(ajax_target,visit.epsg,visit.pol_id,visit.coordinates,visit.layer,function(e,data){
        //remove visit from local storage
        removeVisit(visit.temporalId,function(){
          log("removeVisit("+visit.temporalId+") OK","success");
        },function(){
          log("removeVisit("+visit.temporalId+") KO","warn");
        });
        for(var e=0;e<ve.length;e++){
          //updates events visit id with real id (the one that cames from DB)
          updateEvent(ve[e],'visit_id',data.visit_id);
          //update photos id_visit
          updatePhotovisitId(ve[e].temporalEventId,data.visit_id);
        }
         var visit_events = getVisitEvents(data.visit_id);
        log("InsertNextVisit, initiate photos uploading in 1s","info");
        setTimeout(function(){
          if(visit_events.length>0){
            //inserts events in DB
            InsertNextEvent(data.visit_id);
          }
        },1000);
      },function(msg,data){
        log("InsertNextVisit :"+msg,"error",data);
      });
    }
    
     */

    /*function checkPreviousVisit(element_id,layer){
      log("checkPreviousVisit("+element_id+","+layer+")","info")
      var visits 			= mapStorage.getItem(storeName+'_visits');
      var exists			= false;
      if(visits){
        //check previous visits
        var parsedVisits = JSON.parse(visits);
        for(var i=0;i<parsedVisits.length;i++){
          var item = parsedVisits[i];
          if(item['temporalId']===layer+":"+element_id){
            exists 	= true;
            break;
          }
        }
      }
      return exists;
    }*/
    //******************    end checkPreviousVisit  ******************

    /*	function setEventId(id){
        log("setEventId("+id+")","info");
        _storage.setItem(`bmaps_${_options.project_id}_ov_${response.table}`,JSON.stringify(res));
        mapStorage.setItem(storeName+'_event_id',parseInt(id));
      }
    
      function getEventId(){
        log("getEventId()","info");
        var id = mapStorage.getItem(storeName+'_event_id');
        if(id===null){
          log("getEventId() not id stored","info");
          mapStorage.setItem(storeName+'_event_id',1);
          return 0;
        }else{
          log("getEventId() last id stored: "+id,"info");
          return parseInt(id);
        }
      }*/

  }]);

  return VisitsOffline;
}();

exports["default"] = VisitsOffline;

Date.prototype.addHours = function (h) {
  this.setHours(this.getHours() + h);
  return this;
};

},{"../forms/form_utils":5,"../src/richLogger":79,"./mapStorage":50,"axios":51}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* jshint esversion: 6 */

/* eslint-disable no-undef*/

/* eslint-disable no-restricted-globals*/
var RichLogger =
/*#__PURE__*/
function () {
  function RichLogger(env, options) {
    _classCallCheck(this, RichLogger);

    this._version = '2.0.1';
    this._options = {}; // colors

    this._warnColor = '#f57d00';
    this._infoColor = '#6574f7';
    this._successColor = '#07cb03';

    if (typeof env === 'undefined') {
      env = 'prod';
    }

    if (typeof options !== 'undefined') {
      this._options = options;
    }

    if (typeof this._options.baseHref !== 'undefined') {
      this._baseHref = _options.baseHref;
    } else {
      this._baseHref = null;
    }

    if (typeof this._options.token !== 'undefined') {
      this._token = _options.token;
    } else {
      this._token = null;
    } // colors


    if (typeof this._options.infoColor !== 'undefined') {
      this._infoColor = _options.infoColor;
    }

    if (typeof this._options.warnColor !== 'undefined') {
      this._warnColor = _options.warnColor;
    }

    if (typeof this._options.successColor !== 'undefined') {
      this._successColor = _options.successColor;
    }

    this._env = env;

    if (this._env === 'dev') {
      console.info("%cRichLogger.js: loaded v. ".concat(this._version), "color: ".concat(this._infoColor, ";"));
    }
  }

  _createClass(RichLogger, [{
    key: "info",
    value: function info(module, msg, optionalArg) {
      if (this._env === 'dev') {
        if (typeof optionalArg === 'undefined') {
          console.info("%c".concat(module, ": ").concat(msg), "color: ".concat(this._infoColor, ";"));
        } else {
          console.info("%c".concat(module, ": ").concat(msg), "color: ".concat(this._infoColor, ";"), optionalArg);
        }
      }
    }
  }, {
    key: "log",
    value: function log(moduleName, msg, extradata) {
      if (this._env === 'dev') {
        if (typeof extradata !== 'undefined') {
          console.log("".concat(moduleName, ": ").concat(msg), extradata);
        } else {
          console.log("".concat(moduleName, ": ").concat(msg));
        }
      }
    }
  }, {
    key: "warn",
    value: function warn(module, msg, optionalArg) {
      if (this._env === 'dev') {
        if (typeof optionalArg === 'undefined') {
          console.warn("%c".concat(module, ": ").concat(msg), "color: ".concat(this._warnColor, ";"));
        } else {
          console.warn("%c".concat(module, ": ").concat(msg), "color: ".concat(this._warnColor, ";"), optionalArg);
        }
      }
    }
  }, {
    key: "success",
    value: function success(module, msg, optionalArg) {
      if (this._env === 'dev') {
        if (typeof optionalArg === 'undefined') {
          console.log("%c".concat(module, ": ").concat(msg), "color: ".concat(this._successColor, ";font-weight: bold;"));
        } else {
          console.log("%c".concat(module, ": ").concat(msg), "color: ".concat(this._successColor, ";font-weight: bold;"), optionalArg);
        }
      }
    }
  }, {
    key: "error",
    value: function error(module, msg, optionalArg) {
      if (this._env === 'dev') {
        if (typeof optionalArg === 'undefined') {
          console.error(module, msg);
        } else {
          console.error(module, msg, optionalArg);
        }
      }
    }
  }]);

  return RichLogger;
}();

exports["default"] = RichLogger;

},{}],80:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);
  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

},{}],81:[function(require,module,exports){
"use strict";

},{}],82:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */
'use strict';

var base64 = require('base64-js');

var ieee754 = require('ieee754');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
} // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97


if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  return fromObject(value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  buf.__proto__ = Buffer.prototype;
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }

      return fromArrayLike(obj);
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true;
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding);
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`


function isArrayBufferView(obj) {
  return typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj);
}

function numberIsNaN(obj) {
  return obj !== obj; // eslint-disable-line no-self-compare
}

},{"base64-js":80,"ieee754":85}],83:[function(require,module,exports){
(function (Buffer){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":87}],84:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.

EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;
  if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.

  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];

      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];
  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;

      case 2:
        handler.call(this, arguments[1]);
        break;

      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower

      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;

    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events) this._events = {}; // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".

  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
  if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type])) // If we've already got an array, just append.
    this._events[type].push(listener);else // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener]; // Check for listener leak

  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);

      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);
  return this;
}; // emits a 'removeListener' event iff the listener was removed


EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events || !this._events[type]) return this;
  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;
  if (!this._events) return this; // not listening for removeListener, no need to emit

  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }

  delete this._events[type];
  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];
    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }

  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],85:[function(require,module,exports){
"use strict";

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],86:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],87:[function(require,module,exports){
"use strict";

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],88:[function(require,module,exports){
"use strict";

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],89:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

}).call(this,require('_process'))
},{"_process":90}],90:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

},{}],91:[function(require,module,exports){
"use strict";

module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":92}],92:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);
var keys = objectKeys(Writable.prototype);

for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
} // the no-half-open enforcer


function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":94,"./_stream_writable":96,"core-util-is":83,"inherits":86,"process-nextick-args":89}],93:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');
/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":95,"core-util-is":83,"inherits":86}],94:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;
/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/


var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var debugUtil = require('util');

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/BufferList');

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

  this.highWaterMark = ~~this.highWaterMark; // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.

  this.ranOut = false; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;
  if (options && typeof options.read === 'function') this._read = options.read;
  Stream.call(this);
} // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;

    if (encoding !== state.encoding) {
      chunk = Buffer.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);

  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');

      stream.emit('error', _e);
    } else {
      var skipAdd;

      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false; // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode

      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
} // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;

  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable) {
    debug('onunpipe');

    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;
  var self = this;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = self.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  self._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
}; // exposed for testing purposes only.


Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

}).call(this,require('_process'))
},{"./_stream_duplex":92,"./internal/streams/BufferList":97,"./internal/streams/stream":98,"_process":90,"core-util-is":83,"events":84,"inherits":86,"isarray":88,"process-nextick-args":89,"safe-buffer":103,"string_decoder/":105,"util":81}],95:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');
/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== undefined) stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data !== null && data !== undefined) stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
  if (ts.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

},{"./_stream_duplex":92,"core-util-is":83,"inherits":86}],96:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/


util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

  this.highWaterMark = ~~this.highWaterMark; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  processNextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = Buffer.isBuffer(chunk);

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
} // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.


function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;

    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;

    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }

    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}

}).call(this,require('_process'))
},{"./_stream_duplex":92,"./internal/streams/stream":98,"_process":90,"core-util-is":83,"inherits":86,"process-nextick-args":89,"safe-buffer":103,"util-deprecate":106}],97:[function(require,module,exports){
'use strict';
/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/


module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = {
    data: v,
    next: null
  };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = {
    data: v,
    next: this.head
  };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;

  while (p = p.next) {
    ret += s + p.data;
  }

  return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return Buffer.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;

  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }

  return ret;
};

},{"safe-buffer":103}],98:[function(require,module,exports){
"use strict";

module.exports = require('events').EventEmitter;

},{"events":84}],99:[function(require,module,exports){
"use strict";

module.exports = require('./readable').PassThrough;

},{"./readable":100}],100:[function(require,module,exports){
"use strict";

exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":92,"./lib/_stream_passthrough.js":93,"./lib/_stream_readable.js":94,"./lib/_stream_transform.js":95,"./lib/_stream_writable.js":96}],101:[function(require,module,exports){
"use strict";

module.exports = require('./readable').Transform;

},{"./readable":100}],102:[function(require,module,exports){
"use strict";

module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":96}],103:[function(require,module,exports){
"use strict";

module.exports = require('buffer');

},{"buffer":82}],104:[function(require,module,exports){
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = require('events').EventEmitter;

var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js'); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

},{"events":84,"inherits":86,"readable-stream/duplex.js":91,"readable-stream/passthrough.js":99,"readable-stream/readable.js":100,"readable-stream/transform.js":101,"readable-stream/writable.js":102}],105:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.


function utf8CheckByte(_byte) {
  if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;
  return -1;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD".repeat(p);
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD".repeat(p + 1);
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD".repeat(p + 2);
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD".repeat(this.lastTotal - this.lastNeed);
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":103}],106:[function(require,module,exports){
(function (global){
"use strict";

/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],107:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],108:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function isBuffer(arg) {
  return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

},{}],109:[function(require,module,exports){
(function (process,global){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":108,"_process":90,"inherits":107}]},{},[6]);
